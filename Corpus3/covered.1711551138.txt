/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/lib/ds-test/src/test.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | 
   3 |     | // This program is free software: you can redistribute it and/or modify
   4 |     | // it under the terms of the GNU General Public License as published by
   5 |     | // the Free Software Foundation, either version 3 of the License, or
   6 |     | // (at your option) any later version.
   7 |     | 
   8 |     | // This program is distributed in the hope that it will be useful,
   9 |     | // but WITHOUT ANY WARRANTY; without even the implied warranty of
  10 |     | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11 |     | // GNU General Public License for more details.
  12 |     | 
  13 |     | // You should have received a copy of the GNU General Public License
  14 |     | // along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15 |     | 
  16 |     | pragma solidity >=0.5.0;
  17 |     | 
  18 |     | contract DSTest {
  19 |     |     event log                    (string);
  20 |     |     event logs                   (bytes);
  21 |     | 
  22 |     |     event log_address            (address);
  23 |     |     event log_bytes32            (bytes32);
  24 |     |     event log_int                (int);
  25 |     |     event log_uint               (uint);
  26 |     |     event log_bytes              (bytes);
  27 |     |     event log_string             (string);
  28 |     | 
  29 |     |     event log_named_address      (string key, address val);
  30 |     |     event log_named_bytes32      (string key, bytes32 val);
  31 |     |     event log_named_decimal_int  (string key, int val, uint decimals);
  32 |     |     event log_named_decimal_uint (string key, uint val, uint decimals);
  33 |     |     event log_named_int          (string key, int val);
  34 |     |     event log_named_uint         (string key, uint val);
  35 |     |     event log_named_bytes        (string key, bytes val);
  36 |     |     event log_named_string       (string key, string val);
  37 |     | 
  38 |     |     bool public IS_TEST = true;
  39 |     |     bool private _failed;
  40 |     | 
  41 |     |     address constant HEVM_ADDRESS =
  42 |     |         address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));
  43 |     | 
  44 |     |     modifier mayRevert() { _; }
  45 |     |     modifier testopts(string memory) { _; }
  46 |     | 
  47 |     |     function failed() public returns (bool) {
  48 |     |         if (_failed) {
  49 |     |             return _failed;
  50 |     |         } else {
  51 |     |             bool globalFailed = false;
  52 |     |             if (hasHEVMContext()) {
  53 |     |                 (, bytes memory retdata) = HEVM_ADDRESS.call(
  54 |     |                     abi.encodePacked(
  55 |     |                         bytes4(keccak256("load(address,bytes32)")),
  56 |     |                         abi.encode(HEVM_ADDRESS, bytes32("failed"))
  57 |     |                     )
  58 |     |                 );
  59 |     |                 globalFailed = abi.decode(retdata, (bool));
  60 |     |             }
  61 |     |             return globalFailed;
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 |     |     function fail() internal virtual {
  66 |     |         if (hasHEVMContext()) {
  67 |     |             (bool status, ) = HEVM_ADDRESS.call(
  68 |     |                 abi.encodePacked(
  69 |     |                     bytes4(keccak256("store(address,bytes32,bytes32)")),
  70 |     |                     abi.encode(HEVM_ADDRESS, bytes32("failed"), bytes32(uint256(0x01)))
  71 |     |                 )
  72 |     |             );
  73 |     |             status; // Silence compiler warnings
  74 |     |         }
  75 |     |         _failed = true;
  76 |     |     }
  77 |     | 
  78 |     |     function hasHEVMContext() internal view returns (bool) {
  79 |     |         uint256 hevmCodeSize = 0;
  80 |     |         assembly {
  81 |     |             hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)
  82 |     |         }
  83 |     |         return hevmCodeSize > 0;
  84 |     |     }
  85 |     | 
  86 |     |     modifier logs_gas() {
  87 |     |         uint startGas = gasleft();
  88 |     |         _;
  89 |     |         uint endGas = gasleft();
  90 |     |         emit log_named_uint("gas", startGas - endGas);
  91 |     |     }
  92 |     | 
  93 |     |     function assertTrue(bool condition) internal {
  94 |     |         if (!condition) {
  95 |     |             emit log("Error: Assertion Failed");
  96 |     |             fail();
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     function assertTrue(bool condition, string memory err) internal {
 101 |     |         if (!condition) {
 102 |     |             emit log_named_string("Error", err);
 103 |     |             assertTrue(condition);
 104 |     |         }
 105 |     |     }
 106 |     | 
 107 |     |     function assertEq(address a, address b) internal {
 108 |     |         if (a != b) {
 109 |     |             emit log("Error: a == b not satisfied [address]");
 110 |     |             emit log_named_address("      Left", a);
 111 |     |             emit log_named_address("     Right", b);
 112 |     |             fail();
 113 |     |         }
 114 |     |     }
 115 |     |     function assertEq(address a, address b, string memory err) internal {
 116 |     |         if (a != b) {
 117 |     |             emit log_named_string ("Error", err);
 118 |     |             assertEq(a, b);
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     function assertEq(bytes32 a, bytes32 b) internal {
 123 |     |         if (a != b) {
 124 |     |             emit log("Error: a == b not satisfied [bytes32]");
 125 |     |             emit log_named_bytes32("      Left", a);
 126 |     |             emit log_named_bytes32("     Right", b);
 127 |     |             fail();
 128 |     |         }
 129 |     |     }
 130 |     |     function assertEq(bytes32 a, bytes32 b, string memory err) internal {
 131 |     |         if (a != b) {
 132 |     |             emit log_named_string ("Error", err);
 133 |     |             assertEq(a, b);
 134 |     |         }
 135 |     |     }
 136 |     |     function assertEq32(bytes32 a, bytes32 b) internal {
 137 |     |         assertEq(a, b);
 138 |     |     }
 139 |     |     function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
 140 |     |         assertEq(a, b, err);
 141 |     |     }
 142 |     | 
 143 |     |     function assertEq(int a, int b) internal {
 144 |     |         if (a != b) {
 145 |     |             emit log("Error: a == b not satisfied [int]");
 146 |     |             emit log_named_int("      Left", a);
 147 |     |             emit log_named_int("     Right", b);
 148 |     |             fail();
 149 |     |         }
 150 |     |     }
 151 |     |     function assertEq(int a, int b, string memory err) internal {
 152 |     |         if (a != b) {
 153 |     |             emit log_named_string("Error", err);
 154 |     |             assertEq(a, b);
 155 |     |         }
 156 |     |     }
 157 |     |     function assertEq(uint a, uint b) internal {
 158 |     |         if (a != b) {
 159 |     |             emit log("Error: a == b not satisfied [uint]");
 160 |     |             emit log_named_uint("      Left", a);
 161 |     |             emit log_named_uint("     Right", b);
 162 |     |             fail();
 163 |     |         }
 164 |     |     }
 165 |     |     function assertEq(uint a, uint b, string memory err) internal {
 166 |     |         if (a != b) {
 167 |     |             emit log_named_string("Error", err);
 168 |     |             assertEq(a, b);
 169 |     |         }
 170 |     |     }
 171 |     |     function assertEqDecimal(int a, int b, uint decimals) internal {
 172 |     |         if (a != b) {
 173 |     |             emit log("Error: a == b not satisfied [decimal int]");
 174 |     |             emit log_named_decimal_int("      Left", a, decimals);
 175 |     |             emit log_named_decimal_int("     Right", b, decimals);
 176 |     |             fail();
 177 |     |         }
 178 |     |     }
 179 |     |     function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
 180 |     |         if (a != b) {
 181 |     |             emit log_named_string("Error", err);
 182 |     |             assertEqDecimal(a, b, decimals);
 183 |     |         }
 184 |     |     }
 185 |     |     function assertEqDecimal(uint a, uint b, uint decimals) internal {
 186 |     |         if (a != b) {
 187 |     |             emit log("Error: a == b not satisfied [decimal uint]");
 188 |     |             emit log_named_decimal_uint("      Left", a, decimals);
 189 |     |             emit log_named_decimal_uint("     Right", b, decimals);
 190 |     |             fail();
 191 |     |         }
 192 |     |     }
 193 |     |     function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
 194 |     |         if (a != b) {
 195 |     |             emit log_named_string("Error", err);
 196 |     |             assertEqDecimal(a, b, decimals);
 197 |     |         }
 198 |     |     }
 199 |     | 
 200 |     |     function assertNotEq(address a, address b) internal {
 201 |     |         if (a == b) {
 202 |     |             emit log("Error: a != b not satisfied [address]");
 203 |     |             emit log_named_address("      Left", a);
 204 |     |             emit log_named_address("     Right", b);
 205 |     |             fail();
 206 |     |         }
 207 |     |     }
 208 |     |     function assertNotEq(address a, address b, string memory err) internal {
 209 |     |         if (a == b) {
 210 |     |             emit log_named_string ("Error", err);
 211 |     |             assertNotEq(a, b);
 212 |     |         }
 213 |     |     }
 214 |     | 
 215 |     |     function assertNotEq(bytes32 a, bytes32 b) internal {
 216 |     |         if (a == b) {
 217 |     |             emit log("Error: a != b not satisfied [bytes32]");
 218 |     |             emit log_named_bytes32("      Left", a);
 219 |     |             emit log_named_bytes32("     Right", b);
 220 |     |             fail();
 221 |     |         }
 222 |     |     }
 223 |     |     function assertNotEq(bytes32 a, bytes32 b, string memory err) internal {
 224 |     |         if (a == b) {
 225 |     |             emit log_named_string ("Error", err);
 226 |     |             assertNotEq(a, b);
 227 |     |         }
 228 |     |     }
 229 |     |     function assertNotEq32(bytes32 a, bytes32 b) internal {
 230 |     |         assertNotEq(a, b);
 231 |     |     }
 232 |     |     function assertNotEq32(bytes32 a, bytes32 b, string memory err) internal {
 233 |     |         assertNotEq(a, b, err);
 234 |     |     }
 235 |     | 
 236 |     |     function assertNotEq(int a, int b) internal {
 237 |     |         if (a == b) {
 238 |     |             emit log("Error: a != b not satisfied [int]");
 239 |     |             emit log_named_int("      Left", a);
 240 |     |             emit log_named_int("     Right", b);
 241 |     |             fail();
 242 |     |         }
 243 |     |     }
 244 |     |     function assertNotEq(int a, int b, string memory err) internal {
 245 |     |         if (a == b) {
 246 |     |             emit log_named_string("Error", err);
 247 |     |             assertNotEq(a, b);
 248 |     |         }
 249 |     |     }
 250 |     |     function assertNotEq(uint a, uint b) internal {
 251 |     |         if (a == b) {
 252 |     |             emit log("Error: a != b not satisfied [uint]");
 253 |     |             emit log_named_uint("      Left", a);
 254 |     |             emit log_named_uint("     Right", b);
 255 |     |             fail();
 256 |     |         }
 257 |     |     }
 258 |     |     function assertNotEq(uint a, uint b, string memory err) internal {
 259 |     |         if (a == b) {
 260 |     |             emit log_named_string("Error", err);
 261 |     |             assertNotEq(a, b);
 262 |     |         }
 263 |     |     }
 264 |     |     function assertNotEqDecimal(int a, int b, uint decimals) internal {
 265 |     |         if (a == b) {
 266 |     |             emit log("Error: a != b not satisfied [decimal int]");
 267 |     |             emit log_named_decimal_int("      Left", a, decimals);
 268 |     |             emit log_named_decimal_int("     Right", b, decimals);
 269 |     |             fail();
 270 |     |         }
 271 |     |     }
 272 |     |     function assertNotEqDecimal(int a, int b, uint decimals, string memory err) internal {
 273 |     |         if (a == b) {
 274 |     |             emit log_named_string("Error", err);
 275 |     |             assertNotEqDecimal(a, b, decimals);
 276 |     |         }
 277 |     |     }
 278 |     |     function assertNotEqDecimal(uint a, uint b, uint decimals) internal {
 279 |     |         if (a == b) {
 280 |     |             emit log("Error: a != b not satisfied [decimal uint]");
 281 |     |             emit log_named_decimal_uint("      Left", a, decimals);
 282 |     |             emit log_named_decimal_uint("     Right", b, decimals);
 283 |     |             fail();
 284 |     |         }
 285 |     |     }
 286 |     |     function assertNotEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
 287 |     |         if (a == b) {
 288 |     |             emit log_named_string("Error", err);
 289 |     |             assertNotEqDecimal(a, b, decimals);
 290 |     |         }
 291 |     |     }
 292 |     | 
 293 |     |     function assertGt(uint a, uint b) internal {
 294 |     |         if (a <= b) {
 295 |     |             emit log("Error: a > b not satisfied [uint]");
 296 |     |             emit log_named_uint("  Value a", a);
 297 |     |             emit log_named_uint("  Value b", b);
 298 |     |             fail();
 299 |     |         }
 300 |     |     }
 301 |     |     function assertGt(uint a, uint b, string memory err) internal {
 302 |     |         if (a <= b) {
 303 |     |             emit log_named_string("Error", err);
 304 |     |             assertGt(a, b);
 305 |     |         }
 306 |     |     }
 307 |     |     function assertGt(int a, int b) internal {
 308 |     |         if (a <= b) {
 309 |     |             emit log("Error: a > b not satisfied [int]");
 310 |     |             emit log_named_int("  Value a", a);
 311 |     |             emit log_named_int("  Value b", b);
 312 |     |             fail();
 313 |     |         }
 314 |     |     }
 315 |     |     function assertGt(int a, int b, string memory err) internal {
 316 |     |         if (a <= b) {
 317 |     |             emit log_named_string("Error", err);
 318 |     |             assertGt(a, b);
 319 |     |         }
 320 |     |     }
 321 |     |     function assertGtDecimal(int a, int b, uint decimals) internal {
 322 |     |         if (a <= b) {
 323 |     |             emit log("Error: a > b not satisfied [decimal int]");
 324 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 325 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 326 |     |             fail();
 327 |     |         }
 328 |     |     }
 329 |     |     function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
 330 |     |         if (a <= b) {
 331 |     |             emit log_named_string("Error", err);
 332 |     |             assertGtDecimal(a, b, decimals);
 333 |     |         }
 334 |     |     }
 335 |     |     function assertGtDecimal(uint a, uint b, uint decimals) internal {
 336 |     |         if (a <= b) {
 337 |     |             emit log("Error: a > b not satisfied [decimal uint]");
 338 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 339 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 340 |     |             fail();
 341 |     |         }
 342 |     |     }
 343 |     |     function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
 344 |     |         if (a <= b) {
 345 |     |             emit log_named_string("Error", err);
 346 |     |             assertGtDecimal(a, b, decimals);
 347 |     |         }
 348 |     |     }
 349 |     | 
 350 |     |     function assertGe(uint a, uint b) internal {
 351 |     |         if (a < b) {
 352 |     |             emit log("Error: a >= b not satisfied [uint]");
 353 |     |             emit log_named_uint("  Value a", a);
 354 |     |             emit log_named_uint("  Value b", b);
 355 |     |             fail();
 356 |     |         }
 357 |     |     }
 358 |     |     function assertGe(uint a, uint b, string memory err) internal {
 359 |     |         if (a < b) {
 360 |     |             emit log_named_string("Error", err);
 361 |     |             assertGe(a, b);
 362 |     |         }
 363 |     |     }
 364 |     |     function assertGe(int a, int b) internal {
 365 |     |         if (a < b) {
 366 |     |             emit log("Error: a >= b not satisfied [int]");
 367 |     |             emit log_named_int("  Value a", a);
 368 |     |             emit log_named_int("  Value b", b);
 369 |     |             fail();
 370 |     |         }
 371 |     |     }
 372 |     |     function assertGe(int a, int b, string memory err) internal {
 373 |     |         if (a < b) {
 374 |     |             emit log_named_string("Error", err);
 375 |     |             assertGe(a, b);
 376 |     |         }
 377 |     |     }
 378 |     |     function assertGeDecimal(int a, int b, uint decimals) internal {
 379 |     |         if (a < b) {
 380 |     |             emit log("Error: a >= b not satisfied [decimal int]");
 381 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 382 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 383 |     |             fail();
 384 |     |         }
 385 |     |     }
 386 |     |     function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
 387 |     |         if (a < b) {
 388 |     |             emit log_named_string("Error", err);
 389 |     |             assertGeDecimal(a, b, decimals);
 390 |     |         }
 391 |     |     }
 392 |     |     function assertGeDecimal(uint a, uint b, uint decimals) internal {
 393 |     |         if (a < b) {
 394 |     |             emit log("Error: a >= b not satisfied [decimal uint]");
 395 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 396 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 397 |     |             fail();
 398 |     |         }
 399 |     |     }
 400 |     |     function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
 401 |     |         if (a < b) {
 402 |     |             emit log_named_string("Error", err);
 403 |     |             assertGeDecimal(a, b, decimals);
 404 |     |         }
 405 |     |     }
 406 |     | 
 407 |     |     function assertLt(uint a, uint b) internal {
 408 |     |         if (a >= b) {
 409 |     |             emit log("Error: a < b not satisfied [uint]");
 410 |     |             emit log_named_uint("  Value a", a);
 411 |     |             emit log_named_uint("  Value b", b);
 412 |     |             fail();
 413 |     |         }
 414 |     |     }
 415 |     |     function assertLt(uint a, uint b, string memory err) internal {
 416 |     |         if (a >= b) {
 417 |     |             emit log_named_string("Error", err);
 418 |     |             assertLt(a, b);
 419 |     |         }
 420 |     |     }
 421 |     |     function assertLt(int a, int b) internal {
 422 |     |         if (a >= b) {
 423 |     |             emit log("Error: a < b not satisfied [int]");
 424 |     |             emit log_named_int("  Value a", a);
 425 |     |             emit log_named_int("  Value b", b);
 426 |     |             fail();
 427 |     |         }
 428 |     |     }
 429 |     |     function assertLt(int a, int b, string memory err) internal {
 430 |     |         if (a >= b) {
 431 |     |             emit log_named_string("Error", err);
 432 |     |             assertLt(a, b);
 433 |     |         }
 434 |     |     }
 435 |     |     function assertLtDecimal(int a, int b, uint decimals) internal {
 436 |     |         if (a >= b) {
 437 |     |             emit log("Error: a < b not satisfied [decimal int]");
 438 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 439 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 440 |     |             fail();
 441 |     |         }
 442 |     |     }
 443 |     |     function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
 444 |     |         if (a >= b) {
 445 |     |             emit log_named_string("Error", err);
 446 |     |             assertLtDecimal(a, b, decimals);
 447 |     |         }
 448 |     |     }
 449 |     |     function assertLtDecimal(uint a, uint b, uint decimals) internal {
 450 |     |         if (a >= b) {
 451 |     |             emit log("Error: a < b not satisfied [decimal uint]");
 452 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 453 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 454 |     |             fail();
 455 |     |         }
 456 |     |     }
 457 |     |     function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
 458 |     |         if (a >= b) {
 459 |     |             emit log_named_string("Error", err);
 460 |     |             assertLtDecimal(a, b, decimals);
 461 |     |         }
 462 |     |     }
 463 |     | 
 464 |     |     function assertLe(uint a, uint b) internal {
 465 |     |         if (a > b) {
 466 |     |             emit log("Error: a <= b not satisfied [uint]");
 467 |     |             emit log_named_uint("  Value a", a);
 468 |     |             emit log_named_uint("  Value b", b);
 469 |     |             fail();
 470 |     |         }
 471 |     |     }
 472 |     |     function assertLe(uint a, uint b, string memory err) internal {
 473 |     |         if (a > b) {
 474 |     |             emit log_named_string("Error", err);
 475 |     |             assertLe(a, b);
 476 |     |         }
 477 |     |     }
 478 |     |     function assertLe(int a, int b) internal {
 479 |     |         if (a > b) {
 480 |     |             emit log("Error: a <= b not satisfied [int]");
 481 |     |             emit log_named_int("  Value a", a);
 482 |     |             emit log_named_int("  Value b", b);
 483 |     |             fail();
 484 |     |         }
 485 |     |     }
 486 |     |     function assertLe(int a, int b, string memory err) internal {
 487 |     |         if (a > b) {
 488 |     |             emit log_named_string("Error", err);
 489 |     |             assertLe(a, b);
 490 |     |         }
 491 |     |     }
 492 |     |     function assertLeDecimal(int a, int b, uint decimals) internal {
 493 |     |         if (a > b) {
 494 |     |             emit log("Error: a <= b not satisfied [decimal int]");
 495 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 496 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 497 |     |             fail();
 498 |     |         }
 499 |     |     }
 500 |     |     function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
 501 |     |         if (a > b) {
 502 |     |             emit log_named_string("Error", err);
 503 |     |             assertLeDecimal(a, b, decimals);
 504 |     |         }
 505 |     |     }
 506 |     |     function assertLeDecimal(uint a, uint b, uint decimals) internal {
 507 |     |         if (a > b) {
 508 |     |             emit log("Error: a <= b not satisfied [decimal uint]");
 509 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 510 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 511 |     |             fail();
 512 |     |         }
 513 |     |     }
 514 |     |     function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
 515 |     |         if (a > b) {
 516 |     |             emit log_named_string("Error", err);
 517 |     |             assertLeDecimal(a, b, decimals);
 518 |     |         }
 519 |     |     }
 520 |     | 
 521 |     |     function assertEq(string memory a, string memory b) internal {
 522 |     |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
 523 |     |             emit log("Error: a == b not satisfied [string]");
 524 |     |             emit log_named_string("      Left", a);
 525 |     |             emit log_named_string("     Right", b);
 526 |     |             fail();
 527 |     |         }
 528 |     |     }
 529 |     |     function assertEq(string memory a, string memory b, string memory err) internal {
 530 |     |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
 531 |     |             emit log_named_string("Error", err);
 532 |     |             assertEq(a, b);
 533 |     |         }
 534 |     |     }
 535 |     | 
 536 |     |     function assertNotEq(string memory a, string memory b) internal {
 537 |     |         if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {
 538 |     |             emit log("Error: a != b not satisfied [string]");
 539 |     |             emit log_named_string("      Left", a);
 540 |     |             emit log_named_string("     Right", b);
 541 |     |             fail();
 542 |     |         }
 543 |     |     }
 544 |     |     function assertNotEq(string memory a, string memory b, string memory err) internal {
 545 |     |         if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {
 546 |     |             emit log_named_string("Error", err);
 547 |     |             assertNotEq(a, b);
 548 |     |         }
 549 |     |     }
 550 |     | 
 551 |     |     function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
 552 |     |         ok = true;
 553 |     |         if (a.length == b.length) {
 554 |     |             for (uint i = 0; i < a.length; i++) {
 555 |     |                 if (a[i] != b[i]) {
 556 |     |                     ok = false;
 557 |     |                 }
 558 |     |             }
 559 |     |         } else {
 560 |     |             ok = false;
 561 |     |         }
 562 |     |     }
 563 |     |     function assertEq0(bytes memory a, bytes memory b) internal {
 564 |     |         if (!checkEq0(a, b)) {
 565 |     |             emit log("Error: a == b not satisfied [bytes]");
 566 |     |             emit log_named_bytes("      Left", a);
 567 |     |             emit log_named_bytes("     Right", b);
 568 |     |             fail();
 569 |     |         }
 570 |     |     }
 571 |     |     function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
 572 |     |         if (!checkEq0(a, b)) {
 573 |     |             emit log_named_string("Error", err);
 574 |     |             assertEq0(a, b);
 575 |     |         }
 576 |     |     }
 577 |     | 
 578 |     |     function assertNotEq0(bytes memory a, bytes memory b) internal {
 579 |     |         if (checkEq0(a, b)) {
 580 |     |             emit log("Error: a != b not satisfied [bytes]");
 581 |     |             emit log_named_bytes("      Left", a);
 582 |     |             emit log_named_bytes("     Right", b);
 583 |     |             fail();
 584 |     |         }
 585 |     |     }
 586 |     |     function assertNotEq0(bytes memory a, bytes memory b, string memory err) internal {
 587 |     |         if (checkEq0(a, b)) {
 588 |     |             emit log_named_string("Error", err);
 589 |     |             assertNotEq0(a, b);
 590 |     |         }
 591 |     |     }
 592 |     | }
 593 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/Base.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {StdStorage} from "./StdStorage.sol";
  5 |     | import {Vm, VmSafe} from "./Vm.sol";
  6 |     | 
  7 |     | abstract contract CommonBase {
  8 |     |     // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.
  9 |     |     address internal constant VM_ADDRESS = address(uint160(uint256(keccak256("hevm cheat code"))));
 10 |     |     // console.sol and console2.sol work by executing a staticcall to this address.
 11 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 12 |     |     // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
 13 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 14 |     |     // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.
 15 |     |     address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256("foundry default caller"))));
 16 |     |     // Address of the test contract, deployed by the DEFAULT_SENDER.
 17 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 18 |     |     // Deterministic deployment address of the Multicall3 contract.
 19 |     |     address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;
 20 |     |     // The order of the secp256k1 curve.
 21 |     |     uint256 internal constant SECP256K1_ORDER =
 22 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
 23 |     | 
 24 |     |     uint256 internal constant UINT256_MAX =
 25 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
 26 |     | 
 27 |     |     Vm internal constant vm = Vm(VM_ADDRESS);
 28 |     |     StdStorage internal stdstore;
 29 |     | }
 30 |     | 
 31 |     | abstract contract TestBase is CommonBase {}
 32 |     | 
 33 |     | abstract contract ScriptBase is CommonBase {
 34 |     |     VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);
 35 |     | }
 36 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/Script.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | // 💬 ABOUT
  5 |     | // Forge Std's default Script.
  6 |     | 
  7 |     | // 🧩 MODULES
  8 |     | import {console} from "./console.sol";
  9 |     | import {console2} from "./console2.sol";
 10 |     | import {safeconsole} from "./safeconsole.sol";
 11 |     | import {StdChains} from "./StdChains.sol";
 12 |     | import {StdCheatsSafe} from "./StdCheats.sol";
 13 |     | import {stdJson} from "./StdJson.sol";
 14 |     | import {stdMath} from "./StdMath.sol";
 15 |     | import {StdStorage, stdStorageSafe} from "./StdStorage.sol";
 16 |     | import {StdStyle} from "./StdStyle.sol";
 17 |     | import {StdUtils} from "./StdUtils.sol";
 18 |     | import {VmSafe} from "./Vm.sol";
 19 |     | 
 20 |     | // 📦 BOILERPLATE
 21 |     | import {ScriptBase} from "./Base.sol";
 22 |     | 
 23 |     | // ⭐️ SCRIPT
 24 |     | abstract contract Script is ScriptBase, StdChains, StdCheatsSafe, StdUtils {
 25 |     |     // Note: IS_SCRIPT() must return true.
 26 |     |     bool public IS_SCRIPT = true;
 27 |     | }
 28 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/StdAssertions.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {DSTest} from "ds-test/test.sol";
   5 |     | import {stdMath} from "./StdMath.sol";
   6 |     | 
   7 |     | abstract contract StdAssertions is DSTest {
   8 |     |     event log_array(uint256[] val);
   9 |     |     event log_array(int256[] val);
  10 |     |     event log_array(address[] val);
  11 |     |     event log_named_array(string key, uint256[] val);
  12 |     |     event log_named_array(string key, int256[] val);
  13 |     |     event log_named_array(string key, address[] val);
  14 |     | 
  15 |     |     function fail(string memory err) internal virtual {
  16 |     |         emit log_named_string("Error", err);
  17 |     |         fail();
  18 |     |     }
  19 |     | 
  20 |     |     function assertFalse(bool data) internal virtual {
  21 |     |         assertTrue(!data);
  22 |     |     }
  23 |     | 
  24 |     |     function assertFalse(bool data, string memory err) internal virtual {
  25 |     |         assertTrue(!data, err);
  26 |     |     }
  27 |     | 
  28 |     |     function assertEq(bool a, bool b) internal virtual {
  29 |     |         if (a != b) {
  30 |     |             emit log("Error: a == b not satisfied [bool]");
  31 |     |             emit log_named_string("      Left", a ? "true" : "false");
  32 |     |             emit log_named_string("     Right", b ? "true" : "false");
  33 |     |             fail();
  34 |     |         }
  35 |     |     }
  36 |     | 
  37 |     |     function assertEq(bool a, bool b, string memory err) internal virtual {
  38 |     |         if (a != b) {
  39 |     |             emit log_named_string("Error", err);
  40 |     |             assertEq(a, b);
  41 |     |         }
  42 |     |     }
  43 |     | 
  44 |     |     function assertEq(bytes memory a, bytes memory b) internal virtual {
  45 |     |         assertEq0(a, b);
  46 |     |     }
  47 |     | 
  48 |     |     function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {
  49 |     |         assertEq0(a, b, err);
  50 |     |     }
  51 |     | 
  52 |     |     function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {
  53 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  54 |     |             emit log("Error: a == b not satisfied [uint[]]");
  55 |     |             emit log_named_array("      Left", a);
  56 |     |             emit log_named_array("     Right", b);
  57 |     |             fail();
  58 |     |         }
  59 |     |     }
  60 |     | 
  61 |     |     function assertEq(int256[] memory a, int256[] memory b) internal virtual {
  62 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  63 |     |             emit log("Error: a == b not satisfied [int[]]");
  64 |     |             emit log_named_array("      Left", a);
  65 |     |             emit log_named_array("     Right", b);
  66 |     |             fail();
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     function assertEq(address[] memory a, address[] memory b) internal virtual {
  71 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  72 |     |             emit log("Error: a == b not satisfied [address[]]");
  73 |     |             emit log_named_array("      Left", a);
  74 |     |             emit log_named_array("     Right", b);
  75 |     |             fail();
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {
  80 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  81 |     |             emit log_named_string("Error", err);
  82 |     |             assertEq(a, b);
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {
  87 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  88 |     |             emit log_named_string("Error", err);
  89 |     |             assertEq(a, b);
  90 |     |         }
  91 |     |     }
  92 |     | 
  93 |     |     function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {
  94 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  95 |     |             emit log_named_string("Error", err);
  96 |     |             assertEq(a, b);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     // Legacy helper
 101 |     |     function assertEqUint(uint256 a, uint256 b) internal virtual {
 102 |     |         assertEq(uint256(a), uint256(b));
 103 |     |     }
 104 |     | 
 105 |     |     function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {
 106 |     |         uint256 delta = stdMath.delta(a, b);
 107 |     | 
 108 |     |         if (delta > maxDelta) {
 109 |     |             emit log("Error: a ~= b not satisfied [uint]");
 110 |     |             emit log_named_uint("      Left", a);
 111 |     |             emit log_named_uint("     Right", b);
 112 |     |             emit log_named_uint(" Max Delta", maxDelta);
 113 |     |             emit log_named_uint("     Delta", delta);
 114 |     |             fail();
 115 |     |         }
 116 |     |     }
 117 |     | 
 118 |     |     function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {
 119 |     |         uint256 delta = stdMath.delta(a, b);
 120 |     | 
 121 |     |         if (delta > maxDelta) {
 122 |     |             emit log_named_string("Error", err);
 123 |     |             assertApproxEqAbs(a, b, maxDelta);
 124 |     |         }
 125 |     |     }
 126 |     | 
 127 |     |     function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {
 128 |     |         uint256 delta = stdMath.delta(a, b);
 129 |     | 
 130 |     |         if (delta > maxDelta) {
 131 |     |             emit log("Error: a ~= b not satisfied [uint]");
 132 |     |             emit log_named_decimal_uint("      Left", a, decimals);
 133 |     |             emit log_named_decimal_uint("     Right", b, decimals);
 134 |     |             emit log_named_decimal_uint(" Max Delta", maxDelta, decimals);
 135 |     |             emit log_named_decimal_uint("     Delta", delta, decimals);
 136 |     |             fail();
 137 |     |         }
 138 |     |     }
 139 |     | 
 140 |     |     function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)
 141 |     |         internal
 142 |     |         virtual
 143 |     |     {
 144 |     |         uint256 delta = stdMath.delta(a, b);
 145 |     | 
 146 |     |         if (delta > maxDelta) {
 147 |     |             emit log_named_string("Error", err);
 148 |     |             assertApproxEqAbsDecimal(a, b, maxDelta, decimals);
 149 |     |         }
 150 |     |     }
 151 |     | 
 152 |     |     function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {
 153 |     |         uint256 delta = stdMath.delta(a, b);
 154 |     | 
 155 |     |         if (delta > maxDelta) {
 156 |     |             emit log("Error: a ~= b not satisfied [int]");
 157 |     |             emit log_named_int("       Left", a);
 158 |     |             emit log_named_int("      Right", b);
 159 |     |             emit log_named_uint(" Max Delta", maxDelta);
 160 |     |             emit log_named_uint("     Delta", delta);
 161 |     |             fail();
 162 |     |         }
 163 |     |     }
 164 |     | 
 165 |     |     function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {
 166 |     |         uint256 delta = stdMath.delta(a, b);
 167 |     | 
 168 |     |         if (delta > maxDelta) {
 169 |     |             emit log_named_string("Error", err);
 170 |     |             assertApproxEqAbs(a, b, maxDelta);
 171 |     |         }
 172 |     |     }
 173 |     | 
 174 |     |     function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {
 175 |     |         uint256 delta = stdMath.delta(a, b);
 176 |     | 
 177 |     |         if (delta > maxDelta) {
 178 |     |             emit log("Error: a ~= b not satisfied [int]");
 179 |     |             emit log_named_decimal_int("      Left", a, decimals);
 180 |     |             emit log_named_decimal_int("     Right", b, decimals);
 181 |     |             emit log_named_decimal_uint(" Max Delta", maxDelta, decimals);
 182 |     |             emit log_named_decimal_uint("     Delta", delta, decimals);
 183 |     |             fail();
 184 |     |         }
 185 |     |     }
 186 |     | 
 187 |     |     function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)
 188 |     |         internal
 189 |     |         virtual
 190 |     |     {
 191 |     |         uint256 delta = stdMath.delta(a, b);
 192 |     | 
 193 |     |         if (delta > maxDelta) {
 194 |     |             emit log_named_string("Error", err);
 195 |     |             assertApproxEqAbsDecimal(a, b, maxDelta, decimals);
 196 |     |         }
 197 |     |     }
 198 |     | 
 199 |     |     function assertApproxEqRel(
 200 |     |         uint256 a,
 201 |     |         uint256 b,
 202 |     |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
 203 |     |     ) internal virtual {
 204 |     |         if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.
 205 |     | 
 206 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 207 |     | 
 208 |     |         if (percentDelta > maxPercentDelta) {
 209 |     |             emit log("Error: a ~= b not satisfied [uint]");
 210 |     |             emit log_named_uint("        Left", a);
 211 |     |             emit log_named_uint("       Right", b);
 212 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta * 100, 18);
 213 |     |             emit log_named_decimal_uint("     % Delta", percentDelta * 100, 18);
 214 |     |             fail();
 215 |     |         }
 216 |     |     }
 217 |     | 
 218 |     |     function assertApproxEqRel(
 219 |     |         uint256 a,
 220 |     |         uint256 b,
 221 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 222 |     |         string memory err
 223 |     |     ) internal virtual {
 224 |     |         if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.
 225 |     | 
 226 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 227 |     | 
 228 |     |         if (percentDelta > maxPercentDelta) {
 229 |     |             emit log_named_string("Error", err);
 230 |     |             assertApproxEqRel(a, b, maxPercentDelta);
 231 |     |         }
 232 |     |     }
 233 |     | 
 234 |     |     function assertApproxEqRelDecimal(
 235 |     |         uint256 a,
 236 |     |         uint256 b,
 237 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 238 |     |         uint256 decimals
 239 |     |     ) internal virtual {
 240 |     |         if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.
 241 |     | 
 242 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 243 |     | 
 244 |     |         if (percentDelta > maxPercentDelta) {
 245 |     |             emit log("Error: a ~= b not satisfied [uint]");
 246 |     |             emit log_named_decimal_uint("        Left", a, decimals);
 247 |     |             emit log_named_decimal_uint("       Right", b, decimals);
 248 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta * 100, 18);
 249 |     |             emit log_named_decimal_uint("     % Delta", percentDelta * 100, 18);
 250 |     |             fail();
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     function assertApproxEqRelDecimal(
 255 |     |         uint256 a,
 256 |     |         uint256 b,
 257 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 258 |     |         uint256 decimals,
 259 |     |         string memory err
 260 |     |     ) internal virtual {
 261 |     |         if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.
 262 |     | 
 263 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 264 |     | 
 265 |     |         if (percentDelta > maxPercentDelta) {
 266 |     |             emit log_named_string("Error", err);
 267 |     |             assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);
 268 |     |         }
 269 |     |     }
 270 |     | 
 271 |     |     function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {
 272 |     |         if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.
 273 |     | 
 274 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 275 |     | 
 276 |     |         if (percentDelta > maxPercentDelta) {
 277 |     |             emit log("Error: a ~= b not satisfied [int]");
 278 |     |             emit log_named_int("        Left", a);
 279 |     |             emit log_named_int("       Right", b);
 280 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta * 100, 18);
 281 |     |             emit log_named_decimal_uint("     % Delta", percentDelta * 100, 18);
 282 |     |             fail();
 283 |     |         }
 284 |     |     }
 285 |     | 
 286 |     |     function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {
 287 |     |         if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.
 288 |     | 
 289 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 290 |     | 
 291 |     |         if (percentDelta > maxPercentDelta) {
 292 |     |             emit log_named_string("Error", err);
 293 |     |             assertApproxEqRel(a, b, maxPercentDelta);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {
 298 |     |         if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.
 299 |     | 
 300 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 301 |     | 
 302 |     |         if (percentDelta > maxPercentDelta) {
 303 |     |             emit log("Error: a ~= b not satisfied [int]");
 304 |     |             emit log_named_decimal_int("        Left", a, decimals);
 305 |     |             emit log_named_decimal_int("       Right", b, decimals);
 306 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta * 100, 18);
 307 |     |             emit log_named_decimal_uint("     % Delta", percentDelta * 100, 18);
 308 |     |             fail();
 309 |     |         }
 310 |     |     }
 311 |     | 
 312 |     |     function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)
 313 |     |         internal
 314 |     |         virtual
 315 |     |     {
 316 |     |         if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.
 317 |     | 
 318 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 319 |     | 
 320 |     |         if (percentDelta > maxPercentDelta) {
 321 |     |             emit log_named_string("Error", err);
 322 |     |             assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);
 323 |     |         }
 324 |     |     }
 325 |     | 
 326 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {
 327 |     |         assertEqCall(target, callDataA, target, callDataB, true);
 328 |     |     }
 329 |     | 
 330 |     |     function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)
 331 |     |         internal
 332 |     |         virtual
 333 |     |     {
 334 |     |         assertEqCall(targetA, callDataA, targetB, callDataB, true);
 335 |     |     }
 336 |     | 
 337 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)
 338 |     |         internal
 339 |     |         virtual
 340 |     |     {
 341 |     |         assertEqCall(target, callDataA, target, callDataB, strictRevertData);
 342 |     |     }
 343 |     | 
 344 |     |     function assertEqCall(
 345 |     |         address targetA,
 346 |     |         bytes memory callDataA,
 347 |     |         address targetB,
 348 |     |         bytes memory callDataB,
 349 |     |         bool strictRevertData
 350 |     |     ) internal virtual {
 351 |     |         (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);
 352 |     |         (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);
 353 |     | 
 354 |     |         if (successA && successB) {
 355 |     |             assertEq(returnDataA, returnDataB, "Call return data does not match");
 356 |     |         }
 357 |     | 
 358 |     |         if (!successA && !successB && strictRevertData) {
 359 |     |             assertEq(returnDataA, returnDataB, "Call revert data does not match");
 360 |     |         }
 361 |     | 
 362 |     |         if (!successA && successB) {
 363 |     |             emit log("Error: Calls were not equal");
 364 |     |             emit log_named_bytes("  Left call revert data", returnDataA);
 365 |     |             emit log_named_bytes(" Right call return data", returnDataB);
 366 |     |             fail();
 367 |     |         }
 368 |     | 
 369 |     |         if (successA && !successB) {
 370 |     |             emit log("Error: Calls were not equal");
 371 |     |             emit log_named_bytes("  Left call return data", returnDataA);
 372 |     |             emit log_named_bytes(" Right call revert data", returnDataB);
 373 |     |             fail();
 374 |     |         }
 375 |     |     }
 376 |     | }
 377 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/StdChains.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * StdChains provides information about EVM compatible chains that can be used in scripts/tests.
   8 |     |  * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are
   9 |     |  * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of
  10 |     |  * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the
  11 |     |  * alias used in this contract, which can be found as the first argument to the
  12 |     |  * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.
  13 |     |  *
  14 |     |  * There are two main ways to use this contract:
  15 |     |  *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or
  16 |     |  *      `setChain(string memory chainAlias, Chain memory chain)`
  17 |     |  *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.
  18 |     |  *
  19 |     |  * The first time either of those are used, chains are initialized with the default set of RPC URLs.
  20 |     |  * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in
  21 |     |  * `defaultRpcUrls`.
  22 |     |  *
  23 |     |  * The `setChain` function is straightforward, and it simply saves off the given chain data.
  24 |     |  *
  25 |     |  * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say
  26 |     |  * we want to retrieve the RPC URL for `mainnet`:
  27 |     |  *   - If you have specified data with `setChain`, it will return that.
  28 |     |  *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it
  29 |     |  *     is valid (e.g. a URL is specified, or an environment variable is given and exists).
  30 |     |  *   - If neither of the above conditions is met, the default data is returned.
  31 |     |  *
  32 |     |  * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.
  33 |     |  */
  34 |     | abstract contract StdChains {
  35 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  36 |     | 
  37 |     |     bool private stdChainsInitialized;
  38 |     | 
  39 |     |     struct ChainData {
  40 |     |         string name;
  41 |     |         uint256 chainId;
  42 |     |         string rpcUrl;
  43 |     |     }
  44 |     | 
  45 |     |     struct Chain {
  46 |     |         // The chain name.
  47 |     |         string name;
  48 |     |         // The chain's Chain ID.
  49 |     |         uint256 chainId;
  50 |     |         // The chain's alias. (i.e. what gets specified in `foundry.toml`).
  51 |     |         string chainAlias;
  52 |     |         // A default RPC endpoint for this chain.
  53 |     |         // NOTE: This default RPC URL is included for convenience to facilitate quick tests and
  54 |     |         // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy
  55 |     |         // usage as you will be throttled and this is a disservice to others who need this endpoint.
  56 |     |         string rpcUrl;
  57 |     |     }
  58 |     | 
  59 |     |     // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.
  60 |     |     mapping(string => Chain) private chains;
  61 |     |     // Maps from the chain's alias to it's default RPC URL.
  62 |     |     mapping(string => string) private defaultRpcUrls;
  63 |     |     // Maps from a chain ID to it's alias.
  64 |     |     mapping(uint256 => string) private idToAlias;
  65 |     | 
  66 |     |     bool private fallbackToDefaultRpcUrls = true;
  67 |     | 
  68 |     |     // The RPC URL will be fetched from config or defaultRpcUrls if possible.
  69 |     |     function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {
  70 |     |         require(bytes(chainAlias).length != 0, "StdChains getChain(string): Chain alias cannot be the empty string.");
  71 |     | 
  72 |     |         initializeStdChains();
  73 |     |         chain = chains[chainAlias];
  74 |     |         require(
  75 |     |             chain.chainId != 0,
  76 |     |             string(abi.encodePacked("StdChains getChain(string): Chain with alias \"", chainAlias, "\" not found."))
  77 |     |         );
  78 |     | 
  79 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  80 |     |     }
  81 |     | 
  82 |     |     function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {
  83 |     |         require(chainId != 0, "StdChains getChain(uint256): Chain ID cannot be 0.");
  84 |     |         initializeStdChains();
  85 |     |         string memory chainAlias = idToAlias[chainId];
  86 |     | 
  87 |     |         chain = chains[chainAlias];
  88 |     | 
  89 |     |         require(
  90 |     |             chain.chainId != 0,
  91 |     |             string(abi.encodePacked("StdChains getChain(uint256): Chain with ID ", vm.toString(chainId), " not found."))
  92 |     |         );
  93 |     | 
  94 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  95 |     |     }
  96 |     | 
  97 |     |     // set chain info, with priority to argument's rpcUrl field.
  98 |     |     function setChain(string memory chainAlias, ChainData memory chain) internal virtual {
  99 |     |         require(
 100 |     |             bytes(chainAlias).length != 0,
 101 |     |             "StdChains setChain(string,ChainData): Chain alias cannot be the empty string."
 102 |     |         );
 103 |     | 
 104 |     |         require(chain.chainId != 0, "StdChains setChain(string,ChainData): Chain ID cannot be 0.");
 105 |     | 
 106 |     |         initializeStdChains();
 107 |     |         string memory foundAlias = idToAlias[chain.chainId];
 108 |     | 
 109 |     |         require(
 110 |     |             bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),
 111 |     |             string(
 112 |     |                 abi.encodePacked(
 113 |     |                     "StdChains setChain(string,ChainData): Chain ID ",
 114 |     |                     vm.toString(chain.chainId),
 115 |     |                     " already used by \"",
 116 |     |                     foundAlias,
 117 |     |                     "\"."
 118 |     |                 )
 119 |     |             )
 120 |     |         );
 121 |     | 
 122 |     |         uint256 oldChainId = chains[chainAlias].chainId;
 123 |     |         delete idToAlias[oldChainId];
 124 |     | 
 125 |     |         chains[chainAlias] =
 126 |     |             Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});
 127 |     |         idToAlias[chain.chainId] = chainAlias;
 128 |     |     }
 129 |     | 
 130 |     |     // set chain info, with priority to argument's rpcUrl field.
 131 |     |     function setChain(string memory chainAlias, Chain memory chain) internal virtual {
 132 |     |         setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));
 133 |     |     }
 134 |     | 
 135 |     |     function _toUpper(string memory str) private pure returns (string memory) {
 136 |     |         bytes memory strb = bytes(str);
 137 |     |         bytes memory copy = new bytes(strb.length);
 138 |     |         for (uint256 i = 0; i < strb.length; i++) {
 139 |     |             bytes1 b = strb[i];
 140 |     |             if (b >= 0x61 && b <= 0x7A) {
 141 |     |                 copy[i] = bytes1(uint8(b) - 32);
 142 |     |             } else {
 143 |     |                 copy[i] = b;
 144 |     |             }
 145 |     |         }
 146 |     |         return string(copy);
 147 |     |     }
 148 |     | 
 149 |     |     // lookup rpcUrl, in descending order of priority:
 150 |     |     // current -> config (foundry.toml) -> environment variable -> default
 151 |     |     function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)
 152 |     |         private
 153 |     |         view
 154 |     |         returns (Chain memory)
 155 |     |     {
 156 |     |         if (bytes(chain.rpcUrl).length == 0) {
 157 |     |             try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {
 158 |     |                 chain.rpcUrl = configRpcUrl;
 159 |     |             } catch (bytes memory err) {
 160 |     |                 string memory envName = string(abi.encodePacked(_toUpper(chainAlias), "_RPC_URL"));
 161 |     |                 if (fallbackToDefaultRpcUrls) {
 162 |     |                     chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);
 163 |     |                 } else {
 164 |     |                     chain.rpcUrl = vm.envString(envName);
 165 |     |                 }
 166 |     |                 // Distinguish 'not found' from 'cannot read'
 167 |     |                 // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions
 168 |     |                 bytes memory oldNotFoundError =
 169 |     |                     abi.encodeWithSignature("CheatCodeError", string(abi.encodePacked("invalid rpc url ", chainAlias)));
 170 |     |                 bytes memory newNotFoundError = abi.encodeWithSignature(
 171 |     |                     "CheatcodeError(string)", string(abi.encodePacked("invalid rpc url: ", chainAlias))
 172 |     |                 );
 173 |     |                 bytes32 errHash = keccak256(err);
 174 |     |                 if (
 175 |     |                     (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))
 176 |     |                         || bytes(chain.rpcUrl).length == 0
 177 |     |                 ) {
 178 |     |                     /// @solidity memory-safe-assembly
 179 |     |                     assembly {
 180 |     |                         revert(add(32, err), mload(err))
 181 |     |                     }
 182 |     |                 }
 183 |     |             }
 184 |     |         }
 185 |     |         return chain;
 186 |     |     }
 187 |     | 
 188 |     |     function setFallbackToDefaultRpcUrls(bool useDefault) internal {
 189 |     |         fallbackToDefaultRpcUrls = useDefault;
 190 |     |     }
 191 |     | 
 192 |     |     function initializeStdChains() private {
 193 |     |         if (stdChainsInitialized) return;
 194 |     | 
 195 |     |         stdChainsInitialized = true;
 196 |     | 
 197 |     |         // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`
 198 |     |         setChainWithDefaultRpcUrl("anvil", ChainData("Anvil", 31337, "http://127.0.0.1:8545"));
 199 |     |         setChainWithDefaultRpcUrl(
 200 |     |             "mainnet", ChainData("Mainnet", 1, "https://mainnet.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001")
 201 |     |         );
 202 |     |         setChainWithDefaultRpcUrl(
 203 |     |             "goerli", ChainData("Goerli", 5, "https://goerli.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001")
 204 |     |         );
 205 |     |         setChainWithDefaultRpcUrl(
 206 |     |             "sepolia", ChainData("Sepolia", 11155111, "https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001")
 207 |     |         );
 208 |     |         setChainWithDefaultRpcUrl("optimism", ChainData("Optimism", 10, "https://mainnet.optimism.io"));
 209 |     |         setChainWithDefaultRpcUrl("optimism_goerli", ChainData("Optimism Goerli", 420, "https://goerli.optimism.io"));
 210 |     |         setChainWithDefaultRpcUrl("arbitrum_one", ChainData("Arbitrum One", 42161, "https://arb1.arbitrum.io/rpc"));
 211 |     |         setChainWithDefaultRpcUrl(
 212 |     |             "arbitrum_one_goerli", ChainData("Arbitrum One Goerli", 421613, "https://goerli-rollup.arbitrum.io/rpc")
 213 |     |         );
 214 |     |         setChainWithDefaultRpcUrl("arbitrum_nova", ChainData("Arbitrum Nova", 42170, "https://nova.arbitrum.io/rpc"));
 215 |     |         setChainWithDefaultRpcUrl("polygon", ChainData("Polygon", 137, "https://polygon-rpc.com"));
 216 |     |         setChainWithDefaultRpcUrl(
 217 |     |             "polygon_mumbai", ChainData("Polygon Mumbai", 80001, "https://rpc-mumbai.maticvigil.com")
 218 |     |         );
 219 |     |         setChainWithDefaultRpcUrl("avalanche", ChainData("Avalanche", 43114, "https://api.avax.network/ext/bc/C/rpc"));
 220 |     |         setChainWithDefaultRpcUrl(
 221 |     |             "avalanche_fuji", ChainData("Avalanche Fuji", 43113, "https://api.avax-test.network/ext/bc/C/rpc")
 222 |     |         );
 223 |     |         setChainWithDefaultRpcUrl(
 224 |     |             "bnb_smart_chain", ChainData("BNB Smart Chain", 56, "https://bsc-dataseed1.binance.org")
 225 |     |         );
 226 |     |         setChainWithDefaultRpcUrl(
 227 |     |             "bnb_smart_chain_testnet",
 228 |     |             ChainData("BNB Smart Chain Testnet", 97, "https://rpc.ankr.com/bsc_testnet_chapel")
 229 |     |         );
 230 |     |         setChainWithDefaultRpcUrl("gnosis_chain", ChainData("Gnosis Chain", 100, "https://rpc.gnosischain.com"));
 231 |     |         setChainWithDefaultRpcUrl("moonbeam", ChainData("Moonbeam", 1284, "https://rpc.api.moonbeam.network"));
 232 |     |         setChainWithDefaultRpcUrl(
 233 |     |             "moonriver", ChainData("Moonriver", 1285, "https://rpc.api.moonriver.moonbeam.network")
 234 |     |         );
 235 |     |         setChainWithDefaultRpcUrl("moonbase", ChainData("Moonbase", 1287, "https://rpc.testnet.moonbeam.network"));
 236 |     |         setChainWithDefaultRpcUrl("base_goerli", ChainData("Base Goerli", 84531, "https://goerli.base.org"));
 237 |     |         setChainWithDefaultRpcUrl("base", ChainData("Base", 8453, "https://mainnet.base.org"));
 238 |     |     }
 239 |     | 
 240 |     |     // set chain info, with priority to chainAlias' rpc url in foundry.toml
 241 |     |     function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {
 242 |     |         string memory rpcUrl = chain.rpcUrl;
 243 |     |         defaultRpcUrls[chainAlias] = rpcUrl;
 244 |     |         chain.rpcUrl = "";
 245 |     |         setChain(chainAlias, chain);
 246 |     |         chain.rpcUrl = rpcUrl; // restore argument
 247 |     |     }
 248 |     | }
 249 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/StdCheats.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
   7 |     | import {console2} from "./console2.sol";
   8 |     | import {Vm} from "./Vm.sol";
   9 |     | 
  10 |     | abstract contract StdCheatsSafe {
  11 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  12 |     | 
  13 |     |     uint256 private constant UINT256_MAX =
  14 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  15 |     | 
  16 |     |     bool private gasMeteringOff;
  17 |     | 
  18 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  19 |     |     // that conform to EIP1559. The Raw structs is what is parsed from the JSON
  20 |     |     // and then converted to the one that is used by the user for better UX.
  21 |     | 
  22 |     |     struct RawTx1559 {
  23 |     |         string[] arguments;
  24 |     |         address contractAddress;
  25 |     |         string contractName;
  26 |     |         // json value name = function
  27 |     |         string functionSig;
  28 |     |         bytes32 hash;
  29 |     |         // json value name = tx
  30 |     |         RawTx1559Detail txDetail;
  31 |     |         // json value name = type
  32 |     |         string opcode;
  33 |     |     }
  34 |     | 
  35 |     |     struct RawTx1559Detail {
  36 |     |         AccessList[] accessList;
  37 |     |         bytes data;
  38 |     |         address from;
  39 |     |         bytes gas;
  40 |     |         bytes nonce;
  41 |     |         address to;
  42 |     |         bytes txType;
  43 |     |         bytes value;
  44 |     |     }
  45 |     | 
  46 |     |     struct Tx1559 {
  47 |     |         string[] arguments;
  48 |     |         address contractAddress;
  49 |     |         string contractName;
  50 |     |         string functionSig;
  51 |     |         bytes32 hash;
  52 |     |         Tx1559Detail txDetail;
  53 |     |         string opcode;
  54 |     |     }
  55 |     | 
  56 |     |     struct Tx1559Detail {
  57 |     |         AccessList[] accessList;
  58 |     |         bytes data;
  59 |     |         address from;
  60 |     |         uint256 gas;
  61 |     |         uint256 nonce;
  62 |     |         address to;
  63 |     |         uint256 txType;
  64 |     |         uint256 value;
  65 |     |     }
  66 |     | 
  67 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  68 |     |     // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON
  69 |     |     // and then converted to the one that is used by the user for better UX.
  70 |     | 
  71 |     |     struct TxLegacy {
  72 |     |         string[] arguments;
  73 |     |         address contractAddress;
  74 |     |         string contractName;
  75 |     |         string functionSig;
  76 |     |         string hash;
  77 |     |         string opcode;
  78 |     |         TxDetailLegacy transaction;
  79 |     |     }
  80 |     | 
  81 |     |     struct TxDetailLegacy {
  82 |     |         AccessList[] accessList;
  83 |     |         uint256 chainId;
  84 |     |         bytes data;
  85 |     |         address from;
  86 |     |         uint256 gas;
  87 |     |         uint256 gasPrice;
  88 |     |         bytes32 hash;
  89 |     |         uint256 nonce;
  90 |     |         bytes1 opcode;
  91 |     |         bytes32 r;
  92 |     |         bytes32 s;
  93 |     |         uint256 txType;
  94 |     |         address to;
  95 |     |         uint8 v;
  96 |     |         uint256 value;
  97 |     |     }
  98 |     | 
  99 |     |     struct AccessList {
 100 |     |         address accessAddress;
 101 |     |         bytes32[] storageKeys;
 102 |     |     }
 103 |     | 
 104 |     |     // Data structures to parse Receipt objects from the broadcast artifact.
 105 |     |     // The Raw structs is what is parsed from the JSON
 106 |     |     // and then converted to the one that is used by the user for better UX.
 107 |     | 
 108 |     |     struct RawReceipt {
 109 |     |         bytes32 blockHash;
 110 |     |         bytes blockNumber;
 111 |     |         address contractAddress;
 112 |     |         bytes cumulativeGasUsed;
 113 |     |         bytes effectiveGasPrice;
 114 |     |         address from;
 115 |     |         bytes gasUsed;
 116 |     |         RawReceiptLog[] logs;
 117 |     |         bytes logsBloom;
 118 |     |         bytes status;
 119 |     |         address to;
 120 |     |         bytes32 transactionHash;
 121 |     |         bytes transactionIndex;
 122 |     |     }
 123 |     | 
 124 |     |     struct Receipt {
 125 |     |         bytes32 blockHash;
 126 |     |         uint256 blockNumber;
 127 |     |         address contractAddress;
 128 |     |         uint256 cumulativeGasUsed;
 129 |     |         uint256 effectiveGasPrice;
 130 |     |         address from;
 131 |     |         uint256 gasUsed;
 132 |     |         ReceiptLog[] logs;
 133 |     |         bytes logsBloom;
 134 |     |         uint256 status;
 135 |     |         address to;
 136 |     |         bytes32 transactionHash;
 137 |     |         uint256 transactionIndex;
 138 |     |     }
 139 |     | 
 140 |     |     // Data structures to parse the entire broadcast artifact, assuming the
 141 |     |     // transactions conform to EIP1559.
 142 |     | 
 143 |     |     struct EIP1559ScriptArtifact {
 144 |     |         string[] libraries;
 145 |     |         string path;
 146 |     |         string[] pending;
 147 |     |         Receipt[] receipts;
 148 |     |         uint256 timestamp;
 149 |     |         Tx1559[] transactions;
 150 |     |         TxReturn[] txReturns;
 151 |     |     }
 152 |     | 
 153 |     |     struct RawEIP1559ScriptArtifact {
 154 |     |         string[] libraries;
 155 |     |         string path;
 156 |     |         string[] pending;
 157 |     |         RawReceipt[] receipts;
 158 |     |         TxReturn[] txReturns;
 159 |     |         uint256 timestamp;
 160 |     |         RawTx1559[] transactions;
 161 |     |     }
 162 |     | 
 163 |     |     struct RawReceiptLog {
 164 |     |         // json value = address
 165 |     |         address logAddress;
 166 |     |         bytes32 blockHash;
 167 |     |         bytes blockNumber;
 168 |     |         bytes data;
 169 |     |         bytes logIndex;
 170 |     |         bool removed;
 171 |     |         bytes32[] topics;
 172 |     |         bytes32 transactionHash;
 173 |     |         bytes transactionIndex;
 174 |     |         bytes transactionLogIndex;
 175 |     |     }
 176 |     | 
 177 |     |     struct ReceiptLog {
 178 |     |         // json value = address
 179 |     |         address logAddress;
 180 |     |         bytes32 blockHash;
 181 |     |         uint256 blockNumber;
 182 |     |         bytes data;
 183 |     |         uint256 logIndex;
 184 |     |         bytes32[] topics;
 185 |     |         uint256 transactionIndex;
 186 |     |         uint256 transactionLogIndex;
 187 |     |         bool removed;
 188 |     |     }
 189 |     | 
 190 |     |     struct TxReturn {
 191 |     |         string internalType;
 192 |     |         string value;
 193 |     |     }
 194 |     | 
 195 |     |     struct Account {
 196 |     |         address addr;
 197 |     |         uint256 key;
 198 |     |     }
 199 |     | 
 200 |     |     enum AddressType {
 201 |     |         Payable,
 202 |     |         NonPayable,
 203 |     |         ZeroAddress,
 204 |     |         Precompile,
 205 |     |         ForgeAddress
 206 |     |     }
 207 |     | 
 208 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 209 |     |     function assumeNotBlacklisted(address token, address addr) internal view virtual {
 210 |     |         // Nothing to check if `token` is not a contract.
 211 |     |         uint256 tokenCodeSize;
 212 |     |         assembly {
 213 |     |             tokenCodeSize := extcodesize(token)
 214 |     |         }
 215 |     |         require(tokenCodeSize > 0, "StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.");
 216 |     | 
 217 |     |         bool success;
 218 |     |         bytes memory returnData;
 219 |     | 
 220 |     |         // 4-byte selector for `isBlacklisted(address)`, used by USDC.
 221 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));
 222 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 223 |     | 
 224 |     |         // 4-byte selector for `isBlackListed(address)`, used by USDT.
 225 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));
 226 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 227 |     |     }
 228 |     | 
 229 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 230 |     |     // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for
 231 |     |     // backwards compatibility, since this name was used in the original PR which has already has
 232 |     |     // a release. This function can be removed in a future release once we want a breaking change.
 233 |     |     function assumeNoBlacklisted(address token, address addr) internal view virtual {
 234 |     |         assumeNotBlacklisted(token, addr);
 235 |     |     }
 236 |     | 
 237 |     |     function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {
 238 |     |         if (addressType == AddressType.Payable) {
 239 |     |             assumeNotPayable(addr);
 240 |     |         } else if (addressType == AddressType.NonPayable) {
 241 |     |             assumePayable(addr);
 242 |     |         } else if (addressType == AddressType.ZeroAddress) {
 243 |     |             assumeNotZeroAddress(addr);
 244 |     |         } else if (addressType == AddressType.Precompile) {
 245 |     |             assumeNotPrecompile(addr);
 246 |     |         } else if (addressType == AddressType.ForgeAddress) {
 247 |     |             assumeNotForgeAddress(addr);
 248 |     |         }
 249 |     |     }
 250 |     | 
 251 |     |     function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {
 252 |     |         assumeAddressIsNot(addr, addressType1);
 253 |     |         assumeAddressIsNot(addr, addressType2);
 254 |     |     }
 255 |     | 
 256 |     |     function assumeAddressIsNot(
 257 |     |         address addr,
 258 |     |         AddressType addressType1,
 259 |     |         AddressType addressType2,
 260 |     |         AddressType addressType3
 261 |     |     ) internal virtual {
 262 |     |         assumeAddressIsNot(addr, addressType1);
 263 |     |         assumeAddressIsNot(addr, addressType2);
 264 |     |         assumeAddressIsNot(addr, addressType3);
 265 |     |     }
 266 |     | 
 267 |     |     function assumeAddressIsNot(
 268 |     |         address addr,
 269 |     |         AddressType addressType1,
 270 |     |         AddressType addressType2,
 271 |     |         AddressType addressType3,
 272 |     |         AddressType addressType4
 273 |     |     ) internal virtual {
 274 |     |         assumeAddressIsNot(addr, addressType1);
 275 |     |         assumeAddressIsNot(addr, addressType2);
 276 |     |         assumeAddressIsNot(addr, addressType3);
 277 |     |         assumeAddressIsNot(addr, addressType4);
 278 |     |     }
 279 |     | 
 280 |     |     // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to
 281 |     |     // `addr` and checking the `success` return value.
 282 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 283 |     |     // implemented by `addr`, which should be taken into account when this function is used.
 284 |     |     function _isPayable(address addr) private returns (bool) {
 285 |     |         require(
 286 |     |             addr.balance < UINT256_MAX,
 287 |     |             "StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds"
 288 |     |         );
 289 |     |         uint256 origBalanceTest = address(this).balance;
 290 |     |         uint256 origBalanceAddr = address(addr).balance;
 291 |     | 
 292 |     |         vm.deal(address(this), 1);
 293 |     |         (bool success,) = payable(addr).call{value: 1}("");
 294 |     | 
 295 |     |         // reset balances
 296 |     |         vm.deal(address(this), origBalanceTest);
 297 |     |         vm.deal(addr, origBalanceAddr);
 298 |     | 
 299 |     |         return success;
 300 |     |     }
 301 |     | 
 302 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 303 |     |     // implemented by `addr`, which should be taken into account when this function is used. See the
 304 |     |     // `_isPayable` method for more information.
 305 |     |     function assumePayable(address addr) internal virtual {
 306 |     |         vm.assume(_isPayable(addr));
 307 |     |     }
 308 |     | 
 309 |     |     function assumeNotPayable(address addr) internal virtual {
 310 |     |         vm.assume(!_isPayable(addr));
 311 |     |     }
 312 |     | 
 313 |     |     function assumeNotZeroAddress(address addr) internal pure virtual {
 314 |     |         vm.assume(addr != address(0));
 315 |     |     }
 316 |     | 
 317 |     |     function assumeNotPrecompile(address addr) internal pure virtual {
 318 |     |         assumeNotPrecompile(addr, _pureChainId());
 319 |     |     }
 320 |     | 
 321 |     |     function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {
 322 |     |         // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific
 323 |     |         // address), but the same rationale for excluding them applies so we include those too.
 324 |     | 
 325 |     |         // These should be present on all EVM-compatible chains.
 326 |     |         vm.assume(addr < address(0x1) || addr > address(0x9));
 327 |     | 
 328 |     |         // forgefmt: disable-start
 329 |     |         if (chainId == 10 || chainId == 420) {
 330 |     |             // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21
 331 |     |             vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));
 332 |     |         } else if (chainId == 42161 || chainId == 421613) {
 333 |     |             // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains
 334 |     |             vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));
 335 |     |         } else if (chainId == 43114 || chainId == 43113) {
 336 |     |             // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59
 337 |     |             vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));
 338 |     |             vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));
 339 |     |             vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));
 340 |     |         }
 341 |     |         // forgefmt: disable-end
 342 |     |     }
 343 |     | 
 344 |     |     function assumeNotForgeAddress(address addr) internal pure virtual {
 345 |     |         // vm, console, and Create2Deployer addresses
 346 |     |         vm.assume(
 347 |     |             addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67
 348 |     |                 && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C
 349 |     |         );
 350 |     |     }
 351 |     | 
 352 |     |     function readEIP1559ScriptArtifact(string memory path)
 353 |     |         internal
 354 |     |         view
 355 |     |         virtual
 356 |     |         returns (EIP1559ScriptArtifact memory)
 357 |     |     {
 358 |     |         string memory data = vm.readFile(path);
 359 |     |         bytes memory parsedData = vm.parseJson(data);
 360 |     |         RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));
 361 |     |         EIP1559ScriptArtifact memory artifact;
 362 |     |         artifact.libraries = rawArtifact.libraries;
 363 |     |         artifact.path = rawArtifact.path;
 364 |     |         artifact.timestamp = rawArtifact.timestamp;
 365 |     |         artifact.pending = rawArtifact.pending;
 366 |     |         artifact.txReturns = rawArtifact.txReturns;
 367 |     |         artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);
 368 |     |         artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);
 369 |     |         return artifact;
 370 |     |     }
 371 |     | 
 372 |     |     function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {
 373 |     |         Tx1559[] memory txs = new Tx1559[](rawTxs.length);
 374 |     |         for (uint256 i; i < rawTxs.length; i++) {
 375 |     |             txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);
 376 |     |         }
 377 |     |         return txs;
 378 |     |     }
 379 |     | 
 380 |     |     function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {
 381 |     |         Tx1559 memory transaction;
 382 |     |         transaction.arguments = rawTx.arguments;
 383 |     |         transaction.contractName = rawTx.contractName;
 384 |     |         transaction.functionSig = rawTx.functionSig;
 385 |     |         transaction.hash = rawTx.hash;
 386 |     |         transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);
 387 |     |         transaction.opcode = rawTx.opcode;
 388 |     |         return transaction;
 389 |     |     }
 390 |     | 
 391 |     |     function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)
 392 |     |         internal
 393 |     |         pure
 394 |     |         virtual
 395 |     |         returns (Tx1559Detail memory)
 396 |     |     {
 397 |     |         Tx1559Detail memory txDetail;
 398 |     |         txDetail.data = rawDetail.data;
 399 |     |         txDetail.from = rawDetail.from;
 400 |     |         txDetail.to = rawDetail.to;
 401 |     |         txDetail.nonce = _bytesToUint(rawDetail.nonce);
 402 |     |         txDetail.txType = _bytesToUint(rawDetail.txType);
 403 |     |         txDetail.value = _bytesToUint(rawDetail.value);
 404 |     |         txDetail.gas = _bytesToUint(rawDetail.gas);
 405 |     |         txDetail.accessList = rawDetail.accessList;
 406 |     |         return txDetail;
 407 |     |     }
 408 |     | 
 409 |     |     function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {
 410 |     |         string memory deployData = vm.readFile(path);
 411 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".transactions");
 412 |     |         RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));
 413 |     |         return rawToConvertedEIPTx1559s(rawTxs);
 414 |     |     }
 415 |     | 
 416 |     |     function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {
 417 |     |         string memory deployData = vm.readFile(path);
 418 |     |         string memory key = string(abi.encodePacked(".transactions[", vm.toString(index), "]"));
 419 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 420 |     |         RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));
 421 |     |         return rawToConvertedEIPTx1559(rawTx);
 422 |     |     }
 423 |     | 
 424 |     |     // Analogous to readTransactions, but for receipts.
 425 |     |     function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {
 426 |     |         string memory deployData = vm.readFile(path);
 427 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".receipts");
 428 |     |         RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));
 429 |     |         return rawToConvertedReceipts(rawReceipts);
 430 |     |     }
 431 |     | 
 432 |     |     function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {
 433 |     |         string memory deployData = vm.readFile(path);
 434 |     |         string memory key = string(abi.encodePacked(".receipts[", vm.toString(index), "]"));
 435 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 436 |     |         RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));
 437 |     |         return rawToConvertedReceipt(rawReceipt);
 438 |     |     }
 439 |     | 
 440 |     |     function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {
 441 |     |         Receipt[] memory receipts = new Receipt[](rawReceipts.length);
 442 |     |         for (uint256 i; i < rawReceipts.length; i++) {
 443 |     |             receipts[i] = rawToConvertedReceipt(rawReceipts[i]);
 444 |     |         }
 445 |     |         return receipts;
 446 |     |     }
 447 |     | 
 448 |     |     function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {
 449 |     |         Receipt memory receipt;
 450 |     |         receipt.blockHash = rawReceipt.blockHash;
 451 |     |         receipt.to = rawReceipt.to;
 452 |     |         receipt.from = rawReceipt.from;
 453 |     |         receipt.contractAddress = rawReceipt.contractAddress;
 454 |     |         receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);
 455 |     |         receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);
 456 |     |         receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);
 457 |     |         receipt.status = _bytesToUint(rawReceipt.status);
 458 |     |         receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);
 459 |     |         receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);
 460 |     |         receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);
 461 |     |         receipt.logsBloom = rawReceipt.logsBloom;
 462 |     |         receipt.transactionHash = rawReceipt.transactionHash;
 463 |     |         return receipt;
 464 |     |     }
 465 |     | 
 466 |     |     function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)
 467 |     |         internal
 468 |     |         pure
 469 |     |         virtual
 470 |     |         returns (ReceiptLog[] memory)
 471 |     |     {
 472 |     |         ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);
 473 |     |         for (uint256 i; i < rawLogs.length; i++) {
 474 |     |             logs[i].logAddress = rawLogs[i].logAddress;
 475 |     |             logs[i].blockHash = rawLogs[i].blockHash;
 476 |     |             logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);
 477 |     |             logs[i].data = rawLogs[i].data;
 478 |     |             logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);
 479 |     |             logs[i].topics = rawLogs[i].topics;
 480 |     |             logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);
 481 |     |             logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);
 482 |     |             logs[i].removed = rawLogs[i].removed;
 483 |     |         }
 484 |     |         return logs;
 485 |     |     }
 486 |     | 
 487 |     |     // Deploy a contract by fetching the contract bytecode from
 488 |     |     // the artifacts directory
 489 |     |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
 490 |     |     function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {
 491 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 492 |     |         /// @solidity memory-safe-assembly
 493 |     |         assembly {
 494 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 495 |     |         }
 496 |     | 
 497 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes): Deployment failed.");
 498 |     |     }
 499 |     | 
 500 |     |     function deployCode(string memory what) internal virtual returns (address addr) {
 501 |     |         bytes memory bytecode = vm.getCode(what);
 502 |     |         /// @solidity memory-safe-assembly
 503 |     |         assembly {
 504 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 505 |     |         }
 506 |     | 
 507 |     |         require(addr != address(0), "StdCheats deployCode(string): Deployment failed.");
 508 |     |     }
 509 |     | 
 510 |     |     /// @dev deploy contract with value on construction
 511 |     |     function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {
 512 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 513 |     |         /// @solidity memory-safe-assembly
 514 |     |         assembly {
 515 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 516 |     |         }
 517 |     | 
 518 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes,uint256): Deployment failed.");
 519 |     |     }
 520 |     | 
 521 |     |     function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {
 522 |     |         bytes memory bytecode = vm.getCode(what);
 523 |     |         /// @solidity memory-safe-assembly
 524 |     |         assembly {
 525 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 526 |     |         }
 527 |     | 
 528 |     |         require(addr != address(0), "StdCheats deployCode(string,uint256): Deployment failed.");
 529 |     |     }
 530 |     | 
 531 |     |     // creates a labeled address and the corresponding private key
 532 |     |     function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {
 533 |     |         privateKey = uint256(keccak256(abi.encodePacked(name)));
 534 |     |         addr = vm.addr(privateKey);
 535 |     |         vm.label(addr, name);
 536 |     |     }
 537 |     | 
 538 |     |     // creates a labeled address
 539 |     |     function makeAddr(string memory name) internal virtual returns (address addr) {
 540 |     |         (addr,) = makeAddrAndKey(name);
 541 |     |     }
 542 |     | 
 543 |     |     // Destroys an account immediately, sending the balance to beneficiary.
 544 |     |     // Destroying means: balance will be zero, code will be empty, and nonce will be 0
 545 |     |     // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce
 546 |     |     // only after tx ends, this will run immediately.
 547 |     |     function destroyAccount(address who, address beneficiary) internal virtual {
 548 |     |         uint256 currBalance = who.balance;
 549 |     |         vm.etch(who, abi.encode());
 550 |     |         vm.deal(who, 0);
 551 |     |         vm.resetNonce(who);
 552 |     | 
 553 |     |         uint256 beneficiaryBalance = beneficiary.balance;
 554 |     |         vm.deal(beneficiary, currBalance + beneficiaryBalance);
 555 |     |     }
 556 |     | 
 557 |     |     // creates a struct containing both a labeled address and the corresponding private key
 558 |     |     function makeAccount(string memory name) internal virtual returns (Account memory account) {
 559 |     |         (account.addr, account.key) = makeAddrAndKey(name);
 560 |     |     }
 561 |     | 
 562 |     |     function deriveRememberKey(string memory mnemonic, uint32 index)
 563 |     |         internal
 564 |     |         virtual
 565 |     |         returns (address who, uint256 privateKey)
 566 |     |     {
 567 |     |         privateKey = vm.deriveKey(mnemonic, index);
 568 |     |         who = vm.rememberKey(privateKey);
 569 |     |     }
 570 |     | 
 571 |     |     function _bytesToUint(bytes memory b) private pure returns (uint256) {
 572 |     |         require(b.length <= 32, "StdCheats _bytesToUint(bytes): Bytes length exceeds 32.");
 573 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 574 |     |     }
 575 |     | 
 576 |     |     function isFork() internal view virtual returns (bool status) {
 577 |     |         try vm.activeFork() {
 578 |     |             status = true;
 579 |     |         } catch (bytes memory) {}
 580 |     |     }
 581 |     | 
 582 |     |     modifier skipWhenForking() {
 583 |     |         if (!isFork()) {
 584 |     |             _;
 585 |     |         }
 586 |     |     }
 587 |     | 
 588 |     |     modifier skipWhenNotForking() {
 589 |     |         if (isFork()) {
 590 |     |             _;
 591 |     |         }
 592 |     |     }
 593 |     | 
 594 |     |     modifier noGasMetering() {
 595 |     |         vm.pauseGasMetering();
 596 |     |         // To prevent turning gas monitoring back on with nested functions that use this modifier,
 597 |     |         // we check if gasMetering started in the off position. If it did, we don't want to turn
 598 |     |         // it back on until we exit the top level function that used the modifier
 599 |     |         //
 600 |     |         // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.
 601 |     |         // funcA will have `gasStartedOff` as false, funcB will have it as true,
 602 |     |         // so we only turn metering back on at the end of the funcA
 603 |     |         bool gasStartedOff = gasMeteringOff;
 604 |     |         gasMeteringOff = true;
 605 |     | 
 606 |     |         _;
 607 |     | 
 608 |     |         // if gas metering was on when this modifier was called, turn it back on at the end
 609 |     |         if (!gasStartedOff) {
 610 |     |             gasMeteringOff = false;
 611 |     |             vm.resumeGasMetering();
 612 |     |         }
 613 |     |     }
 614 |     | 
 615 |     |     // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no
 616 |     |     // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We
 617 |     |     // can't simply access the chain ID in a normal view or pure function because the solc View Pure
 618 |     |     // Checker changed `chainid` from pure to view in 0.8.0.
 619 |     |     function _viewChainId() private view returns (uint256 chainId) {
 620 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 621 |     |         assembly {
 622 |     |             chainId := chainid()
 623 |     |         }
 624 |     | 
 625 |     |         address(this); // Silence warnings in older Solc versions.
 626 |     |     }
 627 |     | 
 628 |     |     function _pureChainId() private pure returns (uint256 chainId) {
 629 |     |         function() internal view returns (uint256) fnIn = _viewChainId;
 630 |     |         function() internal pure returns (uint256) pureChainId;
 631 |     |         assembly {
 632 |     |             pureChainId := fnIn
 633 |     |         }
 634 |     |         chainId = pureChainId();
 635 |     |     }
 636 |     | }
 637 |     | 
 638 |     | // Wrappers around cheatcodes to avoid footguns
 639 |     | abstract contract StdCheats is StdCheatsSafe {
 640 |     |     using stdStorage for StdStorage;
 641 |     | 
 642 |     |     StdStorage private stdstore;
 643 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 644 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
 645 |     | 
 646 |     |     // Skip forward or rewind time by the specified number of seconds
 647 |     |     function skip(uint256 time) internal virtual {
 648 |     |         vm.warp(block.timestamp + time);
 649 |     |     }
 650 |     | 
 651 |     |     function rewind(uint256 time) internal virtual {
 652 |     |         vm.warp(block.timestamp - time);
 653 |     |     }
 654 |     | 
 655 |     |     // Setup a prank from an address that has some ether
 656 |     |     function hoax(address msgSender) internal virtual {
 657 |     |         vm.deal(msgSender, 1 << 128);
 658 |     |         vm.prank(msgSender);
 659 |     |     }
 660 |     | 
 661 |     |     function hoax(address msgSender, uint256 give) internal virtual {
 662 |     |         vm.deal(msgSender, give);
 663 |     |         vm.prank(msgSender);
 664 |     |     }
 665 |     | 
 666 |     |     function hoax(address msgSender, address origin) internal virtual {
 667 |     |         vm.deal(msgSender, 1 << 128);
 668 |     |         vm.prank(msgSender, origin);
 669 |     |     }
 670 |     | 
 671 |     |     function hoax(address msgSender, address origin, uint256 give) internal virtual {
 672 |     |         vm.deal(msgSender, give);
 673 |     |         vm.prank(msgSender, origin);
 674 |     |     }
 675 |     | 
 676 |     |     // Start perpetual prank from an address that has some ether
 677 |     |     function startHoax(address msgSender) internal virtual {
 678 |     |         vm.deal(msgSender, 1 << 128);
 679 |     |         vm.startPrank(msgSender);
 680 |     |     }
 681 |     | 
 682 |     |     function startHoax(address msgSender, uint256 give) internal virtual {
 683 |     |         vm.deal(msgSender, give);
 684 |     |         vm.startPrank(msgSender);
 685 |     |     }
 686 |     | 
 687 |     |     // Start perpetual prank from an address that has some ether
 688 |     |     // tx.origin is set to the origin parameter
 689 |     |     function startHoax(address msgSender, address origin) internal virtual {
 690 |     |         vm.deal(msgSender, 1 << 128);
 691 |     |         vm.startPrank(msgSender, origin);
 692 |     |     }
 693 |     | 
 694 |     |     function startHoax(address msgSender, address origin, uint256 give) internal virtual {
 695 |     |         vm.deal(msgSender, give);
 696 |     |         vm.startPrank(msgSender, origin);
 697 |     |     }
 698 |     | 
 699 |     |     function changePrank(address msgSender) internal virtual {
 700 |     |         console2_log_StdCheats("changePrank is deprecated. Please use vm.startPrank instead.");
 701 |     |         vm.stopPrank();
 702 |     |         vm.startPrank(msgSender);
 703 |     |     }
 704 |     | 
 705 |     |     function changePrank(address msgSender, address txOrigin) internal virtual {
 706 |     |         vm.stopPrank();
 707 |     |         vm.startPrank(msgSender, txOrigin);
 708 |     |     }
 709 |     | 
 710 |     |     // The same as Vm's `deal`
 711 |     |     // Use the alternative signature for ERC20 tokens
 712 |     |     function deal(address to, uint256 give) internal virtual {
 713 |     |         vm.deal(to, give);
 714 |     |     }
 715 |     | 
 716 |     |     // Set the balance of an account for any ERC20 token
 717 |     |     // Use the alternative signature to update `totalSupply`
 718 |     |     function deal(address token, address to, uint256 give) internal virtual {
 719 |     |         deal(token, to, give, false);
 720 |     |     }
 721 |     | 
 722 |     |     // Set the balance of an account for any ERC1155 token
 723 |     |     // Use the alternative signature to update `totalSupply`
 724 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {
 725 |     |         dealERC1155(token, to, id, give, false);
 726 |     |     }
 727 |     | 
 728 |     |     function deal(address token, address to, uint256 give, bool adjust) internal virtual {
 729 |     |         // get current balance
 730 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 731 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 732 |     | 
 733 |     |         // update balance
 734 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);
 735 |     | 
 736 |     |         // update total supply
 737 |     |         if (adjust) {
 738 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));
 739 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 740 |     |             if (give < prevBal) {
 741 |     |                 totSup -= (prevBal - give);
 742 |     |             } else {
 743 |     |                 totSup += (give - prevBal);
 744 |     |             }
 745 |     |             stdstore.target(token).sig(0x18160ddd).checked_write(totSup);
 746 |     |         }
 747 |     |     }
 748 |     | 
 749 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {
 750 |     |         // get current balance
 751 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));
 752 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 753 |     | 
 754 |     |         // update balance
 755 |     |         stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);
 756 |     | 
 757 |     |         // update total supply
 758 |     |         if (adjust) {
 759 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));
 760 |     |             require(
 761 |     |                 totSupData.length != 0,
 762 |     |                 "StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply."
 763 |     |             );
 764 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 765 |     |             if (give < prevBal) {
 766 |     |                 totSup -= (prevBal - give);
 767 |     |             } else {
 768 |     |                 totSup += (give - prevBal);
 769 |     |             }
 770 |     |             stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);
 771 |     |         }
 772 |     |     }
 773 |     | 
 774 |     |     function dealERC721(address token, address to, uint256 id) internal virtual {
 775 |     |         // check if token id is already minted and the actual owner.
 776 |     |         (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));
 777 |     |         require(successMinted, "StdCheats deal(address,address,uint,bool): id not minted.");
 778 |     | 
 779 |     |         // get owner current balance
 780 |     |         (, bytes memory fromBalData) =
 781 |     |             token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));
 782 |     |         uint256 fromPrevBal = abi.decode(fromBalData, (uint256));
 783 |     | 
 784 |     |         // get new user current balance
 785 |     |         (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 786 |     |         uint256 toPrevBal = abi.decode(toBalData, (uint256));
 787 |     | 
 788 |     |         // update balances
 789 |     |         stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);
 790 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);
 791 |     | 
 792 |     |         // update owner
 793 |     |         stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);
 794 |     |     }
 795 |     | 
 796 |     |     function deployCodeTo(string memory what, address where) internal virtual {
 797 |     |         deployCodeTo(what, "", 0, where);
 798 |     |     }
 799 |     | 
 800 |     |     function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {
 801 |     |         deployCodeTo(what, args, 0, where);
 802 |     |     }
 803 |     | 
 804 |     |     function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {
 805 |     |         bytes memory creationCode = vm.getCode(what);
 806 |     |         vm.etch(where, abi.encodePacked(creationCode, args));
 807 |     |         (bool success, bytes memory runtimeBytecode) = where.call{value: value}("");
 808 |     |         require(success, "StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.");
 809 |     |         vm.etch(where, runtimeBytecode);
 810 |     |     }
 811 |     | 
 812 |     |     // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.
 813 |     |     function console2_log_StdCheats(string memory p0) private view {
 814 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string)", p0));
 815 |     |         status;
 816 |     |     }
 817 |     | }
 818 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/StdError.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test
  3 |     | pragma solidity >=0.6.2 <0.9.0;
  4 |     | 
  5 |     | library stdError {
  6 |     |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
  7 |     |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
  8 |     |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
  9 |     |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
 10 |     |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
 11 |     |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
 12 |     |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
 13 |     |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
 14 |     |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
 15 |     | }
 16 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/StdInvariant.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | abstract contract StdInvariant {
   7 |     |     struct FuzzSelector {
   8 |     |         address addr;
   9 |     |         bytes4[] selectors;
  10 |     |     }
  11 |     | 
  12 |     |     struct FuzzInterface {
  13 |     |         address addr;
  14 |     |         string[] artifacts;
  15 |     |     }
  16 |     | 
  17 |     |     address[] private _excludedContracts;
  18 |     |     address[] private _excludedSenders;
  19 |     |     address[] private _targetedContracts;
  20 |     |     address[] private _targetedSenders;
  21 |     | 
  22 |     |     string[] private _excludedArtifacts;
  23 |     |     string[] private _targetedArtifacts;
  24 |     | 
  25 |     |     FuzzSelector[] private _targetedArtifactSelectors;
  26 |     |     FuzzSelector[] private _targetedSelectors;
  27 |     | 
  28 |     |     FuzzInterface[] private _targetedInterfaces;
  29 |     | 
  30 |     |     // Functions for users:
  31 |     |     // These are intended to be called in tests.
  32 |     | 
  33 |     |     function excludeContract(address newExcludedContract_) internal {
  34 |     |         _excludedContracts.push(newExcludedContract_);
  35 |     |     }
  36 |     | 
  37 |     |     function excludeSender(address newExcludedSender_) internal {
  38 |     |         _excludedSenders.push(newExcludedSender_);
  39 |     |     }
  40 |     | 
  41 |     |     function excludeArtifact(string memory newExcludedArtifact_) internal {
  42 |     |         _excludedArtifacts.push(newExcludedArtifact_);
  43 |     |     }
  44 |     | 
  45 |     |     function targetArtifact(string memory newTargetedArtifact_) internal {
  46 |     |         _targetedArtifacts.push(newTargetedArtifact_);
  47 |     |     }
  48 |     | 
  49 |     |     function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {
  50 |     |         _targetedArtifactSelectors.push(newTargetedArtifactSelector_);
  51 |     |     }
  52 |     | 
  53 |     |     function targetContract(address newTargetedContract_) internal {
  54 |     |         _targetedContracts.push(newTargetedContract_);
  55 |     |     }
  56 |     | 
  57 |     |     function targetSelector(FuzzSelector memory newTargetedSelector_) internal {
  58 |     |         _targetedSelectors.push(newTargetedSelector_);
  59 |     |     }
  60 |     | 
  61 |     |     function targetSender(address newTargetedSender_) internal {
  62 |     |         _targetedSenders.push(newTargetedSender_);
  63 |     |     }
  64 |     | 
  65 |     |     function targetInterface(FuzzInterface memory newTargetedInterface_) internal {
  66 |     |         _targetedInterfaces.push(newTargetedInterface_);
  67 |     |     }
  68 |     | 
  69 |     |     // Functions for forge:
  70 |     |     // These are called by forge to run invariant tests and don't need to be called in tests.
  71 |     | 
  72 |     |     function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {
  73 |     |         excludedArtifacts_ = _excludedArtifacts;
  74 |     |     }
  75 |     | 
  76 |     |     function excludeContracts() public view returns (address[] memory excludedContracts_) {
  77 |     |         excludedContracts_ = _excludedContracts;
  78 |     |     }
  79 |     | 
  80 |     |     function excludeSenders() public view returns (address[] memory excludedSenders_) {
  81 |     |         excludedSenders_ = _excludedSenders;
  82 |     |     }
  83 |     | 
  84 |     |     function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {
  85 |     |         targetedArtifacts_ = _targetedArtifacts;
  86 |     |     }
  87 |     | 
  88 |     |     function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {
  89 |     |         targetedArtifactSelectors_ = _targetedArtifactSelectors;
  90 |     |     }
  91 |     | 
  92 |     |     function targetContracts() public view returns (address[] memory targetedContracts_) {
  93 |     |         targetedContracts_ = _targetedContracts;
  94 |     |     }
  95 |     | 
  96 |     |     function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {
  97 |     |         targetedSelectors_ = _targetedSelectors;
  98 |     |     }
  99 |     | 
 100 |     |     function targetSenders() public view returns (address[] memory targetedSenders_) {
 101 |     |         targetedSenders_ = _targetedSenders;
 102 |     |     }
 103 |     | 
 104 |     |     function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {
 105 |     |         targetedInterfaces_ = _targetedInterfaces;
 106 |     |     }
 107 |     | }
 108 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/StdJson.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing JSON files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdJson for string;
  12 |     | // string memory json = vm.readFile("some_path");
  13 |     | // json.parseUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdJson for string;
  18 |     | // string memory json = "deploymentArtifact";
  19 |     | // Contract contract = new Contract();
  20 |     | // json.serialize("contractAddress", address(contract));
  21 |     | // json = json.serialize("deploymentTimes", uint(1));
  22 |     | // // store the stringified JSON to the 'json' variable we have been using as a key
  23 |     | // // as we won't need it any longer
  24 |     | // string memory json2 = "finalArtifact";
  25 |     | // string memory final = json2.serialize("depArtifact", json);
  26 |     | // final.write("<some_path>");
  27 |     | // ```
  28 |     | 
  29 |     | library stdJson {
  30 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  31 |     | 
  32 |     |     function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {
  33 |     |         return vm.parseJson(json, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUint(string memory json, string memory key) internal pure returns (uint256) {
  37 |     |         return vm.parseJsonUint(json, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {
  41 |     |         return vm.parseJsonUintArray(json, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readInt(string memory json, string memory key) internal pure returns (int256) {
  45 |     |         return vm.parseJsonInt(json, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {
  49 |     |         return vm.parseJsonIntArray(json, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {
  53 |     |         return vm.parseJsonBytes32(json, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {
  57 |     |         return vm.parseJsonBytes32Array(json, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readString(string memory json, string memory key) internal pure returns (string memory) {
  61 |     |         return vm.parseJsonString(json, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {
  65 |     |         return vm.parseJsonStringArray(json, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddress(string memory json, string memory key) internal pure returns (address) {
  69 |     |         return vm.parseJsonAddress(json, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {
  73 |     |         return vm.parseJsonAddressArray(json, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBool(string memory json, string memory key) internal pure returns (bool) {
  77 |     |         return vm.parseJsonBool(json, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {
  81 |     |         return vm.parseJsonBoolArray(json, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {
  85 |     |         return vm.parseJsonBytes(json, key);
  86 |     |     }
  87 |     | 
  88 |     |     function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {
  89 |     |         return vm.parseJsonBytesArray(json, key);
  90 |     |     }
  91 |     | 
  92 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
  93 |     |         return vm.serializeJson(jsonKey, rootObject);
  94 |     |     }
  95 |     | 
  96 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
  97 |     |         return vm.serializeBool(jsonKey, key, value);
  98 |     |     }
  99 |     | 
 100 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
 101 |     |         internal
 102 |     |         returns (string memory)
 103 |     |     {
 104 |     |         return vm.serializeBool(jsonKey, key, value);
 105 |     |     }
 106 |     | 
 107 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 108 |     |         return vm.serializeUint(jsonKey, key, value);
 109 |     |     }
 110 |     | 
 111 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 112 |     |         internal
 113 |     |         returns (string memory)
 114 |     |     {
 115 |     |         return vm.serializeUint(jsonKey, key, value);
 116 |     |     }
 117 |     | 
 118 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 119 |     |         return vm.serializeInt(jsonKey, key, value);
 120 |     |     }
 121 |     | 
 122 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 123 |     |         internal
 124 |     |         returns (string memory)
 125 |     |     {
 126 |     |         return vm.serializeInt(jsonKey, key, value);
 127 |     |     }
 128 |     | 
 129 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 130 |     |         return vm.serializeAddress(jsonKey, key, value);
 131 |     |     }
 132 |     | 
 133 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 134 |     |         internal
 135 |     |         returns (string memory)
 136 |     |     {
 137 |     |         return vm.serializeAddress(jsonKey, key, value);
 138 |     |     }
 139 |     | 
 140 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 141 |     |         return vm.serializeBytes32(jsonKey, key, value);
 142 |     |     }
 143 |     | 
 144 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 145 |     |         internal
 146 |     |         returns (string memory)
 147 |     |     {
 148 |     |         return vm.serializeBytes32(jsonKey, key, value);
 149 |     |     }
 150 |     | 
 151 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 152 |     |         return vm.serializeBytes(jsonKey, key, value);
 153 |     |     }
 154 |     | 
 155 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 156 |     |         internal
 157 |     |         returns (string memory)
 158 |     |     {
 159 |     |         return vm.serializeBytes(jsonKey, key, value);
 160 |     |     }
 161 |     | 
 162 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 163 |     |         internal
 164 |     |         returns (string memory)
 165 |     |     {
 166 |     |         return vm.serializeString(jsonKey, key, value);
 167 |     |     }
 168 |     | 
 169 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 170 |     |         internal
 171 |     |         returns (string memory)
 172 |     |     {
 173 |     |         return vm.serializeString(jsonKey, key, value);
 174 |     |     }
 175 |     | 
 176 |     |     function write(string memory jsonKey, string memory path) internal {
 177 |     |         vm.writeJson(jsonKey, path);
 178 |     |     }
 179 |     | 
 180 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 181 |     |         vm.writeJson(jsonKey, path, valueKey);
 182 |     |     }
 183 |     | }
 184 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/StdMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | library stdMath {
  5 |     |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
  6 |     | 
  7 |     |     function abs(int256 a) internal pure returns (uint256) {
  8 |     |         // Required or it will fail when `a = type(int256).min`
  9 |     |         if (a == INT256_MIN) {
 10 |     |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
 11 |     |         }
 12 |     | 
 13 |     |         return uint256(a > 0 ? a : -a);
 14 |     |     }
 15 |     | 
 16 |     |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
 17 |     |         return a > b ? a - b : b - a;
 18 |     |     }
 19 |     | 
 20 |     |     function delta(int256 a, int256 b) internal pure returns (uint256) {
 21 |     |         // a and b are of the same sign
 22 |     |         // this works thanks to two's complement, the left-most bit is the sign bit
 23 |     |         if ((a ^ b) > -1) {
 24 |     |             return delta(abs(a), abs(b));
 25 |     |         }
 26 |     | 
 27 |     |         // a and b are of opposite signs
 28 |     |         return abs(a) + abs(b);
 29 |     |     }
 30 |     | 
 31 |     |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
 32 |     |         uint256 absDelta = delta(a, b);
 33 |     | 
 34 |     |         return absDelta * 1e18 / b;
 35 |     |     }
 36 |     | 
 37 |     |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
 38 |     |         uint256 absDelta = delta(a, b);
 39 |     |         uint256 absB = abs(b);
 40 |     | 
 41 |     |         return absDelta * 1e18 / absB;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/StdStorage.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {Vm} from "./Vm.sol";
   5 |     | 
   6 |     | struct StdStorage {
   7 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;
   8 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;
   9 |     |     bytes32[] _keys;
  10 |     |     bytes4 _sig;
  11 |     |     uint256 _depth;
  12 |     |     address _target;
  13 |     |     bytes32 _set;
  14 |     | }
  15 |     | 
  16 |     | library stdStorageSafe {
  17 |     |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
  18 |     |     event WARNING_UninitedSlot(address who, uint256 slot);
  19 |     | 
  20 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  21 |     | 
  22 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
  23 |     |         return bytes4(keccak256(bytes(sigStr)));
  24 |     |     }
  25 |     | 
  26 |     |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
  27 |     |     // slot complexity:
  28 |     |     //  if flat, will be bytes32(uint256(uint));
  29 |     |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
  30 |     |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
  31 |     |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
  32 |     |     function find(StdStorage storage self) internal returns (uint256) {
  33 |     |         address who = self._target;
  34 |     |         bytes4 fsig = self._sig;
  35 |     |         uint256 field_depth = self._depth;
  36 |     |         bytes32[] memory ins = self._keys;
  37 |     | 
  38 |     |         // calldata to test against
  39 |     |         if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
  40 |     |             return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
  41 |     |         }
  42 |     |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
  43 |     |         vm.record();
  44 |     |         bytes32 fdat;
  45 |     |         {
  46 |     |             (, bytes memory rdat) = who.staticcall(cald);
  47 |     |             fdat = bytesToBytes32(rdat, 32 * field_depth);
  48 |     |         }
  49 |     | 
  50 |     |         (bytes32[] memory reads,) = vm.accesses(address(who));
  51 |     |         if (reads.length == 1) {
  52 |     |             bytes32 curr = vm.load(who, reads[0]);
  53 |     |             if (curr == bytes32(0)) {
  54 |     |                 emit WARNING_UninitedSlot(who, uint256(reads[0]));
  55 |     |             }
  56 |     |             if (fdat != curr) {
  57 |     |                 require(
  58 |     |                     false,
  59 |     |                     "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported."
  60 |     |                 );
  61 |     |             }
  62 |     |             emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));
  63 |     |             self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);
  64 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
  65 |     |         } else if (reads.length > 1) {
  66 |     |             for (uint256 i = 0; i < reads.length; i++) {
  67 |     |                 bytes32 prev = vm.load(who, reads[i]);
  68 |     |                 if (prev == bytes32(0)) {
  69 |     |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
  70 |     |                 }
  71 |     |                 if (prev != fdat) {
  72 |     |                     continue;
  73 |     |                 }
  74 |     |                 bytes32 new_val = ~prev;
  75 |     |                 // store
  76 |     |                 vm.store(who, reads[i], new_val);
  77 |     |                 bool success;
  78 |     |                 {
  79 |     |                     bytes memory rdat;
  80 |     |                     (success, rdat) = who.staticcall(cald);
  81 |     |                     fdat = bytesToBytes32(rdat, 32 * field_depth);
  82 |     |                 }
  83 |     | 
  84 |     |                 if (success && fdat == new_val) {
  85 |     |                     // we found which of the slots is the actual one
  86 |     |                     emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));
  87 |     |                     self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);
  88 |     |                     self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
  89 |     |                     vm.store(who, reads[i], prev);
  90 |     |                     break;
  91 |     |                 }
  92 |     |                 vm.store(who, reads[i], prev);
  93 |     |             }
  94 |     |         } else {
  95 |     |             revert("stdStorage find(StdStorage): No storage use detected for target.");
  96 |     |         }
  97 |     | 
  98 |     |         require(
  99 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],
 100 |     |             "stdStorage find(StdStorage): Slot(s) not found."
 101 |     |         );
 102 |     | 
 103 |     |         delete self._target;
 104 |     |         delete self._sig;
 105 |     |         delete self._keys;
 106 |     |         delete self._depth;
 107 |     | 
 108 |     |         return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
 109 |     |     }
 110 |     | 
 111 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 112 |     |         self._target = _target;
 113 |     |         return self;
 114 |     |     }
 115 |     | 
 116 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 117 |     |         self._sig = _sig;
 118 |     |         return self;
 119 |     |     }
 120 |     | 
 121 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 122 |     |         self._sig = sigs(_sig);
 123 |     |         return self;
 124 |     |     }
 125 |     | 
 126 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 127 |     |         self._keys.push(bytes32(uint256(uint160(who))));
 128 |     |         return self;
 129 |     |     }
 130 |     | 
 131 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 132 |     |         self._keys.push(bytes32(amt));
 133 |     |         return self;
 134 |     |     }
 135 |     | 
 136 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 137 |     |         self._keys.push(key);
 138 |     |         return self;
 139 |     |     }
 140 |     | 
 141 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 142 |     |         self._depth = _depth;
 143 |     |         return self;
 144 |     |     }
 145 |     | 
 146 |     |     function read(StdStorage storage self) private returns (bytes memory) {
 147 |     |         address t = self._target;
 148 |     |         uint256 s = find(self);
 149 |     |         return abi.encode(vm.load(t, bytes32(s)));
 150 |     |     }
 151 |     | 
 152 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 153 |     |         return abi.decode(read(self), (bytes32));
 154 |     |     }
 155 |     | 
 156 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 157 |     |         int256 v = read_int(self);
 158 |     |         if (v == 0) return false;
 159 |     |         if (v == 1) return true;
 160 |     |         revert("stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.");
 161 |     |     }
 162 |     | 
 163 |     |     function read_address(StdStorage storage self) internal returns (address) {
 164 |     |         return abi.decode(read(self), (address));
 165 |     |     }
 166 |     | 
 167 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 168 |     |         return abi.decode(read(self), (uint256));
 169 |     |     }
 170 |     | 
 171 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 172 |     |         return abi.decode(read(self), (int256));
 173 |     |     }
 174 |     | 
 175 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 176 |     |         address who = self._target;
 177 |     |         uint256 field_depth = self._depth;
 178 |     |         vm.startMappingRecording();
 179 |     |         uint256 child = find(self) - field_depth;
 180 |     |         (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 181 |     |         if (!found) {
 182 |     |             revert(
 183 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 184 |     |             );
 185 |     |         }
 186 |     |         return (uint256(parent_slot), key);
 187 |     |     }
 188 |     | 
 189 |     |     function root(StdStorage storage self) internal returns (uint256) {
 190 |     |         address who = self._target;
 191 |     |         uint256 field_depth = self._depth;
 192 |     |         vm.startMappingRecording();
 193 |     |         uint256 child = find(self) - field_depth;
 194 |     |         bool found;
 195 |     |         bytes32 root_slot;
 196 |     |         bytes32 parent_slot;
 197 |     |         (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 198 |     |         if (!found) {
 199 |     |             revert(
 200 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 201 |     |             );
 202 |     |         }
 203 |     |         while (found) {
 204 |     |             root_slot = parent_slot;
 205 |     |             (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));
 206 |     |         }
 207 |     |         return uint256(root_slot);
 208 |     |     }
 209 |     | 
 210 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 211 |     |         bytes32 out;
 212 |     | 
 213 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 214 |     |         for (uint256 i = 0; i < max; i++) {
 215 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 216 |     |         }
 217 |     |         return out;
 218 |     |     }
 219 |     | 
 220 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 221 |     |         bytes memory result = new bytes(b.length * 32);
 222 |     |         for (uint256 i = 0; i < b.length; i++) {
 223 |     |             bytes32 k = b[i];
 224 |     |             /// @solidity memory-safe-assembly
 225 |     |             assembly {
 226 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 227 |     |             }
 228 |     |         }
 229 |     | 
 230 |     |         return result;
 231 |     |     }
 232 |     | }
 233 |     | 
 234 |     | library stdStorage {
 235 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 236 |     | 
 237 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
 238 |     |         return stdStorageSafe.sigs(sigStr);
 239 |     |     }
 240 |     | 
 241 |     |     function find(StdStorage storage self) internal returns (uint256) {
 242 |     |         return stdStorageSafe.find(self);
 243 |     |     }
 244 |     | 
 245 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 246 |     |         return stdStorageSafe.target(self, _target);
 247 |     |     }
 248 |     | 
 249 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 250 |     |         return stdStorageSafe.sig(self, _sig);
 251 |     |     }
 252 |     | 
 253 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 254 |     |         return stdStorageSafe.sig(self, _sig);
 255 |     |     }
 256 |     | 
 257 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 258 |     |         return stdStorageSafe.with_key(self, who);
 259 |     |     }
 260 |     | 
 261 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 262 |     |         return stdStorageSafe.with_key(self, amt);
 263 |     |     }
 264 |     | 
 265 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 266 |     |         return stdStorageSafe.with_key(self, key);
 267 |     |     }
 268 |     | 
 269 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 270 |     |         return stdStorageSafe.depth(self, _depth);
 271 |     |     }
 272 |     | 
 273 |     |     function checked_write(StdStorage storage self, address who) internal {
 274 |     |         checked_write(self, bytes32(uint256(uint160(who))));
 275 |     |     }
 276 |     | 
 277 |     |     function checked_write(StdStorage storage self, uint256 amt) internal {
 278 |     |         checked_write(self, bytes32(amt));
 279 |     |     }
 280 |     | 
 281 |     |     function checked_write_int(StdStorage storage self, int256 val) internal {
 282 |     |         checked_write(self, bytes32(uint256(val)));
 283 |     |     }
 284 |     | 
 285 |     |     function checked_write(StdStorage storage self, bool write) internal {
 286 |     |         bytes32 t;
 287 |     |         /// @solidity memory-safe-assembly
 288 |     |         assembly {
 289 |     |             t := write
 290 |     |         }
 291 |     |         checked_write(self, t);
 292 |     |     }
 293 |     | 
 294 |     |     function checked_write(StdStorage storage self, bytes32 set) internal {
 295 |     |         address who = self._target;
 296 |     |         bytes4 fsig = self._sig;
 297 |     |         uint256 field_depth = self._depth;
 298 |     |         bytes32[] memory ins = self._keys;
 299 |     | 
 300 |     |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
 301 |     |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
 302 |     |             find(self);
 303 |     |         }
 304 |     |         bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);
 305 |     | 
 306 |     |         bytes32 fdat;
 307 |     |         {
 308 |     |             (, bytes memory rdat) = who.staticcall(cald);
 309 |     |             fdat = bytesToBytes32(rdat, 32 * field_depth);
 310 |     |         }
 311 |     |         bytes32 curr = vm.load(who, slot);
 312 |     | 
 313 |     |         if (fdat != curr) {
 314 |     |             require(
 315 |     |                 false,
 316 |     |                 "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported."
 317 |     |             );
 318 |     |         }
 319 |     |         vm.store(who, slot, set);
 320 |     |         delete self._target;
 321 |     |         delete self._sig;
 322 |     |         delete self._keys;
 323 |     |         delete self._depth;
 324 |     |     }
 325 |     | 
 326 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 327 |     |         return stdStorageSafe.read_bytes32(self);
 328 |     |     }
 329 |     | 
 330 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 331 |     |         return stdStorageSafe.read_bool(self);
 332 |     |     }
 333 |     | 
 334 |     |     function read_address(StdStorage storage self) internal returns (address) {
 335 |     |         return stdStorageSafe.read_address(self);
 336 |     |     }
 337 |     | 
 338 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 339 |     |         return stdStorageSafe.read_uint(self);
 340 |     |     }
 341 |     | 
 342 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 343 |     |         return stdStorageSafe.read_int(self);
 344 |     |     }
 345 |     | 
 346 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 347 |     |         return stdStorageSafe.parent(self);
 348 |     |     }
 349 |     | 
 350 |     |     function root(StdStorage storage self) internal returns (uint256) {
 351 |     |         return stdStorageSafe.root(self);
 352 |     |     }
 353 |     | 
 354 |     |     // Private function so needs to be copied over
 355 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 356 |     |         bytes32 out;
 357 |     | 
 358 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 359 |     |         for (uint256 i = 0; i < max; i++) {
 360 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 361 |     |         }
 362 |     |         return out;
 363 |     |     }
 364 |     | 
 365 |     |     // Private function so needs to be copied over
 366 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 367 |     |         bytes memory result = new bytes(b.length * 32);
 368 |     |         for (uint256 i = 0; i < b.length; i++) {
 369 |     |             bytes32 k = b[i];
 370 |     |             /// @solidity memory-safe-assembly
 371 |     |             assembly {
 372 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 373 |     |             }
 374 |     |         }
 375 |     | 
 376 |     |         return result;
 377 |     |     }
 378 |     | }
 379 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/StdStyle.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.4.22 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | library StdStyle {
   7 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
   8 |     | 
   9 |     |     string constant RED = "\u001b[91m";
  10 |     |     string constant GREEN = "\u001b[92m";
  11 |     |     string constant YELLOW = "\u001b[93m";
  12 |     |     string constant BLUE = "\u001b[94m";
  13 |     |     string constant MAGENTA = "\u001b[95m";
  14 |     |     string constant CYAN = "\u001b[96m";
  15 |     |     string constant BOLD = "\u001b[1m";
  16 |     |     string constant DIM = "\u001b[2m";
  17 |     |     string constant ITALIC = "\u001b[3m";
  18 |     |     string constant UNDERLINE = "\u001b[4m";
  19 |     |     string constant INVERSE = "\u001b[7m";
  20 |     |     string constant RESET = "\u001b[0m";
  21 |     | 
  22 |     |     function styleConcat(string memory style, string memory self) private pure returns (string memory) {
  23 |     |         return string(abi.encodePacked(style, self, RESET));
  24 |     |     }
  25 |     | 
  26 |     |     function red(string memory self) internal pure returns (string memory) {
  27 |     |         return styleConcat(RED, self);
  28 |     |     }
  29 |     | 
  30 |     |     function red(uint256 self) internal pure returns (string memory) {
  31 |     |         return red(vm.toString(self));
  32 |     |     }
  33 |     | 
  34 |     |     function red(int256 self) internal pure returns (string memory) {
  35 |     |         return red(vm.toString(self));
  36 |     |     }
  37 |     | 
  38 |     |     function red(address self) internal pure returns (string memory) {
  39 |     |         return red(vm.toString(self));
  40 |     |     }
  41 |     | 
  42 |     |     function red(bool self) internal pure returns (string memory) {
  43 |     |         return red(vm.toString(self));
  44 |     |     }
  45 |     | 
  46 |     |     function redBytes(bytes memory self) internal pure returns (string memory) {
  47 |     |         return red(vm.toString(self));
  48 |     |     }
  49 |     | 
  50 |     |     function redBytes32(bytes32 self) internal pure returns (string memory) {
  51 |     |         return red(vm.toString(self));
  52 |     |     }
  53 |     | 
  54 |     |     function green(string memory self) internal pure returns (string memory) {
  55 |     |         return styleConcat(GREEN, self);
  56 |     |     }
  57 |     | 
  58 |     |     function green(uint256 self) internal pure returns (string memory) {
  59 |     |         return green(vm.toString(self));
  60 |     |     }
  61 |     | 
  62 |     |     function green(int256 self) internal pure returns (string memory) {
  63 |     |         return green(vm.toString(self));
  64 |     |     }
  65 |     | 
  66 |     |     function green(address self) internal pure returns (string memory) {
  67 |     |         return green(vm.toString(self));
  68 |     |     }
  69 |     | 
  70 |     |     function green(bool self) internal pure returns (string memory) {
  71 |     |         return green(vm.toString(self));
  72 |     |     }
  73 |     | 
  74 |     |     function greenBytes(bytes memory self) internal pure returns (string memory) {
  75 |     |         return green(vm.toString(self));
  76 |     |     }
  77 |     | 
  78 |     |     function greenBytes32(bytes32 self) internal pure returns (string memory) {
  79 |     |         return green(vm.toString(self));
  80 |     |     }
  81 |     | 
  82 |     |     function yellow(string memory self) internal pure returns (string memory) {
  83 |     |         return styleConcat(YELLOW, self);
  84 |     |     }
  85 |     | 
  86 |     |     function yellow(uint256 self) internal pure returns (string memory) {
  87 |     |         return yellow(vm.toString(self));
  88 |     |     }
  89 |     | 
  90 |     |     function yellow(int256 self) internal pure returns (string memory) {
  91 |     |         return yellow(vm.toString(self));
  92 |     |     }
  93 |     | 
  94 |     |     function yellow(address self) internal pure returns (string memory) {
  95 |     |         return yellow(vm.toString(self));
  96 |     |     }
  97 |     | 
  98 |     |     function yellow(bool self) internal pure returns (string memory) {
  99 |     |         return yellow(vm.toString(self));
 100 |     |     }
 101 |     | 
 102 |     |     function yellowBytes(bytes memory self) internal pure returns (string memory) {
 103 |     |         return yellow(vm.toString(self));
 104 |     |     }
 105 |     | 
 106 |     |     function yellowBytes32(bytes32 self) internal pure returns (string memory) {
 107 |     |         return yellow(vm.toString(self));
 108 |     |     }
 109 |     | 
 110 |     |     function blue(string memory self) internal pure returns (string memory) {
 111 |     |         return styleConcat(BLUE, self);
 112 |     |     }
 113 |     | 
 114 |     |     function blue(uint256 self) internal pure returns (string memory) {
 115 |     |         return blue(vm.toString(self));
 116 |     |     }
 117 |     | 
 118 |     |     function blue(int256 self) internal pure returns (string memory) {
 119 |     |         return blue(vm.toString(self));
 120 |     |     }
 121 |     | 
 122 |     |     function blue(address self) internal pure returns (string memory) {
 123 |     |         return blue(vm.toString(self));
 124 |     |     }
 125 |     | 
 126 |     |     function blue(bool self) internal pure returns (string memory) {
 127 |     |         return blue(vm.toString(self));
 128 |     |     }
 129 |     | 
 130 |     |     function blueBytes(bytes memory self) internal pure returns (string memory) {
 131 |     |         return blue(vm.toString(self));
 132 |     |     }
 133 |     | 
 134 |     |     function blueBytes32(bytes32 self) internal pure returns (string memory) {
 135 |     |         return blue(vm.toString(self));
 136 |     |     }
 137 |     | 
 138 |     |     function magenta(string memory self) internal pure returns (string memory) {
 139 |     |         return styleConcat(MAGENTA, self);
 140 |     |     }
 141 |     | 
 142 |     |     function magenta(uint256 self) internal pure returns (string memory) {
 143 |     |         return magenta(vm.toString(self));
 144 |     |     }
 145 |     | 
 146 |     |     function magenta(int256 self) internal pure returns (string memory) {
 147 |     |         return magenta(vm.toString(self));
 148 |     |     }
 149 |     | 
 150 |     |     function magenta(address self) internal pure returns (string memory) {
 151 |     |         return magenta(vm.toString(self));
 152 |     |     }
 153 |     | 
 154 |     |     function magenta(bool self) internal pure returns (string memory) {
 155 |     |         return magenta(vm.toString(self));
 156 |     |     }
 157 |     | 
 158 |     |     function magentaBytes(bytes memory self) internal pure returns (string memory) {
 159 |     |         return magenta(vm.toString(self));
 160 |     |     }
 161 |     | 
 162 |     |     function magentaBytes32(bytes32 self) internal pure returns (string memory) {
 163 |     |         return magenta(vm.toString(self));
 164 |     |     }
 165 |     | 
 166 |     |     function cyan(string memory self) internal pure returns (string memory) {
 167 |     |         return styleConcat(CYAN, self);
 168 |     |     }
 169 |     | 
 170 |     |     function cyan(uint256 self) internal pure returns (string memory) {
 171 |     |         return cyan(vm.toString(self));
 172 |     |     }
 173 |     | 
 174 |     |     function cyan(int256 self) internal pure returns (string memory) {
 175 |     |         return cyan(vm.toString(self));
 176 |     |     }
 177 |     | 
 178 |     |     function cyan(address self) internal pure returns (string memory) {
 179 |     |         return cyan(vm.toString(self));
 180 |     |     }
 181 |     | 
 182 |     |     function cyan(bool self) internal pure returns (string memory) {
 183 |     |         return cyan(vm.toString(self));
 184 |     |     }
 185 |     | 
 186 |     |     function cyanBytes(bytes memory self) internal pure returns (string memory) {
 187 |     |         return cyan(vm.toString(self));
 188 |     |     }
 189 |     | 
 190 |     |     function cyanBytes32(bytes32 self) internal pure returns (string memory) {
 191 |     |         return cyan(vm.toString(self));
 192 |     |     }
 193 |     | 
 194 |     |     function bold(string memory self) internal pure returns (string memory) {
 195 |     |         return styleConcat(BOLD, self);
 196 |     |     }
 197 |     | 
 198 |     |     function bold(uint256 self) internal pure returns (string memory) {
 199 |     |         return bold(vm.toString(self));
 200 |     |     }
 201 |     | 
 202 |     |     function bold(int256 self) internal pure returns (string memory) {
 203 |     |         return bold(vm.toString(self));
 204 |     |     }
 205 |     | 
 206 |     |     function bold(address self) internal pure returns (string memory) {
 207 |     |         return bold(vm.toString(self));
 208 |     |     }
 209 |     | 
 210 |     |     function bold(bool self) internal pure returns (string memory) {
 211 |     |         return bold(vm.toString(self));
 212 |     |     }
 213 |     | 
 214 |     |     function boldBytes(bytes memory self) internal pure returns (string memory) {
 215 |     |         return bold(vm.toString(self));
 216 |     |     }
 217 |     | 
 218 |     |     function boldBytes32(bytes32 self) internal pure returns (string memory) {
 219 |     |         return bold(vm.toString(self));
 220 |     |     }
 221 |     | 
 222 |     |     function dim(string memory self) internal pure returns (string memory) {
 223 |     |         return styleConcat(DIM, self);
 224 |     |     }
 225 |     | 
 226 |     |     function dim(uint256 self) internal pure returns (string memory) {
 227 |     |         return dim(vm.toString(self));
 228 |     |     }
 229 |     | 
 230 |     |     function dim(int256 self) internal pure returns (string memory) {
 231 |     |         return dim(vm.toString(self));
 232 |     |     }
 233 |     | 
 234 |     |     function dim(address self) internal pure returns (string memory) {
 235 |     |         return dim(vm.toString(self));
 236 |     |     }
 237 |     | 
 238 |     |     function dim(bool self) internal pure returns (string memory) {
 239 |     |         return dim(vm.toString(self));
 240 |     |     }
 241 |     | 
 242 |     |     function dimBytes(bytes memory self) internal pure returns (string memory) {
 243 |     |         return dim(vm.toString(self));
 244 |     |     }
 245 |     | 
 246 |     |     function dimBytes32(bytes32 self) internal pure returns (string memory) {
 247 |     |         return dim(vm.toString(self));
 248 |     |     }
 249 |     | 
 250 |     |     function italic(string memory self) internal pure returns (string memory) {
 251 |     |         return styleConcat(ITALIC, self);
 252 |     |     }
 253 |     | 
 254 |     |     function italic(uint256 self) internal pure returns (string memory) {
 255 |     |         return italic(vm.toString(self));
 256 |     |     }
 257 |     | 
 258 |     |     function italic(int256 self) internal pure returns (string memory) {
 259 |     |         return italic(vm.toString(self));
 260 |     |     }
 261 |     | 
 262 |     |     function italic(address self) internal pure returns (string memory) {
 263 |     |         return italic(vm.toString(self));
 264 |     |     }
 265 |     | 
 266 |     |     function italic(bool self) internal pure returns (string memory) {
 267 |     |         return italic(vm.toString(self));
 268 |     |     }
 269 |     | 
 270 |     |     function italicBytes(bytes memory self) internal pure returns (string memory) {
 271 |     |         return italic(vm.toString(self));
 272 |     |     }
 273 |     | 
 274 |     |     function italicBytes32(bytes32 self) internal pure returns (string memory) {
 275 |     |         return italic(vm.toString(self));
 276 |     |     }
 277 |     | 
 278 |     |     function underline(string memory self) internal pure returns (string memory) {
 279 |     |         return styleConcat(UNDERLINE, self);
 280 |     |     }
 281 |     | 
 282 |     |     function underline(uint256 self) internal pure returns (string memory) {
 283 |     |         return underline(vm.toString(self));
 284 |     |     }
 285 |     | 
 286 |     |     function underline(int256 self) internal pure returns (string memory) {
 287 |     |         return underline(vm.toString(self));
 288 |     |     }
 289 |     | 
 290 |     |     function underline(address self) internal pure returns (string memory) {
 291 |     |         return underline(vm.toString(self));
 292 |     |     }
 293 |     | 
 294 |     |     function underline(bool self) internal pure returns (string memory) {
 295 |     |         return underline(vm.toString(self));
 296 |     |     }
 297 |     | 
 298 |     |     function underlineBytes(bytes memory self) internal pure returns (string memory) {
 299 |     |         return underline(vm.toString(self));
 300 |     |     }
 301 |     | 
 302 |     |     function underlineBytes32(bytes32 self) internal pure returns (string memory) {
 303 |     |         return underline(vm.toString(self));
 304 |     |     }
 305 |     | 
 306 |     |     function inverse(string memory self) internal pure returns (string memory) {
 307 |     |         return styleConcat(INVERSE, self);
 308 |     |     }
 309 |     | 
 310 |     |     function inverse(uint256 self) internal pure returns (string memory) {
 311 |     |         return inverse(vm.toString(self));
 312 |     |     }
 313 |     | 
 314 |     |     function inverse(int256 self) internal pure returns (string memory) {
 315 |     |         return inverse(vm.toString(self));
 316 |     |     }
 317 |     | 
 318 |     |     function inverse(address self) internal pure returns (string memory) {
 319 |     |         return inverse(vm.toString(self));
 320 |     |     }
 321 |     | 
 322 |     |     function inverse(bool self) internal pure returns (string memory) {
 323 |     |         return inverse(vm.toString(self));
 324 |     |     }
 325 |     | 
 326 |     |     function inverseBytes(bytes memory self) internal pure returns (string memory) {
 327 |     |         return inverse(vm.toString(self));
 328 |     |     }
 329 |     | 
 330 |     |     function inverseBytes32(bytes32 self) internal pure returns (string memory) {
 331 |     |         return inverse(vm.toString(self));
 332 |     |     }
 333 |     | }
 334 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/StdUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {IMulticall3} from "./interfaces/IMulticall3.sol";
   7 |     | import {MockERC20} from "./mocks/MockERC20.sol";
   8 |     | import {MockERC721} from "./mocks/MockERC721.sol";
   9 |     | import {VmSafe} from "./Vm.sol";
  10 |     | 
  11 |     | abstract contract StdUtils {
  12 |     |     /*//////////////////////////////////////////////////////////////////////////
  13 |     |                                      CONSTANTS
  14 |     |     //////////////////////////////////////////////////////////////////////////*/
  15 |     | 
  16 |     |     IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);
  17 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  18 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
  19 |     |     uint256 private constant INT256_MIN_ABS =
  20 |     |         57896044618658097711785492504343953926634992332820282019728792003956564819968;
  21 |     |     uint256 private constant SECP256K1_ORDER =
  22 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
  23 |     |     uint256 private constant UINT256_MAX =
  24 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  25 |     | 
  26 |     |     // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
  27 |     |     address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
  28 |     | 
  29 |     |     /*//////////////////////////////////////////////////////////////////////////
  30 |     |                                  INTERNAL FUNCTIONS
  31 |     |     //////////////////////////////////////////////////////////////////////////*/
  32 |     | 
  33 |     |     function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  34 |     |         require(min <= max, "StdUtils bound(uint256,uint256,uint256): Max is less than min.");
  35 |     |         // If x is between min and max, return x directly. This is to ensure that dictionary values
  36 |     |         // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188
  37 |     |         if (x >= min && x <= max) return x;
  38 |     | 
  39 |     |         uint256 size = max - min + 1;
  40 |     | 
  41 |     |         // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.
  42 |     |         // This helps ensure coverage of the min/max values.
  43 |     |         if (x <= 3 && size > x) return min + x;
  44 |     |         if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);
  45 |     | 
  46 |     |         // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
  47 |     |         if (x > max) {
  48 |     |             uint256 diff = x - max;
  49 |     |             uint256 rem = diff % size;
  50 |     |             if (rem == 0) return max;
  51 |     |             result = min + rem - 1;
  52 |     |         } else if (x < min) {
  53 |     |             uint256 diff = min - x;
  54 |     |             uint256 rem = diff % size;
  55 |     |             if (rem == 0) return min;
  56 |     |             result = max - rem + 1;
  57 |     |         }
  58 |     |     }
  59 |     | 
  60 |     |     function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  61 |     |         result = _bound(x, min, max);
  62 |     |         console2_log_StdUtils("Bound Result", result);
  63 |     |     }
  64 |     | 
  65 |     |     function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  66 |     |         require(min <= max, "StdUtils bound(int256,int256,int256): Max is less than min.");
  67 |     | 
  68 |     |         // Shifting all int256 values to uint256 to use _bound function. The range of two types are:
  69 |     |         // int256 : -(2**255) ~ (2**255 - 1)
  70 |     |         // uint256:     0     ~ (2**256 - 1)
  71 |     |         // So, add 2**255, INT256_MIN_ABS to the integer values.
  72 |     |         //
  73 |     |         // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.
  74 |     |         // So, use `~uint256(x) + 1` instead.
  75 |     |         uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);
  76 |     |         uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);
  77 |     |         uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);
  78 |     | 
  79 |     |         uint256 y = _bound(_x, _min, _max);
  80 |     | 
  81 |     |         // To move it back to int256 value, subtract INT256_MIN_ABS at here.
  82 |     |         result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);
  83 |     |     }
  84 |     | 
  85 |     |     function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  86 |     |         result = _bound(x, min, max);
  87 |     |         console2_log_StdUtils("Bound result", vm.toString(result));
  88 |     |     }
  89 |     | 
  90 |     |     function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {
  91 |     |         result = _bound(privateKey, 1, SECP256K1_ORDER - 1);
  92 |     |     }
  93 |     | 
  94 |     |     function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {
  95 |     |         require(b.length <= 32, "StdUtils bytesToUint(bytes): Bytes length exceeds 32.");
  96 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
  97 |     |     }
  98 |     | 
  99 |     |     /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce
 100 |     |     /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)
 101 |     |     function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {
 102 |     |         console2_log_StdUtils("computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.");
 103 |     |         return vm.computeCreateAddress(deployer, nonce);
 104 |     |     }
 105 |     | 
 106 |     |     function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)
 107 |     |         internal
 108 |     |         pure
 109 |     |         virtual
 110 |     |         returns (address)
 111 |     |     {
 112 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 113 |     |         return vm.computeCreate2Address(salt, initcodeHash, deployer);
 114 |     |     }
 115 |     | 
 116 |     |     /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer
 117 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {
 118 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 119 |     |         return vm.computeCreate2Address(salt, initCodeHash);
 120 |     |     }
 121 |     | 
 122 |     |     /// @dev returns an initialized mock ERC20 contract
 123 |     |     function deployMockERC20(string memory name, string memory symbol, uint8 decimals)
 124 |     |         internal
 125 |     |         returns (MockERC20 mock)
 126 |     |     {
 127 |     |         mock = new MockERC20();
 128 |     |         mock.initialize(name, symbol, decimals);
 129 |     |     }
 130 |     | 
 131 |     |     /// @dev returns an initialized mock ERC721 contract
 132 |     |     function deployMockERC721(string memory name, string memory symbol) internal returns (MockERC721 mock) {
 133 |     |         mock = new MockERC721();
 134 |     |         mock.initialize(name, symbol);
 135 |     |     }
 136 |     | 
 137 |     |     /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments
 138 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 139 |     |     function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {
 140 |     |         return hashInitCode(creationCode, "");
 141 |     |     }
 142 |     | 
 143 |     |     /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2
 144 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 145 |     |     /// @param args the ABI-encoded arguments to the constructor of C
 146 |     |     function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {
 147 |     |         return keccak256(abi.encodePacked(creationCode, args));
 148 |     |     }
 149 |     | 
 150 |     |     // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.
 151 |     |     function getTokenBalances(address token, address[] memory addresses)
 152 |     |         internal
 153 |     |         virtual
 154 |     |         returns (uint256[] memory balances)
 155 |     |     {
 156 |     |         uint256 tokenCodeSize;
 157 |     |         assembly {
 158 |     |             tokenCodeSize := extcodesize(token)
 159 |     |         }
 160 |     |         require(tokenCodeSize > 0, "StdUtils getTokenBalances(address,address[]): Token address is not a contract.");
 161 |     | 
 162 |     |         // ABI encode the aggregate call to Multicall3.
 163 |     |         uint256 length = addresses.length;
 164 |     |         IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);
 165 |     |         for (uint256 i = 0; i < length; ++i) {
 166 |     |             // 0x70a08231 = bytes4("balanceOf(address)"))
 167 |     |             calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});
 168 |     |         }
 169 |     | 
 170 |     |         // Make the aggregate call.
 171 |     |         (, bytes[] memory returnData) = multicall.aggregate(calls);
 172 |     | 
 173 |     |         // ABI decode the return data and return the balances.
 174 |     |         balances = new uint256[](length);
 175 |     |         for (uint256 i = 0; i < length; ++i) {
 176 |     |             balances[i] = abi.decode(returnData[i], (uint256));
 177 |     |         }
 178 |     |     }
 179 |     | 
 180 |     |     /*//////////////////////////////////////////////////////////////////////////
 181 |     |                                  PRIVATE FUNCTIONS
 182 |     |     //////////////////////////////////////////////////////////////////////////*/
 183 |     | 
 184 |     |     function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {
 185 |     |         return address(uint160(uint256(bytesValue)));
 186 |     |     }
 187 |     | 
 188 |     |     // This section is used to prevent the compilation of console, which shortens the compilation time when console is
 189 |     |     // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid
 190 |     |     // any breaking changes to function signatures.
 191 |     |     function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)
 192 |     |         internal
 193 |     |         pure
 194 |     |         returns (function(bytes memory) internal pure fnOut)
 195 |     |     {
 196 |     |         assembly {
 197 |     |             fnOut := fnIn
 198 |     |         }
 199 |     |     }
 200 |     | 
 201 |     |     function _sendLogPayload(bytes memory payload) internal pure {
 202 |     |         _castLogPayloadViewToPure(_sendLogPayloadView)(payload);
 203 |     |     }
 204 |     | 
 205 |     |     function _sendLogPayloadView(bytes memory payload) private view {
 206 |     |         uint256 payloadLength = payload.length;
 207 |     |         address consoleAddress = CONSOLE2_ADDRESS;
 208 |     |         /// @solidity memory-safe-assembly
 209 |     |         assembly {
 210 |     |             let payloadStart := add(payload, 32)
 211 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
 212 |     |         }
 213 |     |     }
 214 |     | 
 215 |     |     function console2_log_StdUtils(string memory p0) private pure {
 216 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
 217 |     |     }
 218 |     | 
 219 |     |     function console2_log_StdUtils(string memory p0, uint256 p1) private pure {
 220 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
 221 |     |     }
 222 |     | 
 223 |     |     function console2_log_StdUtils(string memory p0, string memory p1) private pure {
 224 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
 225 |     |     }
 226 |     | }
 227 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/Test.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | // 💬 ABOUT
  7 |     | // Forge Std's default Test.
  8 |     | 
  9 |     | // 🧩 MODULES
 10 |     | import {console} from "./console.sol";
 11 |     | import {console2} from "./console2.sol";
 12 |     | import {safeconsole} from "./safeconsole.sol";
 13 |     | import {StdAssertions} from "./StdAssertions.sol";
 14 |     | import {StdChains} from "./StdChains.sol";
 15 |     | import {StdCheats} from "./StdCheats.sol";
 16 |     | import {stdError} from "./StdError.sol";
 17 |     | import {StdInvariant} from "./StdInvariant.sol";
 18 |     | import {stdJson} from "./StdJson.sol";
 19 |     | import {stdMath} from "./StdMath.sol";
 20 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
 21 |     | import {StdStyle} from "./StdStyle.sol";
 22 |     | import {StdUtils} from "./StdUtils.sol";
 23 |     | import {Vm} from "./Vm.sol";
 24 |     | 
 25 |     | // 📦 BOILERPLATE
 26 |     | import {TestBase} from "./Base.sol";
 27 |     | import {DSTest} from "ds-test/test.sol";
 28 |     | 
 29 |     | // ⭐️ TEST
 30 |     | abstract contract Test is TestBase, DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {
 31 |     | // Note: IS_TEST() must return true.
 32 |     | // Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.
 33 |     | }
 34 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/Vm.sol
    1 |     | // Automatically @generated by scripts/vm.py. Do not modify manually.
    2 |     | 
    3 |     | // SPDX-License-Identifier: MIT OR Apache-2.0
    4 |     | pragma solidity >=0.6.2 <0.9.0;
    5 |     | pragma experimental ABIEncoderV2;
    6 |     | 
    7 |     | /// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may
    8 |     | /// result in Script simulations differing from on-chain execution. It is recommended to only use
    9 |     | /// these cheats in scripts.
   10 |     | interface VmSafe {
   11 |     |     /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.
   12 |     |     enum CallerMode {
   13 |     |         // No caller modification is currently active.
   14 |     |         None,
   15 |     |         // A one time broadcast triggered by a `vm.broadcast()` call is currently active.
   16 |     |         Broadcast,
   17 |     |         // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.
   18 |     |         RecurrentBroadcast,
   19 |     |         // A one time prank triggered by a `vm.prank()` call is currently active.
   20 |     |         Prank,
   21 |     |         // A recurrent prank triggered by a `vm.startPrank()` call is currently active.
   22 |     |         RecurrentPrank
   23 |     |     }
   24 |     | 
   25 |     |     /// The kind of account access that occurred.
   26 |     |     enum AccountAccessKind {
   27 |     |         // The account was called.
   28 |     |         Call,
   29 |     |         // The account was called via delegatecall.
   30 |     |         DelegateCall,
   31 |     |         // The account was called via callcode.
   32 |     |         CallCode,
   33 |     |         // The account was called via staticcall.
   34 |     |         StaticCall,
   35 |     |         // The account was created.
   36 |     |         Create,
   37 |     |         // The account was selfdestructed.
   38 |     |         SelfDestruct,
   39 |     |         // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).
   40 |     |         Resume,
   41 |     |         // The account's balance was read.
   42 |     |         Balance,
   43 |     |         // The account's codesize was read.
   44 |     |         Extcodesize,
   45 |     |         // The account's codehash was read.
   46 |     |         Extcodehash,
   47 |     |         // The account's code was copied.
   48 |     |         Extcodecopy
   49 |     |     }
   50 |     | 
   51 |     |     /// An Ethereum log. Returned by `getRecordedLogs`.
   52 |     |     struct Log {
   53 |     |         // The topics of the log, including the signature, if any.
   54 |     |         bytes32[] topics;
   55 |     |         // The raw data of the log.
   56 |     |         bytes data;
   57 |     |         // The address of the log's emitter.
   58 |     |         address emitter;
   59 |     |     }
   60 |     | 
   61 |     |     /// An RPC URL and its alias. Returned by `rpcUrlStructs`.
   62 |     |     struct Rpc {
   63 |     |         // The alias of the RPC URL.
   64 |     |         string key;
   65 |     |         // The RPC URL.
   66 |     |         string url;
   67 |     |     }
   68 |     | 
   69 |     |     /// An RPC log object. Returned by `eth_getLogs`.
   70 |     |     struct EthGetLogs {
   71 |     |         // The address of the log's emitter.
   72 |     |         address emitter;
   73 |     |         // The topics of the log, including the signature, if any.
   74 |     |         bytes32[] topics;
   75 |     |         // The raw data of the log.
   76 |     |         bytes data;
   77 |     |         // The block hash.
   78 |     |         bytes32 blockHash;
   79 |     |         // The block number.
   80 |     |         uint64 blockNumber;
   81 |     |         // The transaction hash.
   82 |     |         bytes32 transactionHash;
   83 |     |         // The transaction index in the block.
   84 |     |         uint64 transactionIndex;
   85 |     |         // The log index.
   86 |     |         uint256 logIndex;
   87 |     |         // Whether the log was removed.
   88 |     |         bool removed;
   89 |     |     }
   90 |     | 
   91 |     |     /// A single entry in a directory listing. Returned by `readDir`.
   92 |     |     struct DirEntry {
   93 |     |         // The error message, if any.
   94 |     |         string errorMessage;
   95 |     |         // The path of the entry.
   96 |     |         string path;
   97 |     |         // The depth of the entry.
   98 |     |         uint64 depth;
   99 |     |         // Whether the entry is a directory.
  100 |     |         bool isDir;
  101 |     |         // Whether the entry is a symlink.
  102 |     |         bool isSymlink;
  103 |     |     }
  104 |     | 
  105 |     |     /// Metadata information about a file.
  106 |     |     /// This structure is returned from the `fsMetadata` function and represents known
  107 |     |     /// metadata about a file such as its permissions, size, modification
  108 |     |     /// times, etc.
  109 |     |     struct FsMetadata {
  110 |     |         // True if this metadata is for a directory.
  111 |     |         bool isDir;
  112 |     |         // True if this metadata is for a symlink.
  113 |     |         bool isSymlink;
  114 |     |         // The size of the file, in bytes, this metadata is for.
  115 |     |         uint256 length;
  116 |     |         // True if this metadata is for a readonly (unwritable) file.
  117 |     |         bool readOnly;
  118 |     |         // The last modification time listed in this metadata.
  119 |     |         uint256 modified;
  120 |     |         // The last access time of this metadata.
  121 |     |         uint256 accessed;
  122 |     |         // The creation time listed in this metadata.
  123 |     |         uint256 created;
  124 |     |     }
  125 |     | 
  126 |     |     /// A wallet with a public and private key.
  127 |     |     struct Wallet {
  128 |     |         // The wallet's address.
  129 |     |         address addr;
  130 |     |         // The wallet's public key `X`.
  131 |     |         uint256 publicKeyX;
  132 |     |         // The wallet's public key `Y`.
  133 |     |         uint256 publicKeyY;
  134 |     |         // The wallet's private key.
  135 |     |         uint256 privateKey;
  136 |     |     }
  137 |     | 
  138 |     |     /// The result of a `tryFfi` call.
  139 |     |     struct FfiResult {
  140 |     |         // The exit code of the call.
  141 |     |         int32 exitCode;
  142 |     |         // The optionally hex-decoded `stdout` data.
  143 |     |         bytes stdout;
  144 |     |         // The `stderr` data.
  145 |     |         bytes stderr;
  146 |     |     }
  147 |     | 
  148 |     |     /// Information on the chain and fork.
  149 |     |     struct ChainInfo {
  150 |     |         // The fork identifier. Set to zero if no fork is active.
  151 |     |         uint256 forkId;
  152 |     |         // The chain ID of the current fork.
  153 |     |         uint256 chainId;
  154 |     |     }
  155 |     | 
  156 |     |     /// The result of a `stopAndReturnStateDiff` call.
  157 |     |     struct AccountAccess {
  158 |     |         // The chain and fork the access occurred.
  159 |     |         ChainInfo chainInfo;
  160 |     |         // The kind of account access that determines what the account is.
  161 |     |         // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.
  162 |     |         // If kind is Create, then the account is the newly created account.
  163 |     |         // If kind is SelfDestruct, then the account is the selfdestruct recipient.
  164 |     |         // If kind is a Resume, then account represents a account context that has resumed.
  165 |     |         AccountAccessKind kind;
  166 |     |         // The account that was accessed.
  167 |     |         // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.
  168 |     |         address account;
  169 |     |         // What accessed the account.
  170 |     |         address accessor;
  171 |     |         // If the account was initialized or empty prior to the access.
  172 |     |         // An account is considered initialized if it has code, a
  173 |     |         // non-zero nonce, or a non-zero balance.
  174 |     |         bool initialized;
  175 |     |         // The previous balance of the accessed account.
  176 |     |         uint256 oldBalance;
  177 |     |         // The potential new balance of the accessed account.
  178 |     |         // That is, all balance changes are recorded here, even if reverts occurred.
  179 |     |         uint256 newBalance;
  180 |     |         // Code of the account deployed by CREATE.
  181 |     |         bytes deployedCode;
  182 |     |         // Value passed along with the account access
  183 |     |         uint256 value;
  184 |     |         // Input data provided to the CREATE or CALL
  185 |     |         bytes data;
  186 |     |         // If this access reverted in either the current or parent context.
  187 |     |         bool reverted;
  188 |     |         // An ordered list of storage accesses made during an account access operation.
  189 |     |         StorageAccess[] storageAccesses;
  190 |     |     }
  191 |     | 
  192 |     |     /// The storage accessed during an `AccountAccess`.
  193 |     |     struct StorageAccess {
  194 |     |         // The account whose storage was accessed.
  195 |     |         address account;
  196 |     |         // The slot that was accessed.
  197 |     |         bytes32 slot;
  198 |     |         // If the access was a write.
  199 |     |         bool isWrite;
  200 |     |         // The previous value of the slot.
  201 |     |         bytes32 previousValue;
  202 |     |         // The new value of the slot.
  203 |     |         bytes32 newValue;
  204 |     |         // If the access was reverted.
  205 |     |         bool reverted;
  206 |     |     }
  207 |     | 
  208 |     |     // ======== Environment ========
  209 |     | 
  210 |     |     /// Gets the environment variable `name` and parses it as `address`.
  211 |     |     /// Reverts if the variable was not found or could not be parsed.
  212 |     |     function envAddress(string calldata name) external view returns (address value);
  213 |     | 
  214 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  215 |     |     /// Reverts if the variable was not found or could not be parsed.
  216 |     |     function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);
  217 |     | 
  218 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  219 |     |     /// Reverts if the variable was not found or could not be parsed.
  220 |     |     function envBool(string calldata name) external view returns (bool value);
  221 |     | 
  222 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  223 |     |     /// Reverts if the variable was not found or could not be parsed.
  224 |     |     function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);
  225 |     | 
  226 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  227 |     |     /// Reverts if the variable was not found or could not be parsed.
  228 |     |     function envBytes32(string calldata name) external view returns (bytes32 value);
  229 |     | 
  230 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  231 |     |     /// Reverts if the variable was not found or could not be parsed.
  232 |     |     function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);
  233 |     | 
  234 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  235 |     |     /// Reverts if the variable was not found or could not be parsed.
  236 |     |     function envBytes(string calldata name) external view returns (bytes memory value);
  237 |     | 
  238 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  239 |     |     /// Reverts if the variable was not found or could not be parsed.
  240 |     |     function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);
  241 |     | 
  242 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  243 |     |     /// Reverts if the variable was not found or could not be parsed.
  244 |     |     function envInt(string calldata name) external view returns (int256 value);
  245 |     | 
  246 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  247 |     |     /// Reverts if the variable was not found or could not be parsed.
  248 |     |     function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);
  249 |     | 
  250 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  251 |     |     /// Reverts if the variable could not be parsed.
  252 |     |     /// Returns `defaultValue` if the variable was not found.
  253 |     |     function envOr(string calldata name, bool defaultValue) external view returns (bool value);
  254 |     | 
  255 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  256 |     |     /// Reverts if the variable could not be parsed.
  257 |     |     /// Returns `defaultValue` if the variable was not found.
  258 |     |     function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);
  259 |     | 
  260 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  261 |     |     /// Reverts if the variable could not be parsed.
  262 |     |     /// Returns `defaultValue` if the variable was not found.
  263 |     |     function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)
  264 |     |         external
  265 |     |         view
  266 |     |         returns (address[] memory value);
  267 |     | 
  268 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  269 |     |     /// Reverts if the variable could not be parsed.
  270 |     |     /// Returns `defaultValue` if the variable was not found.
  271 |     |     function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)
  272 |     |         external
  273 |     |         view
  274 |     |         returns (bytes32[] memory value);
  275 |     | 
  276 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  277 |     |     /// Reverts if the variable could not be parsed.
  278 |     |     /// Returns `defaultValue` if the variable was not found.
  279 |     |     function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)
  280 |     |         external
  281 |     |         view
  282 |     |         returns (string[] memory value);
  283 |     | 
  284 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  285 |     |     /// Reverts if the variable could not be parsed.
  286 |     |     /// Returns `defaultValue` if the variable was not found.
  287 |     |     function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)
  288 |     |         external
  289 |     |         view
  290 |     |         returns (bytes[] memory value);
  291 |     | 
  292 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  293 |     |     /// Reverts if the variable could not be parsed.
  294 |     |     /// Returns `defaultValue` if the variable was not found.
  295 |     |     function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);
  296 |     | 
  297 |     |     /// Gets the environment variable `name` and parses it as `address`.
  298 |     |     /// Reverts if the variable could not be parsed.
  299 |     |     /// Returns `defaultValue` if the variable was not found.
  300 |     |     function envOr(string calldata name, address defaultValue) external view returns (address value);
  301 |     | 
  302 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  303 |     |     /// Reverts if the variable could not be parsed.
  304 |     |     /// Returns `defaultValue` if the variable was not found.
  305 |     |     function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);
  306 |     | 
  307 |     |     /// Gets the environment variable `name` and parses it as `string`.
  308 |     |     /// Reverts if the variable could not be parsed.
  309 |     |     /// Returns `defaultValue` if the variable was not found.
  310 |     |     function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);
  311 |     | 
  312 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  313 |     |     /// Reverts if the variable could not be parsed.
  314 |     |     /// Returns `defaultValue` if the variable was not found.
  315 |     |     function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);
  316 |     | 
  317 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  318 |     |     /// Reverts if the variable could not be parsed.
  319 |     |     /// Returns `defaultValue` if the variable was not found.
  320 |     |     function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)
  321 |     |         external
  322 |     |         view
  323 |     |         returns (bool[] memory value);
  324 |     | 
  325 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  326 |     |     /// Reverts if the variable could not be parsed.
  327 |     |     /// Returns `defaultValue` if the variable was not found.
  328 |     |     function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)
  329 |     |         external
  330 |     |         view
  331 |     |         returns (uint256[] memory value);
  332 |     | 
  333 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  334 |     |     /// Reverts if the variable could not be parsed.
  335 |     |     /// Returns `defaultValue` if the variable was not found.
  336 |     |     function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)
  337 |     |         external
  338 |     |         view
  339 |     |         returns (int256[] memory value);
  340 |     | 
  341 |     |     /// Gets the environment variable `name` and parses it as `string`.
  342 |     |     /// Reverts if the variable was not found or could not be parsed.
  343 |     |     function envString(string calldata name) external view returns (string memory value);
  344 |     | 
  345 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  346 |     |     /// Reverts if the variable was not found or could not be parsed.
  347 |     |     function envString(string calldata name, string calldata delim) external view returns (string[] memory value);
  348 |     | 
  349 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  350 |     |     /// Reverts if the variable was not found or could not be parsed.
  351 |     |     function envUint(string calldata name) external view returns (uint256 value);
  352 |     | 
  353 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  354 |     |     /// Reverts if the variable was not found or could not be parsed.
  355 |     |     function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);
  356 |     | 
  357 |     |     /// Sets environment variables.
  358 |     |     function setEnv(string calldata name, string calldata value) external;
  359 |     | 
  360 |     |     // ======== EVM ========
  361 |     | 
  362 |     |     /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.
  363 |     |     function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
  364 |     | 
  365 |     |     /// Gets the address for a given private key.
  366 |     |     function addr(uint256 privateKey) external pure returns (address keyAddr);
  367 |     | 
  368 |     |     /// Gets all the logs according to specified filter.
  369 |     |     function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)
  370 |     |         external
  371 |     |         returns (EthGetLogs[] memory logs);
  372 |     | 
  373 |     |     /// Gets the current `block.number`.
  374 |     |     /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,
  375 |     |     /// and as a result will get optimized out by the compiler.
  376 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  377 |     |     function getBlockNumber() external view returns (uint256 height);
  378 |     | 
  379 |     |     /// Gets the current `block.timestamp`.
  380 |     |     /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,
  381 |     |     /// and as a result will get optimized out by the compiler.
  382 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  383 |     |     function getBlockTimestamp() external view returns (uint256 timestamp);
  384 |     | 
  385 |     |     /// Gets the map key and parent of a mapping at a given slot, for a given address.
  386 |     |     function getMappingKeyAndParentOf(address target, bytes32 elementSlot)
  387 |     |         external
  388 |     |         returns (bool found, bytes32 key, bytes32 parent);
  389 |     | 
  390 |     |     /// Gets the number of elements in the mapping at the given slot, for a given address.
  391 |     |     function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);
  392 |     | 
  393 |     |     /// Gets the elements at index idx of the mapping at the given slot, for a given address. The
  394 |     |     /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).
  395 |     |     function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);
  396 |     | 
  397 |     |     /// Gets the nonce of an account.
  398 |     |     function getNonce(address account) external view returns (uint64 nonce);
  399 |     | 
  400 |     |     /// Gets all the recorded logs.
  401 |     |     function getRecordedLogs() external returns (Log[] memory logs);
  402 |     | 
  403 |     |     /// Loads a storage slot from an address.
  404 |     |     function load(address target, bytes32 slot) external view returns (bytes32 data);
  405 |     | 
  406 |     |     /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
  407 |     |     function pauseGasMetering() external;
  408 |     | 
  409 |     |     /// Records all storage reads and writes.
  410 |     |     function record() external;
  411 |     | 
  412 |     |     /// Record all the transaction logs.
  413 |     |     function recordLogs() external;
  414 |     | 
  415 |     |     /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
  416 |     |     function resumeGasMetering() external;
  417 |     | 
  418 |     |     /// Performs an Ethereum JSON-RPC request to the current fork URL.
  419 |     |     function rpc(string calldata method, string calldata params) external returns (bytes memory data);
  420 |     | 
  421 |     |     /// Signs `digest` with `privateKey` using the secp256r1 curve.
  422 |     |     function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);
  423 |     | 
  424 |     |     /// Signs `digest` with `privateKey` using the secp256k1 curve.
  425 |     |     function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  426 |     | 
  427 |     |     /// Starts recording all map SSTOREs for later retrieval.
  428 |     |     function startMappingRecording() external;
  429 |     | 
  430 |     |     /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,
  431 |     |     /// along with the context of the calls
  432 |     |     function startStateDiffRecording() external;
  433 |     | 
  434 |     |     /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
  435 |     |     function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);
  436 |     | 
  437 |     |     /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.
  438 |     |     function stopMappingRecording() external;
  439 |     | 
  440 |     |     // ======== Filesystem ========
  441 |     | 
  442 |     |     /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
  443 |     |     /// `path` is relative to the project root.
  444 |     |     function closeFile(string calldata path) external;
  445 |     | 
  446 |     |     /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.
  447 |     |     /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.
  448 |     |     /// Both `from` and `to` are relative to the project root.
  449 |     |     function copyFile(string calldata from, string calldata to) external returns (uint64 copied);
  450 |     | 
  451 |     |     /// Creates a new, empty directory at the provided path.
  452 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  453 |     |     /// - User lacks permissions to modify `path`.
  454 |     |     /// - A parent of the given path doesn't exist and `recursive` is false.
  455 |     |     /// - `path` already exists and `recursive` is false.
  456 |     |     /// `path` is relative to the project root.
  457 |     |     function createDir(string calldata path, bool recursive) external;
  458 |     | 
  459 |     |     /// Returns true if the given path points to an existing entity, else returns false.
  460 |     |     function exists(string calldata path) external returns (bool result);
  461 |     | 
  462 |     |     /// Performs a foreign function call via the terminal.
  463 |     |     function ffi(string[] calldata commandInput) external returns (bytes memory result);
  464 |     | 
  465 |     |     /// Given a path, query the file system to get information about a file, directory, etc.
  466 |     |     function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);
  467 |     | 
  468 |     |     /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file.
  469 |     |     function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);
  470 |     | 
  471 |     |     /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file.
  472 |     |     function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);
  473 |     | 
  474 |     |     /// Returns true if the path exists on disk and is pointing at a directory, else returns false.
  475 |     |     function isDir(string calldata path) external returns (bool result);
  476 |     | 
  477 |     |     /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.
  478 |     |     function isFile(string calldata path) external returns (bool result);
  479 |     | 
  480 |     |     /// Get the path of the current project root.
  481 |     |     function projectRoot() external view returns (string memory path);
  482 |     | 
  483 |     |     /// Reads the directory at the given path recursively, up to `maxDepth`.
  484 |     |     /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.
  485 |     |     /// Follows symbolic links if `followLinks` is true.
  486 |     |     function readDir(string calldata path) external view returns (DirEntry[] memory entries);
  487 |     | 
  488 |     |     /// See `readDir(string)`.
  489 |     |     function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);
  490 |     | 
  491 |     |     /// See `readDir(string)`.
  492 |     |     function readDir(string calldata path, uint64 maxDepth, bool followLinks)
  493 |     |         external
  494 |     |         view
  495 |     |         returns (DirEntry[] memory entries);
  496 |     | 
  497 |     |     /// Reads the entire content of file to string. `path` is relative to the project root.
  498 |     |     function readFile(string calldata path) external view returns (string memory data);
  499 |     | 
  500 |     |     /// Reads the entire content of file as binary. `path` is relative to the project root.
  501 |     |     function readFileBinary(string calldata path) external view returns (bytes memory data);
  502 |     | 
  503 |     |     /// Reads next line of file to string.
  504 |     |     function readLine(string calldata path) external view returns (string memory line);
  505 |     | 
  506 |     |     /// Reads a symbolic link, returning the path that the link points to.
  507 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  508 |     |     /// - `path` is not a symbolic link.
  509 |     |     /// - `path` does not exist.
  510 |     |     function readLink(string calldata linkPath) external view returns (string memory targetPath);
  511 |     | 
  512 |     |     /// Removes a directory at the provided path.
  513 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  514 |     |     /// - `path` doesn't exist.
  515 |     |     /// - `path` isn't a directory.
  516 |     |     /// - User lacks permissions to modify `path`.
  517 |     |     /// - The directory is not empty and `recursive` is false.
  518 |     |     /// `path` is relative to the project root.
  519 |     |     function removeDir(string calldata path, bool recursive) external;
  520 |     | 
  521 |     |     /// Removes a file from the filesystem.
  522 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  523 |     |     /// - `path` points to a directory.
  524 |     |     /// - The file doesn't exist.
  525 |     |     /// - The user lacks permissions to remove the file.
  526 |     |     /// `path` is relative to the project root.
  527 |     |     function removeFile(string calldata path) external;
  528 |     | 
  529 |     |     /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
  530 |     |     function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);
  531 |     | 
  532 |     |     /// Returns the time since unix epoch in milliseconds.
  533 |     |     function unixTime() external returns (uint256 milliseconds);
  534 |     | 
  535 |     |     /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
  536 |     |     /// `path` is relative to the project root.
  537 |     |     function writeFile(string calldata path, string calldata data) external;
  538 |     | 
  539 |     |     /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
  540 |     |     /// `path` is relative to the project root.
  541 |     |     function writeFileBinary(string calldata path, bytes calldata data) external;
  542 |     | 
  543 |     |     /// Writes line to file, creating a file if it does not exist.
  544 |     |     /// `path` is relative to the project root.
  545 |     |     function writeLine(string calldata path, string calldata data) external;
  546 |     | 
  547 |     |     // ======== JSON ========
  548 |     | 
  549 |     |     /// Checks if `key` exists in a JSON object.
  550 |     |     function keyExists(string calldata json, string calldata key) external view returns (bool);
  551 |     | 
  552 |     |     /// Parses a string of JSON data at `key` and coerces it to `address`.
  553 |     |     function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);
  554 |     | 
  555 |     |     /// Parses a string of JSON data at `key` and coerces it to `address[]`.
  556 |     |     function parseJsonAddressArray(string calldata json, string calldata key)
  557 |     |         external
  558 |     |         pure
  559 |     |         returns (address[] memory);
  560 |     | 
  561 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool`.
  562 |     |     function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);
  563 |     | 
  564 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool[]`.
  565 |     |     function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);
  566 |     | 
  567 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes`.
  568 |     |     function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);
  569 |     | 
  570 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32`.
  571 |     |     function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);
  572 |     | 
  573 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
  574 |     |     function parseJsonBytes32Array(string calldata json, string calldata key)
  575 |     |         external
  576 |     |         pure
  577 |     |         returns (bytes32[] memory);
  578 |     | 
  579 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.
  580 |     |     function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);
  581 |     | 
  582 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256`.
  583 |     |     function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);
  584 |     | 
  585 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256[]`.
  586 |     |     function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);
  587 |     | 
  588 |     |     /// Returns an array of all the keys in a JSON object.
  589 |     |     function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);
  590 |     | 
  591 |     |     /// Parses a string of JSON data at `key` and coerces it to `string`.
  592 |     |     function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);
  593 |     | 
  594 |     |     /// Parses a string of JSON data at `key` and coerces it to `string[]`.
  595 |     |     function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);
  596 |     | 
  597 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256`.
  598 |     |     function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);
  599 |     | 
  600 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.
  601 |     |     function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);
  602 |     | 
  603 |     |     /// ABI-encodes a JSON object.
  604 |     |     function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);
  605 |     | 
  606 |     |     /// ABI-encodes a JSON object at `key`.
  607 |     |     function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);
  608 |     | 
  609 |     |     /// See `serializeJson`.
  610 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
  611 |     |         external
  612 |     |         returns (string memory json);
  613 |     | 
  614 |     |     /// See `serializeJson`.
  615 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
  616 |     |         external
  617 |     |         returns (string memory json);
  618 |     | 
  619 |     |     /// See `serializeJson`.
  620 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
  621 |     |         external
  622 |     |         returns (string memory json);
  623 |     | 
  624 |     |     /// See `serializeJson`.
  625 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
  626 |     |         external
  627 |     |         returns (string memory json);
  628 |     | 
  629 |     |     /// See `serializeJson`.
  630 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
  631 |     |         external
  632 |     |         returns (string memory json);
  633 |     | 
  634 |     |     /// See `serializeJson`.
  635 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
  636 |     |         external
  637 |     |         returns (string memory json);
  638 |     | 
  639 |     |     /// See `serializeJson`.
  640 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
  641 |     |         external
  642 |     |         returns (string memory json);
  643 |     | 
  644 |     |     /// See `serializeJson`.
  645 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
  646 |     |         external
  647 |     |         returns (string memory json);
  648 |     | 
  649 |     |     /// See `serializeJson`.
  650 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
  651 |     |         external
  652 |     |         returns (string memory json);
  653 |     | 
  654 |     |     /// See `serializeJson`.
  655 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
  656 |     |         external
  657 |     |         returns (string memory json);
  658 |     | 
  659 |     |     /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.
  660 |     |     /// Returns the stringified version of the specific JSON file up to that moment.
  661 |     |     function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);
  662 |     | 
  663 |     |     /// See `serializeJson`.
  664 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
  665 |     |         external
  666 |     |         returns (string memory json);
  667 |     | 
  668 |     |     /// See `serializeJson`.
  669 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
  670 |     |         external
  671 |     |         returns (string memory json);
  672 |     | 
  673 |     |     /// See `serializeJson`.
  674 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
  675 |     |         external
  676 |     |         returns (string memory json);
  677 |     | 
  678 |     |     /// See `serializeJson`.
  679 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
  680 |     |         external
  681 |     |         returns (string memory json);
  682 |     | 
  683 |     |     /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.
  684 |     |     function writeJson(string calldata json, string calldata path) external;
  685 |     | 
  686 |     |     /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>
  687 |     |     /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
  688 |     |     function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
  689 |     | 
  690 |     |     // ======== Scripting ========
  691 |     | 
  692 |     |     /// Using the address that calls the test contract, has the next call (at this call depth only)
  693 |     |     /// create a transaction that can later be signed and sent onchain.
  694 |     |     function broadcast() external;
  695 |     | 
  696 |     |     /// Has the next call (at this call depth only) create a transaction with the address provided
  697 |     |     /// as the sender that can later be signed and sent onchain.
  698 |     |     function broadcast(address signer) external;
  699 |     | 
  700 |     |     /// Has the next call (at this call depth only) create a transaction with the private key
  701 |     |     /// provided as the sender that can later be signed and sent onchain.
  702 |     |     function broadcast(uint256 privateKey) external;
  703 |     | 
  704 |     |     /// Using the address that calls the test contract, has all subsequent calls
  705 |     |     /// (at this call depth only) create transactions that can later be signed and sent onchain.
  706 |     |     function startBroadcast() external;
  707 |     | 
  708 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the address
  709 |     |     /// provided that can later be signed and sent onchain.
  710 |     |     function startBroadcast(address signer) external;
  711 |     | 
  712 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the private key
  713 |     |     /// provided that can later be signed and sent onchain.
  714 |     |     function startBroadcast(uint256 privateKey) external;
  715 |     | 
  716 |     |     /// Stops collecting onchain transactions.
  717 |     |     function stopBroadcast() external;
  718 |     | 
  719 |     |     // ======== String ========
  720 |     | 
  721 |     |     /// Parses the given `string` into an `address`.
  722 |     |     function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
  723 |     | 
  724 |     |     /// Parses the given `string` into a `bool`.
  725 |     |     function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
  726 |     | 
  727 |     |     /// Parses the given `string` into `bytes`.
  728 |     |     function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
  729 |     | 
  730 |     |     /// Parses the given `string` into a `bytes32`.
  731 |     |     function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
  732 |     | 
  733 |     |     /// Parses the given `string` into a `int256`.
  734 |     |     function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
  735 |     | 
  736 |     |     /// Parses the given `string` into a `uint256`.
  737 |     |     function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
  738 |     | 
  739 |     |     /// Converts the given value to a `string`.
  740 |     |     function toString(address value) external pure returns (string memory stringifiedValue);
  741 |     | 
  742 |     |     /// Converts the given value to a `string`.
  743 |     |     function toString(bytes calldata value) external pure returns (string memory stringifiedValue);
  744 |     | 
  745 |     |     /// Converts the given value to a `string`.
  746 |     |     function toString(bytes32 value) external pure returns (string memory stringifiedValue);
  747 |     | 
  748 |     |     /// Converts the given value to a `string`.
  749 |     |     function toString(bool value) external pure returns (string memory stringifiedValue);
  750 |     | 
  751 |     |     /// Converts the given value to a `string`.
  752 |     |     function toString(uint256 value) external pure returns (string memory stringifiedValue);
  753 |     | 
  754 |     |     /// Converts the given value to a `string`.
  755 |     |     function toString(int256 value) external pure returns (string memory stringifiedValue);
  756 |     | 
  757 |     |     // ======== Testing ========
  758 |     | 
  759 |     |     /// If the condition is false, discard this run's fuzz inputs and generate new ones.
  760 |     |     function assume(bool condition) external pure;
  761 |     | 
  762 |     |     /// Writes a breakpoint to jump to in the debugger.
  763 |     |     function breakpoint(string calldata char) external;
  764 |     | 
  765 |     |     /// Writes a conditional breakpoint to jump to in the debugger.
  766 |     |     function breakpoint(string calldata char, bool value) external;
  767 |     | 
  768 |     |     /// Returns the RPC url for the given alias.
  769 |     |     function rpcUrl(string calldata rpcAlias) external view returns (string memory json);
  770 |     | 
  771 |     |     /// Returns all rpc urls and their aliases as structs.
  772 |     |     function rpcUrlStructs() external view returns (Rpc[] memory urls);
  773 |     | 
  774 |     |     /// Returns all rpc urls and their aliases `[alias, url][]`.
  775 |     |     function rpcUrls() external view returns (string[2][] memory urls);
  776 |     | 
  777 |     |     /// Suspends execution of the main thread for `duration` milliseconds.
  778 |     |     function sleep(uint256 duration) external;
  779 |     | 
  780 |     |     // ======== Utilities ========
  781 |     | 
  782 |     |     /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
  783 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)
  784 |     |         external
  785 |     |         pure
  786 |     |         returns (address);
  787 |     | 
  788 |     |     /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
  789 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);
  790 |     | 
  791 |     |     /// Compute the address a contract will be deployed at for a given deployer address and nonce.
  792 |     |     function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);
  793 |     | 
  794 |     |     /// Derives a private key from the name, labels the account with that name, and returns the wallet.
  795 |     |     function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);
  796 |     | 
  797 |     |     /// Generates a wallet from the private key and returns the wallet.
  798 |     |     function createWallet(uint256 privateKey) external returns (Wallet memory wallet);
  799 |     | 
  800 |     |     /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.
  801 |     |     function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);
  802 |     | 
  803 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
  804 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
  805 |     |     function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);
  806 |     | 
  807 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
  808 |     |     /// at `{derivationPath}{index}`.
  809 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)
  810 |     |         external
  811 |     |         pure
  812 |     |         returns (uint256 privateKey);
  813 |     | 
  814 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
  815 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
  816 |     |     function deriveKey(string calldata mnemonic, uint32 index, string calldata language)
  817 |     |         external
  818 |     |         pure
  819 |     |         returns (uint256 privateKey);
  820 |     | 
  821 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
  822 |     |     /// at `{derivationPath}{index}`.
  823 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)
  824 |     |         external
  825 |     |         pure
  826 |     |         returns (uint256 privateKey);
  827 |     | 
  828 |     |     /// Gets the label for the specified address.
  829 |     |     function getLabel(address account) external view returns (string memory currentLabel);
  830 |     | 
  831 |     |     /// Get a `Wallet`'s nonce.
  832 |     |     function getNonce(Wallet calldata wallet) external returns (uint64 nonce);
  833 |     | 
  834 |     |     /// Labels an address in call traces.
  835 |     |     function label(address account, string calldata newLabel) external;
  836 |     | 
  837 |     |     /// Adds a private key to the local forge wallet and returns the address.
  838 |     |     function rememberKey(uint256 privateKey) external returns (address keyAddr);
  839 |     | 
  840 |     |     /// Signs data with a `Wallet`.
  841 |     |     function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
  842 |     | 
  843 |     |     /// Encodes a `bytes` value to a base64url string.
  844 |     |     function toBase64URL(bytes calldata data) external pure returns (string memory);
  845 |     | 
  846 |     |     /// Encodes a `string` value to a base64url string.
  847 |     |     function toBase64URL(string calldata data) external pure returns (string memory);
  848 |     | 
  849 |     |     /// Encodes a `bytes` value to a base64 string.
  850 |     |     function toBase64(bytes calldata data) external pure returns (string memory);
  851 |     | 
  852 |     |     /// Encodes a `string` value to a base64 string.
  853 |     |     function toBase64(string calldata data) external pure returns (string memory);
  854 |     | }
  855 |     | 
  856 |     | /// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used
  857 |     | /// in tests, but it is not recommended to use these cheats in scripts.
  858 |     | interface Vm is VmSafe {
  859 |     |     // ======== EVM ========
  860 |     | 
  861 |     |     /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.
  862 |     |     function activeFork() external view returns (uint256 forkId);
  863 |     | 
  864 |     |     /// In forking mode, explicitly grant the given address cheatcode access.
  865 |     |     function allowCheatcodes(address account) external;
  866 |     | 
  867 |     |     /// Sets `block.chainid`.
  868 |     |     function chainId(uint256 newChainId) external;
  869 |     | 
  870 |     |     /// Clears all mocked calls.
  871 |     |     function clearMockedCalls() external;
  872 |     | 
  873 |     |     /// Sets `block.coinbase`.
  874 |     |     function coinbase(address newCoinbase) external;
  875 |     | 
  876 |     |     /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
  877 |     |     function createFork(string calldata urlOrAlias) external returns (uint256 forkId);
  878 |     | 
  879 |     |     /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.
  880 |     |     function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
  881 |     | 
  882 |     |     /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,
  883 |     |     /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
  884 |     |     function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
  885 |     | 
  886 |     |     /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
  887 |     |     function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);
  888 |     | 
  889 |     |     /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
  890 |     |     function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
  891 |     | 
  892 |     |     /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,
  893 |     |     /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.
  894 |     |     function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
  895 |     | 
  896 |     |     /// Sets an address' balance.
  897 |     |     function deal(address account, uint256 newBalance) external;
  898 |     | 
  899 |     |     /// Removes the snapshot with the given ID created by `snapshot`.
  900 |     |     /// Takes the snapshot ID to delete.
  901 |     |     /// Returns `true` if the snapshot was successfully deleted.
  902 |     |     /// Returns `false` if the snapshot does not exist.
  903 |     |     function deleteSnapshot(uint256 snapshotId) external returns (bool success);
  904 |     | 
  905 |     |     /// Removes _all_ snapshots previously created by `snapshot`.
  906 |     |     function deleteSnapshots() external;
  907 |     | 
  908 |     |     /// Sets `block.difficulty`.
  909 |     |     /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.
  910 |     |     /// Reverts if used on unsupported EVM versions.
  911 |     |     function difficulty(uint256 newDifficulty) external;
  912 |     | 
  913 |     |     /// Dump a genesis JSON file's `allocs` to disk.
  914 |     |     function dumpState(string calldata pathToStateJson) external;
  915 |     | 
  916 |     |     /// Sets an address' code.
  917 |     |     function etch(address target, bytes calldata newRuntimeBytecode) external;
  918 |     | 
  919 |     |     /// Sets `block.basefee`.
  920 |     |     function fee(uint256 newBasefee) external;
  921 |     | 
  922 |     |     /// Returns true if the account is marked as persistent.
  923 |     |     function isPersistent(address account) external view returns (bool persistent);
  924 |     | 
  925 |     |     /// Load a genesis JSON file's `allocs` into the in-memory revm state.
  926 |     |     function loadAllocs(string calldata pathToAllocsJson) external;
  927 |     | 
  928 |     |     /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
  929 |     |     /// Meaning, changes made to the state of this account will be kept when switching forks.
  930 |     |     function makePersistent(address account) external;
  931 |     | 
  932 |     |     /// See `makePersistent(address)`.
  933 |     |     function makePersistent(address account0, address account1) external;
  934 |     | 
  935 |     |     /// See `makePersistent(address)`.
  936 |     |     function makePersistent(address account0, address account1, address account2) external;
  937 |     | 
  938 |     |     /// See `makePersistent(address)`.
  939 |     |     function makePersistent(address[] calldata accounts) external;
  940 |     | 
  941 |     |     /// Reverts a call to an address with specified revert data.
  942 |     |     function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;
  943 |     | 
  944 |     |     /// Reverts a call to an address with a specific `msg.value`, with specified revert data.
  945 |     |     function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)
  946 |     |         external;
  947 |     | 
  948 |     |     /// Mocks a call to an address, returning specified data.
  949 |     |     /// Calldata can either be strict or a partial match, e.g. if you only
  950 |     |     /// pass a Solidity selector to the expected calldata, then the entire Solidity
  951 |     |     /// function will be mocked.
  952 |     |     function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;
  953 |     | 
  954 |     |     /// Mocks a call to an address with a specific `msg.value`, returning specified data.
  955 |     |     /// Calldata match takes precedence over `msg.value` in case of ambiguity.
  956 |     |     function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;
  957 |     | 
  958 |     |     /// Sets the *next* call's `msg.sender` to be the input address.
  959 |     |     function prank(address msgSender) external;
  960 |     | 
  961 |     |     /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
  962 |     |     function prank(address msgSender, address txOrigin) external;
  963 |     | 
  964 |     |     /// Sets `block.prevrandao`.
  965 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
  966 |     |     /// If used on unsupported EVM versions it will revert.
  967 |     |     function prevrandao(bytes32 newPrevrandao) external;
  968 |     | 
  969 |     |     /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
  970 |     |     function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);
  971 |     | 
  972 |     |     /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
  973 |     |     function resetNonce(address account) external;
  974 |     | 
  975 |     |     /// Revert the state of the EVM to a previous snapshot
  976 |     |     /// Takes the snapshot ID to revert to.
  977 |     |     /// Returns `true` if the snapshot was successfully reverted.
  978 |     |     /// Returns `false` if the snapshot does not exist.
  979 |     |     /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.
  980 |     |     function revertTo(uint256 snapshotId) external returns (bool success);
  981 |     | 
  982 |     |     /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots
  983 |     |     /// Takes the snapshot ID to revert to.
  984 |     |     /// Returns `true` if the snapshot was successfully reverted and deleted.
  985 |     |     /// Returns `false` if the snapshot does not exist.
  986 |     |     function revertToAndDelete(uint256 snapshotId) external returns (bool success);
  987 |     | 
  988 |     |     /// Revokes persistent status from the address, previously added via `makePersistent`.
  989 |     |     function revokePersistent(address account) external;
  990 |     | 
  991 |     |     /// See `revokePersistent(address)`.
  992 |     |     function revokePersistent(address[] calldata accounts) external;
  993 |     | 
  994 |     |     /// Sets `block.height`.
  995 |     |     function roll(uint256 newHeight) external;
  996 |     | 
  997 |     |     /// Updates the currently active fork to given block number
  998 |     |     /// This is similar to `roll` but for the currently active fork.
  999 |     |     function rollFork(uint256 blockNumber) external;
 1000 |     | 
 1001 |     |     /// Updates the currently active fork to given transaction. This will `rollFork` with the number
 1002 |     |     /// of the block the transaction was mined in and replays all transaction mined before it in the block.
 1003 |     |     function rollFork(bytes32 txHash) external;
 1004 |     | 
 1005 |     |     /// Updates the given fork to given block number.
 1006 |     |     function rollFork(uint256 forkId, uint256 blockNumber) external;
 1007 |     | 
 1008 |     |     /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
 1009 |     |     function rollFork(uint256 forkId, bytes32 txHash) external;
 1010 |     | 
 1011 |     |     /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
 1012 |     |     function selectFork(uint256 forkId) external;
 1013 |     | 
 1014 |     |     /// Sets the nonce of an account. Must be higher than the current nonce of the account.
 1015 |     |     function setNonce(address account, uint64 newNonce) external;
 1016 |     | 
 1017 |     |     /// Sets the nonce of an account to an arbitrary value.
 1018 |     |     function setNonceUnsafe(address account, uint64 newNonce) external;
 1019 |     | 
 1020 |     |     /// Snapshot the current state of the evm.
 1021 |     |     /// Returns the ID of the snapshot that was created.
 1022 |     |     /// To revert a snapshot use `revertTo`.
 1023 |     |     function snapshot() external returns (uint256 snapshotId);
 1024 |     | 
 1025 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
 1026 |     |     function startPrank(address msgSender) external;
 1027 |     | 
 1028 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
 1029 |     |     function startPrank(address msgSender, address txOrigin) external;
 1030 |     | 
 1031 |     |     /// Resets subsequent calls' `msg.sender` to be `address(this)`.
 1032 |     |     function stopPrank() external;
 1033 |     | 
 1034 |     |     /// Stores a value to an address' storage slot.
 1035 |     |     function store(address target, bytes32 slot, bytes32 value) external;
 1036 |     | 
 1037 |     |     /// Fetches the given transaction from the active fork and executes it on the current state.
 1038 |     |     function transact(bytes32 txHash) external;
 1039 |     | 
 1040 |     |     /// Fetches the given transaction from the given fork and executes it on the current state.
 1041 |     |     function transact(uint256 forkId, bytes32 txHash) external;
 1042 |     | 
 1043 |     |     /// Sets `tx.gasprice`.
 1044 |     |     function txGasPrice(uint256 newGasPrice) external;
 1045 |     | 
 1046 |     |     /// Sets `block.timestamp`.
 1047 |     |     function warp(uint256 newTimestamp) external;
 1048 |     | 
 1049 |     |     // ======== Testing ========
 1050 |     | 
 1051 |     |     /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 1052 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;
 1053 |     | 
 1054 |     |     /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 1055 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)
 1056 |     |         external;
 1057 |     | 
 1058 |     |     /// Expects a call to an address with the specified calldata.
 1059 |     |     /// Calldata can either be a strict or a partial match.
 1060 |     |     function expectCall(address callee, bytes calldata data) external;
 1061 |     | 
 1062 |     |     /// Expects given number of calls to an address with the specified calldata.
 1063 |     |     function expectCall(address callee, bytes calldata data, uint64 count) external;
 1064 |     | 
 1065 |     |     /// Expects a call to an address with the specified `msg.value` and calldata.
 1066 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data) external;
 1067 |     | 
 1068 |     |     /// Expects given number of calls to an address with the specified `msg.value` and calldata.
 1069 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;
 1070 |     | 
 1071 |     |     /// Expect a call to an address with the specified `msg.value`, gas, and calldata.
 1072 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;
 1073 |     | 
 1074 |     |     /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
 1075 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;
 1076 |     | 
 1077 |     |     /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).
 1078 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 1079 |     |     /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
 1080 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;
 1081 |     | 
 1082 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 1083 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)
 1084 |     |         external;
 1085 |     | 
 1086 |     |     /// Prepare an expected log with all topic and data checks enabled.
 1087 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 1088 |     |     /// logs were emitted in the expected order with the expected topics and data.
 1089 |     |     function expectEmit() external;
 1090 |     | 
 1091 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 1092 |     |     function expectEmit(address emitter) external;
 1093 |     | 
 1094 |     |     /// Expects an error on next call with any revert data.
 1095 |     |     function expectRevert() external;
 1096 |     | 
 1097 |     |     /// Expects an error on next call that starts with the revert data.
 1098 |     |     function expectRevert(bytes4 revertData) external;
 1099 |     | 
 1100 |     |     /// Expects an error on next call that exactly matches the revert data.
 1101 |     |     function expectRevert(bytes calldata revertData) external;
 1102 |     | 
 1103 |     |     /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other
 1104 |     |     /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
 1105 |     |     function expectSafeMemory(uint64 min, uint64 max) external;
 1106 |     | 
 1107 |     |     /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.
 1108 |     |     /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges
 1109 |     |     /// to the set.
 1110 |     |     function expectSafeMemoryCall(uint64 min, uint64 max) external;
 1111 |     | 
 1112 |     |     /// Marks a test as skipped. Must be called at the top of the test.
 1113 |     |     function skip(bool skipTest) external;
 1114 |     | 
 1115 |     |     /// Stops all safe memory expectation in the current subcontext.
 1116 |     |     function stopExpectSafeMemory() external;
 1117 |     | }
 1118 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    6 |     | 
    7 |     |     function _sendLogPayload(bytes memory payload) private view {
    8 |     |         uint256 payloadLength = payload.length;
    9 |     |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 |     |         assembly {
   12 |     |             let payloadStart := add(payload, 32)
   13 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   14 |     |         }
   15 |     |     }
   16 |     | 
   17 |     |     function log() internal view {
   18 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   19 |     |     }
   20 |     | 
   21 |     |     function logInt(int p0) internal view {
   22 |     |         _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
   23 |     |     }
   24 |     | 
   25 |     |     function logUint(uint p0) internal view {
   26 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
   27 |     |     }
   28 |     | 
   29 |     |     function logString(string memory p0) internal view {
   30 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   31 |     |     }
   32 |     | 
   33 |     |     function logBool(bool p0) internal view {
   34 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   35 |     |     }
   36 |     | 
   37 |     |     function logAddress(address p0) internal view {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   39 |     |     }
   40 |     | 
   41 |     |     function logBytes(bytes memory p0) internal view {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logBytes1(bytes1 p0) internal view {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logBytes2(bytes2 p0) internal view {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBytes3(bytes3 p0) internal view {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logBytes4(bytes4 p0) internal view {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes5(bytes5 p0) internal view {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes6(bytes6 p0) internal view {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes7(bytes7 p0) internal view {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes8(bytes8 p0) internal view {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes9(bytes9 p0) internal view {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes10(bytes10 p0) internal view {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes11(bytes11 p0) internal view {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes12(bytes12 p0) internal view {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes13(bytes13 p0) internal view {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes14(bytes14 p0) internal view {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes15(bytes15 p0) internal view {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes16(bytes16 p0) internal view {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes17(bytes17 p0) internal view {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes18(bytes18 p0) internal view {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes19(bytes19 p0) internal view {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes20(bytes20 p0) internal view {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes21(bytes21 p0) internal view {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes22(bytes22 p0) internal view {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes23(bytes23 p0) internal view {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes24(bytes24 p0) internal view {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes25(bytes25 p0) internal view {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes26(bytes26 p0) internal view {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes27(bytes27 p0) internal view {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes28(bytes28 p0) internal view {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes29(bytes29 p0) internal view {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes30(bytes30 p0) internal view {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes31(bytes31 p0) internal view {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes32(bytes32 p0) internal view {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function log(uint p0) internal view {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
  175 |     |     }
  176 |     | 
  177 |     |     function log(string memory p0) internal view {
  178 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  179 |     |     }
  180 |     | 
  181 |     |     function log(bool p0) internal view {
  182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function log(address p0) internal view {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  187 |     |     }
  188 |     | 
  189 |     |     function log(uint p0, uint p1) internal view {
  190 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
  191 |     |     }
  192 |     | 
  193 |     |     function log(uint p0, string memory p1) internal view {
  194 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
  195 |     |     }
  196 |     | 
  197 |     |     function log(uint p0, bool p1) internal view {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
  199 |     |     }
  200 |     | 
  201 |     |     function log(uint p0, address p1) internal view {
  202 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
  203 |     |     }
  204 |     | 
  205 |     |     function log(string memory p0, uint p1) internal view {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
  207 |     |     }
  208 |     | 
  209 |     |     function log(string memory p0, string memory p1) internal view {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  211 |     |     }
  212 |     | 
  213 |     |     function log(string memory p0, bool p1) internal view {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(string memory p0, address p1) internal view {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  219 |     |     }
  220 |     | 
  221 |     |     function log(bool p0, uint p1) internal view {
  222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
  223 |     |     }
  224 |     | 
  225 |     |     function log(bool p0, string memory p1) internal view {
  226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  227 |     |     }
  228 |     | 
  229 |     |     function log(bool p0, bool p1) internal view {
  230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  231 |     |     }
  232 |     | 
  233 |     |     function log(bool p0, address p1) internal view {
  234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  235 |     |     }
  236 |     | 
  237 |     |     function log(address p0, uint p1) internal view {
  238 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(address p0, string memory p1) internal view {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  243 |     |     }
  244 |     | 
  245 |     |     function log(address p0, bool p1) internal view {
  246 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(address p0, address p1) internal view {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(uint p0, uint p1, uint p2) internal view {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
  255 |     |     }
  256 |     | 
  257 |     |     function log(uint p0, uint p1, string memory p2) internal view {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
  259 |     |     }
  260 |     | 
  261 |     |     function log(uint p0, uint p1, bool p2) internal view {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
  263 |     |     }
  264 |     | 
  265 |     |     function log(uint p0, uint p1, address p2) internal view {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
  267 |     |     }
  268 |     | 
  269 |     |     function log(uint p0, string memory p1, uint p2) internal view {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
  271 |     |     }
  272 |     | 
  273 |     |     function log(uint p0, string memory p1, string memory p2) internal view {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
  275 |     |     }
  276 |     | 
  277 |     |     function log(uint p0, string memory p1, bool p2) internal view {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint p0, string memory p1, address p2) internal view {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint p0, bool p1, uint p2) internal view {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint p0, bool p1, string memory p2) internal view {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint p0, bool p1, bool p2) internal view {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint p0, bool p1, address p2) internal view {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint p0, address p1, uint p2) internal view {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint p0, address p1, string memory p2) internal view {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint p0, address p1, bool p2) internal view {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint p0, address p1, address p2) internal view {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(string memory p0, uint p1, uint p2) internal view {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(string memory p0, uint p1, string memory p2) internal view {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(string memory p0, uint p1, bool p2) internal view {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(string memory p0, uint p1, address p2) internal view {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(string memory p0, string memory p1, uint p2) internal view {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(string memory p0, string memory p1, string memory p2) internal view {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(string memory p0, string memory p1, bool p2) internal view {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, string memory p1, address p2) internal view {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, bool p1, uint p2) internal view {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, bool p1, string memory p2) internal view {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, bool p1, bool p2) internal view {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, bool p1, address p2) internal view {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, address p1, uint p2) internal view {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, address p1, string memory p2) internal view {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, address p1, bool p2) internal view {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, address p1, address p2) internal view {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(bool p0, uint p1, uint p2) internal view {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(bool p0, uint p1, string memory p2) internal view {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(bool p0, uint p1, bool p2) internal view {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(bool p0, uint p1, address p2) internal view {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(bool p0, string memory p1, uint p2) internal view {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(bool p0, string memory p1, string memory p2) internal view {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(bool p0, string memory p1, bool p2) internal view {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, string memory p1, address p2) internal view {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, bool p1, uint p2) internal view {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, bool p1, string memory p2) internal view {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, bool p1, bool p2) internal view {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, bool p1, address p2) internal view {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, address p1, uint p2) internal view {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, address p1, string memory p2) internal view {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, address p1, bool p2) internal view {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, address p1, address p2) internal view {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(address p0, uint p1, uint p2) internal view {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(address p0, uint p1, string memory p2) internal view {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(address p0, uint p1, bool p2) internal view {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(address p0, uint p1, address p2) internal view {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(address p0, string memory p1, uint p2) internal view {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(address p0, string memory p1, string memory p2) internal view {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(address p0, string memory p1, bool p2) internal view {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, string memory p1, address p2) internal view {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, bool p1, uint p2) internal view {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, bool p1, string memory p2) internal view {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, bool p1, bool p2) internal view {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, bool p1, address p2) internal view {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, address p1, uint p2) internal view {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, address p1, string memory p2) internal view {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, address p1, bool p2) internal view {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, address p1, address p2) internal view {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(uint p0, uint p1, uint p2, uint p3) internal view {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
  511 |     |     }
  512 |     | 
  513 |     |     function log(uint p0, uint p1, uint p2, string memory p3) internal view {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
  515 |     |     }
  516 |     | 
  517 |     |     function log(uint p0, uint p1, uint p2, bool p3) internal view {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
  519 |     |     }
  520 |     | 
  521 |     |     function log(uint p0, uint p1, uint p2, address p3) internal view {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
  523 |     |     }
  524 |     | 
  525 |     |     function log(uint p0, uint p1, string memory p2, uint p3) internal view {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
  527 |     |     }
  528 |     | 
  529 |     |     function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
  531 |     |     }
  532 |     | 
  533 |     |     function log(uint p0, uint p1, string memory p2, bool p3) internal view {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint p0, uint p1, string memory p2, address p3) internal view {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint p0, uint p1, bool p2, uint p3) internal view {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint p0, uint p1, bool p2, string memory p3) internal view {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint p0, uint p1, bool p2, bool p3) internal view {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint p0, uint p1, bool p2, address p3) internal view {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint p0, uint p1, address p2, uint p3) internal view {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint p0, uint p1, address p2, string memory p3) internal view {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint p0, uint p1, address p2, bool p3) internal view {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint p0, uint p1, address p2, address p3) internal view {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint p0, string memory p1, uint p2, uint p3) internal view {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint p0, string memory p1, uint p2, bool p3) internal view {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint p0, string memory p1, uint p2, address p3) internal view {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint p0, string memory p1, string memory p2, address p3) internal view {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint p0, string memory p1, bool p2, uint p3) internal view {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint p0, string memory p1, bool p2, bool p3) internal view {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint p0, string memory p1, bool p2, address p3) internal view {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint p0, string memory p1, address p2, uint p3) internal view {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint p0, string memory p1, address p2, string memory p3) internal view {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint p0, string memory p1, address p2, bool p3) internal view {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint p0, string memory p1, address p2, address p3) internal view {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint p0, bool p1, uint p2, uint p3) internal view {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint p0, bool p1, uint p2, string memory p3) internal view {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint p0, bool p1, uint p2, bool p3) internal view {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint p0, bool p1, uint p2, address p3) internal view {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint p0, bool p1, string memory p2, uint p3) internal view {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint p0, bool p1, string memory p2, bool p3) internal view {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint p0, bool p1, string memory p2, address p3) internal view {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint p0, bool p1, bool p2, uint p3) internal view {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint p0, bool p1, bool p2, string memory p3) internal view {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint p0, bool p1, bool p2, bool p3) internal view {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint p0, bool p1, bool p2, address p3) internal view {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint p0, bool p1, address p2, uint p3) internal view {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint p0, bool p1, address p2, string memory p3) internal view {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint p0, bool p1, address p2, bool p3) internal view {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint p0, bool p1, address p2, address p3) internal view {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint p0, address p1, uint p2, uint p3) internal view {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint p0, address p1, uint p2, string memory p3) internal view {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint p0, address p1, uint p2, bool p3) internal view {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint p0, address p1, uint p2, address p3) internal view {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint p0, address p1, string memory p2, uint p3) internal view {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint p0, address p1, string memory p2, string memory p3) internal view {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint p0, address p1, string memory p2, bool p3) internal view {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint p0, address p1, string memory p2, address p3) internal view {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint p0, address p1, bool p2, uint p3) internal view {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint p0, address p1, bool p2, string memory p3) internal view {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint p0, address p1, bool p2, bool p3) internal view {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint p0, address p1, bool p2, address p3) internal view {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint p0, address p1, address p2, uint p3) internal view {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint p0, address p1, address p2, string memory p3) internal view {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint p0, address p1, address p2, bool p3) internal view {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint p0, address p1, address p2, address p3) internal view {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(string memory p0, uint p1, uint p2, uint p3) internal view {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(string memory p0, uint p1, uint p2, bool p3) internal view {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(string memory p0, uint p1, uint p2, address p3) internal view {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint p1, string memory p2, address p3) internal view {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint p1, bool p2, uint p3) internal view {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint p1, bool p2, bool p3) internal view {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint p1, bool p2, address p3) internal view {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint p1, address p2, uint p3) internal view {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint p1, address p2, string memory p3) internal view {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint p1, address p2, bool p3) internal view {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint p1, address p2, address p3) internal view {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, string memory p1, uint p2, address p3) internal view {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, address p2, uint p3) internal view {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, bool p1, uint p2, uint p3) internal view {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, bool p1, uint p2, bool p3) internal view {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, bool p1, uint p2, address p3) internal view {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, bool p2, uint p3) internal view {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, address p2, uint p3) internal view {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, address p2, address p3) internal view {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, address p1, uint p2, uint p3) internal view {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, address p1, uint p2, string memory p3) internal view {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, address p1, uint p2, bool p3) internal view {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, address p1, uint p2, address p3) internal view {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, address p1, string memory p2, uint p3) internal view {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, bool p2, uint p3) internal view {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, bool p2, address p3) internal view {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, address p2, uint p3) internal view {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, address p2, bool p3) internal view {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, address p2, address p3) internal view {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(bool p0, uint p1, uint p2, uint p3) internal view {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(bool p0, uint p1, uint p2, string memory p3) internal view {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(bool p0, uint p1, uint p2, bool p3) internal view {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(bool p0, uint p1, uint p2, address p3) internal view {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(bool p0, uint p1, string memory p2, uint p3) internal view {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(bool p0, uint p1, string memory p2, bool p3) internal view {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint p1, string memory p2, address p3) internal view {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint p1, bool p2, uint p3) internal view {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint p1, bool p2, string memory p3) internal view {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint p1, bool p2, bool p3) internal view {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint p1, bool p2, address p3) internal view {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint p1, address p2, uint p3) internal view {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint p1, address p2, string memory p3) internal view {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint p1, address p2, bool p3) internal view {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint p1, address p2, address p3) internal view {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, string memory p1, uint p2, uint p3) internal view {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, string memory p1, uint p2, bool p3) internal view {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, string memory p1, uint p2, address p3) internal view {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, bool p2, uint p3) internal view {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, address p2, uint p3) internal view {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, address p2, address p3) internal view {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, bool p1, uint p2, uint p3) internal view {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, bool p1, uint p2, string memory p3) internal view {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, bool p1, uint p2, bool p3) internal view {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, bool p1, uint p2, address p3) internal view {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, bool p1, string memory p2, uint p3) internal view {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, bool p2, uint p3) internal view {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, bool p2, address p3) internal view {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, address p2, uint p3) internal view {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, address p2, bool p3) internal view {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, address p2, address p3) internal view {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, address p1, uint p2, uint p3) internal view {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, address p1, uint p2, string memory p3) internal view {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, address p1, uint p2, bool p3) internal view {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, address p1, uint p2, address p3) internal view {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, address p1, string memory p2, uint p3) internal view {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, string memory p2, address p3) internal view {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, bool p2, uint p3) internal view {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, bool p2, bool p3) internal view {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, bool p2, address p3) internal view {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, address p2, uint p3) internal view {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, address p2, string memory p3) internal view {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, address p2, bool p3) internal view {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, address p2, address p3) internal view {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(address p0, uint p1, uint p2, uint p3) internal view {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(address p0, uint p1, uint p2, string memory p3) internal view {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(address p0, uint p1, uint p2, bool p3) internal view {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(address p0, uint p1, uint p2, address p3) internal view {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(address p0, uint p1, string memory p2, uint p3) internal view {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(address p0, uint p1, string memory p2, string memory p3) internal view {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(address p0, uint p1, string memory p2, bool p3) internal view {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint p1, string memory p2, address p3) internal view {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint p1, bool p2, uint p3) internal view {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint p1, bool p2, string memory p3) internal view {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint p1, bool p2, bool p3) internal view {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint p1, bool p2, address p3) internal view {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint p1, address p2, uint p3) internal view {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint p1, address p2, string memory p3) internal view {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint p1, address p2, bool p3) internal view {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint p1, address p2, address p3) internal view {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, string memory p1, uint p2, uint p3) internal view {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, string memory p1, uint p2, string memory p3) internal view {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, string memory p1, uint p2, bool p3) internal view {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, string memory p1, uint p2, address p3) internal view {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, string memory p1, string memory p2, uint p3) internal view {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, bool p2, uint p3) internal view {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, bool p2, address p3) internal view {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, address p2, uint p3) internal view {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, address p2, bool p3) internal view {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, address p2, address p3) internal view {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, bool p1, uint p2, uint p3) internal view {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, bool p1, uint p2, string memory p3) internal view {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, bool p1, uint p2, bool p3) internal view {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, bool p1, uint p2, address p3) internal view {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, bool p1, string memory p2, uint p3) internal view {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, string memory p2, address p3) internal view {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, bool p2, uint p3) internal view {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, bool p2, bool p3) internal view {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, bool p2, address p3) internal view {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, address p2, uint p3) internal view {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, address p2, string memory p3) internal view {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, address p2, bool p3) internal view {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, address p2, address p3) internal view {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, address p1, uint p2, uint p3) internal view {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, address p1, uint p2, string memory p3) internal view {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, address p1, uint p2, bool p3) internal view {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, address p1, uint p2, address p3) internal view {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, address p1, string memory p2, uint p3) internal view {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, address p1, string memory p2, bool p3) internal view {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, string memory p2, address p3) internal view {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, bool p2, uint p3) internal view {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, bool p2, string memory p3) internal view {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, bool p2, bool p3) internal view {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, bool p2, address p3) internal view {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, address p2, uint p3) internal view {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, address p2, string memory p3) internal view {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, address p2, bool p3) internal view {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, address p2, address p3) internal view {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/console2.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | /// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should
    5 |     | /// use `int256` and `uint256`. This modified version fixes that. This version is recommended
    6 |     | /// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in
    7 |     | /// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.
    8 |     | /// Reference: https://github.com/NomicFoundation/hardhat/issues/2178
    9 |     | library console2 {
   10 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
   11 |     | 
   12 |     |     function _castLogPayloadViewToPure(
   13 |     |         function(bytes memory) internal view fnIn
   14 |     |     ) internal pure returns (function(bytes memory) internal pure fnOut) {
   15 |     |         assembly {
   16 |     |             fnOut := fnIn
   17 |     |         }
   18 |     |     }
   19 |     | 
   20 |     |     function _sendLogPayload(bytes memory payload) internal pure {
   21 |     |         _castLogPayloadViewToPure(_sendLogPayloadView)(payload);
   22 |     |     }
   23 |     | 
   24 |     |     function _sendLogPayloadView(bytes memory payload) private view {
   25 |     |         uint256 payloadLength = payload.length;
   26 |     |         address consoleAddress = CONSOLE_ADDRESS;
   27 |     |         /// @solidity memory-safe-assembly
   28 |     |         assembly {
   29 |     |             let payloadStart := add(payload, 32)
   30 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   31 |     |         }
   32 |     |     }
   33 |     | 
   34 |     |     function log() internal pure {
   35 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   36 |     |     }
   37 |     | 
   38 |     |     function logInt(int256 p0) internal pure {
   39 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   40 |     |     }
   41 |     | 
   42 |     |     function logUint(uint256 p0) internal pure {
   43 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   44 |     |     }
   45 |     | 
   46 |     |     function logString(string memory p0) internal pure {
   47 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   48 |     |     }
   49 |     | 
   50 |     |     function logBool(bool p0) internal pure {
   51 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   52 |     |     }
   53 |     | 
   54 |     |     function logAddress(address p0) internal pure {
   55 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   56 |     |     }
   57 |     | 
   58 |     |     function logBytes(bytes memory p0) internal pure {
   59 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   60 |     |     }
   61 |     | 
   62 |     |     function logBytes1(bytes1 p0) internal pure {
   63 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   64 |     |     }
   65 |     | 
   66 |     |     function logBytes2(bytes2 p0) internal pure {
   67 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   68 |     |     }
   69 |     | 
   70 |     |     function logBytes3(bytes3 p0) internal pure {
   71 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   72 |     |     }
   73 |     | 
   74 |     |     function logBytes4(bytes4 p0) internal pure {
   75 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   76 |     |     }
   77 |     | 
   78 |     |     function logBytes5(bytes5 p0) internal pure {
   79 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   80 |     |     }
   81 |     | 
   82 |     |     function logBytes6(bytes6 p0) internal pure {
   83 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   84 |     |     }
   85 |     | 
   86 |     |     function logBytes7(bytes7 p0) internal pure {
   87 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   88 |     |     }
   89 |     | 
   90 |     |     function logBytes8(bytes8 p0) internal pure {
   91 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   92 |     |     }
   93 |     | 
   94 |     |     function logBytes9(bytes9 p0) internal pure {
   95 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   96 |     |     }
   97 |     | 
   98 |     |     function logBytes10(bytes10 p0) internal pure {
   99 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
  100 |     |     }
  101 |     | 
  102 |     |     function logBytes11(bytes11 p0) internal pure {
  103 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
  104 |     |     }
  105 |     | 
  106 |     |     function logBytes12(bytes12 p0) internal pure {
  107 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
  108 |     |     }
  109 |     | 
  110 |     |     function logBytes13(bytes13 p0) internal pure {
  111 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  112 |     |     }
  113 |     | 
  114 |     |     function logBytes14(bytes14 p0) internal pure {
  115 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  116 |     |     }
  117 |     | 
  118 |     |     function logBytes15(bytes15 p0) internal pure {
  119 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  120 |     |     }
  121 |     | 
  122 |     |     function logBytes16(bytes16 p0) internal pure {
  123 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  124 |     |     }
  125 |     | 
  126 |     |     function logBytes17(bytes17 p0) internal pure {
  127 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  128 |     |     }
  129 |     | 
  130 |     |     function logBytes18(bytes18 p0) internal pure {
  131 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  132 |     |     }
  133 |     | 
  134 |     |     function logBytes19(bytes19 p0) internal pure {
  135 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  136 |     |     }
  137 |     | 
  138 |     |     function logBytes20(bytes20 p0) internal pure {
  139 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  140 |     |     }
  141 |     | 
  142 |     |     function logBytes21(bytes21 p0) internal pure {
  143 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  144 |     |     }
  145 |     | 
  146 |     |     function logBytes22(bytes22 p0) internal pure {
  147 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  148 |     |     }
  149 |     | 
  150 |     |     function logBytes23(bytes23 p0) internal pure {
  151 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  152 |     |     }
  153 |     | 
  154 |     |     function logBytes24(bytes24 p0) internal pure {
  155 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  156 |     |     }
  157 |     | 
  158 |     |     function logBytes25(bytes25 p0) internal pure {
  159 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  160 |     |     }
  161 |     | 
  162 |     |     function logBytes26(bytes26 p0) internal pure {
  163 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  164 |     |     }
  165 |     | 
  166 |     |     function logBytes27(bytes27 p0) internal pure {
  167 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  168 |     |     }
  169 |     | 
  170 |     |     function logBytes28(bytes28 p0) internal pure {
  171 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  172 |     |     }
  173 |     | 
  174 |     |     function logBytes29(bytes29 p0) internal pure {
  175 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  176 |     |     }
  177 |     | 
  178 |     |     function logBytes30(bytes30 p0) internal pure {
  179 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  180 |     |     }
  181 |     | 
  182 |     |     function logBytes31(bytes31 p0) internal pure {
  183 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  184 |     |     }
  185 |     | 
  186 |     |     function logBytes32(bytes32 p0) internal pure {
  187 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  188 |     |     }
  189 |     | 
  190 |     |     function log(uint256 p0) internal pure {
  191 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  192 |     |     }
  193 |     | 
  194 |     |     function log(int256 p0) internal pure {
  195 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
  196 |     |     }
  197 |     | 
  198 |     |     function log(string memory p0) internal pure {
  199 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  200 |     |     }
  201 |     | 
  202 |     |     function log(bool p0) internal pure {
  203 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  204 |     |     }
  205 |     | 
  206 |     |     function log(address p0) internal pure {
  207 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  208 |     |     }
  209 |     | 
  210 |     |     function log(uint256 p0, uint256 p1) internal pure {
  211 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  212 |     |     }
  213 |     | 
  214 |     |     function log(uint256 p0, string memory p1) internal pure {
  215 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  216 |     |     }
  217 |     | 
  218 |     |     function log(uint256 p0, bool p1) internal pure {
  219 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  220 |     |     }
  221 |     | 
  222 |     |     function log(uint256 p0, address p1) internal pure {
  223 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  224 |     |     }
  225 |     | 
  226 |     |     function log(string memory p0, uint256 p1) internal pure {
  227 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  228 |     |     }
  229 |     | 
  230 |     |     function log(string memory p0, int256 p1) internal pure {
  231 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,int256)", p0, p1));
  232 |     |     }
  233 |     | 
  234 |     |     function log(string memory p0, string memory p1) internal pure {
  235 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  236 |     |     }
  237 |     | 
  238 |     |     function log(string memory p0, bool p1) internal pure {
  239 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  240 |     |     }
  241 |     | 
  242 |     |     function log(string memory p0, address p1) internal pure {
  243 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  244 |     |     }
  245 |     | 
  246 |     |     function log(bool p0, uint256 p1) internal pure {
  247 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  248 |     |     }
  249 |     | 
  250 |     |     function log(bool p0, string memory p1) internal pure {
  251 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  252 |     |     }
  253 |     | 
  254 |     |     function log(bool p0, bool p1) internal pure {
  255 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  256 |     |     }
  257 |     | 
  258 |     |     function log(bool p0, address p1) internal pure {
  259 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  260 |     |     }
  261 |     | 
  262 |     |     function log(address p0, uint256 p1) internal pure {
  263 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  264 |     |     }
  265 |     | 
  266 |     |     function log(address p0, string memory p1) internal pure {
  267 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  268 |     |     }
  269 |     | 
  270 |     |     function log(address p0, bool p1) internal pure {
  271 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  272 |     |     }
  273 |     | 
  274 |     |     function log(address p0, address p1) internal pure {
  275 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  276 |     |     }
  277 |     | 
  278 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  279 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  280 |     |     }
  281 |     | 
  282 |     |     function log(uint256 p0, uint256 p1, string memory p2) internal pure {
  283 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  284 |     |     }
  285 |     | 
  286 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  287 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  288 |     |     }
  289 |     | 
  290 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  291 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  292 |     |     }
  293 |     | 
  294 |     |     function log(uint256 p0, string memory p1, uint256 p2) internal pure {
  295 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  296 |     |     }
  297 |     | 
  298 |     |     function log(uint256 p0, string memory p1, string memory p2) internal pure {
  299 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  300 |     |     }
  301 |     | 
  302 |     |     function log(uint256 p0, string memory p1, bool p2) internal pure {
  303 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  304 |     |     }
  305 |     | 
  306 |     |     function log(uint256 p0, string memory p1, address p2) internal pure {
  307 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  308 |     |     }
  309 |     | 
  310 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  311 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  312 |     |     }
  313 |     | 
  314 |     |     function log(uint256 p0, bool p1, string memory p2) internal pure {
  315 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  316 |     |     }
  317 |     | 
  318 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  319 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  320 |     |     }
  321 |     | 
  322 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  323 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  324 |     |     }
  325 |     | 
  326 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  327 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  328 |     |     }
  329 |     | 
  330 |     |     function log(uint256 p0, address p1, string memory p2) internal pure {
  331 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  332 |     |     }
  333 |     | 
  334 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  335 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  336 |     |     }
  337 |     | 
  338 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  339 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  340 |     |     }
  341 |     | 
  342 |     |     function log(string memory p0, uint256 p1, uint256 p2) internal pure {
  343 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  344 |     |     }
  345 |     | 
  346 |     |     function log(string memory p0, uint256 p1, string memory p2) internal pure {
  347 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  348 |     |     }
  349 |     | 
  350 |     |     function log(string memory p0, uint256 p1, bool p2) internal pure {
  351 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  352 |     |     }
  353 |     | 
  354 |     |     function log(string memory p0, uint256 p1, address p2) internal pure {
  355 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  356 |     |     }
  357 |     | 
  358 |     |     function log(string memory p0, string memory p1, uint256 p2) internal pure {
  359 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  360 |     |     }
  361 |     | 
  362 |     |     function log(string memory p0, string memory p1, string memory p2) internal pure {
  363 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  364 |     |     }
  365 |     | 
  366 |     |     function log(string memory p0, string memory p1, bool p2) internal pure {
  367 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  368 |     |     }
  369 |     | 
  370 |     |     function log(string memory p0, string memory p1, address p2) internal pure {
  371 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  372 |     |     }
  373 |     | 
  374 |     |     function log(string memory p0, bool p1, uint256 p2) internal pure {
  375 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  376 |     |     }
  377 |     | 
  378 |     |     function log(string memory p0, bool p1, string memory p2) internal pure {
  379 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  380 |     |     }
  381 |     | 
  382 |     |     function log(string memory p0, bool p1, bool p2) internal pure {
  383 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  384 |     |     }
  385 |     | 
  386 |     |     function log(string memory p0, bool p1, address p2) internal pure {
  387 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  388 |     |     }
  389 |     | 
  390 |     |     function log(string memory p0, address p1, uint256 p2) internal pure {
  391 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  392 |     |     }
  393 |     | 
  394 |     |     function log(string memory p0, address p1, string memory p2) internal pure {
  395 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  396 |     |     }
  397 |     | 
  398 |     |     function log(string memory p0, address p1, bool p2) internal pure {
  399 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  400 |     |     }
  401 |     | 
  402 |     |     function log(string memory p0, address p1, address p2) internal pure {
  403 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  404 |     |     }
  405 |     | 
  406 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  407 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  408 |     |     }
  409 |     | 
  410 |     |     function log(bool p0, uint256 p1, string memory p2) internal pure {
  411 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  412 |     |     }
  413 |     | 
  414 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  415 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  416 |     |     }
  417 |     | 
  418 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  419 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  420 |     |     }
  421 |     | 
  422 |     |     function log(bool p0, string memory p1, uint256 p2) internal pure {
  423 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  424 |     |     }
  425 |     | 
  426 |     |     function log(bool p0, string memory p1, string memory p2) internal pure {
  427 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  428 |     |     }
  429 |     | 
  430 |     |     function log(bool p0, string memory p1, bool p2) internal pure {
  431 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  432 |     |     }
  433 |     | 
  434 |     |     function log(bool p0, string memory p1, address p2) internal pure {
  435 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  436 |     |     }
  437 |     | 
  438 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  439 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  440 |     |     }
  441 |     | 
  442 |     |     function log(bool p0, bool p1, string memory p2) internal pure {
  443 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  444 |     |     }
  445 |     | 
  446 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  447 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  448 |     |     }
  449 |     | 
  450 |     |     function log(bool p0, bool p1, address p2) internal pure {
  451 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  452 |     |     }
  453 |     | 
  454 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  455 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  456 |     |     }
  457 |     | 
  458 |     |     function log(bool p0, address p1, string memory p2) internal pure {
  459 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  460 |     |     }
  461 |     | 
  462 |     |     function log(bool p0, address p1, bool p2) internal pure {
  463 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  464 |     |     }
  465 |     | 
  466 |     |     function log(bool p0, address p1, address p2) internal pure {
  467 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  468 |     |     }
  469 |     | 
  470 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
  471 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  472 |     |     }
  473 |     | 
  474 |     |     function log(address p0, uint256 p1, string memory p2) internal pure {
  475 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  476 |     |     }
  477 |     | 
  478 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
  479 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  480 |     |     }
  481 |     | 
  482 |     |     function log(address p0, uint256 p1, address p2) internal pure {
  483 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  484 |     |     }
  485 |     | 
  486 |     |     function log(address p0, string memory p1, uint256 p2) internal pure {
  487 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  488 |     |     }
  489 |     | 
  490 |     |     function log(address p0, string memory p1, string memory p2) internal pure {
  491 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  492 |     |     }
  493 |     | 
  494 |     |     function log(address p0, string memory p1, bool p2) internal pure {
  495 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  496 |     |     }
  497 |     | 
  498 |     |     function log(address p0, string memory p1, address p2) internal pure {
  499 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  500 |     |     }
  501 |     | 
  502 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
  503 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  504 |     |     }
  505 |     | 
  506 |     |     function log(address p0, bool p1, string memory p2) internal pure {
  507 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  508 |     |     }
  509 |     | 
  510 |     |     function log(address p0, bool p1, bool p2) internal pure {
  511 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  512 |     |     }
  513 |     | 
  514 |     |     function log(address p0, bool p1, address p2) internal pure {
  515 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  516 |     |     }
  517 |     | 
  518 |     |     function log(address p0, address p1, uint256 p2) internal pure {
  519 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  520 |     |     }
  521 |     | 
  522 |     |     function log(address p0, address p1, string memory p2) internal pure {
  523 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  524 |     |     }
  525 |     | 
  526 |     |     function log(address p0, address p1, bool p2) internal pure {
  527 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  528 |     |     }
  529 |     | 
  530 |     |     function log(address p0, address p1, address p2) internal pure {
  531 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  532 |     |     }
  533 |     | 
  534 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  535 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  536 |     |     }
  537 |     | 
  538 |     |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  539 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  540 |     |     }
  541 |     | 
  542 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  543 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  544 |     |     }
  545 |     | 
  546 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  547 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  548 |     |     }
  549 |     | 
  550 |     |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  551 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  552 |     |     }
  553 |     | 
  554 |     |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {
  555 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  556 |     |     }
  557 |     | 
  558 |     |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {
  559 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  560 |     |     }
  561 |     | 
  562 |     |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {
  563 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  564 |     |     }
  565 |     | 
  566 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  567 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  568 |     |     }
  569 |     | 
  570 |     |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {
  571 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  572 |     |     }
  573 |     | 
  574 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  575 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  576 |     |     }
  577 |     | 
  578 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  579 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  580 |     |     }
  581 |     | 
  582 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  583 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  584 |     |     }
  585 |     | 
  586 |     |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {
  587 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  588 |     |     }
  589 |     | 
  590 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  591 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  592 |     |     }
  593 |     | 
  594 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  595 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  596 |     |     }
  597 |     | 
  598 |     |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  599 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  600 |     |     }
  601 |     | 
  602 |     |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {
  603 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  604 |     |     }
  605 |     | 
  606 |     |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {
  607 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  608 |     |     }
  609 |     | 
  610 |     |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {
  611 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  612 |     |     }
  613 |     | 
  614 |     |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {
  615 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  616 |     |     }
  617 |     | 
  618 |     |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {
  619 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  620 |     |     }
  621 |     | 
  622 |     |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {
  623 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  624 |     |     }
  625 |     | 
  626 |     |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {
  627 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  628 |     |     }
  629 |     | 
  630 |     |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {
  631 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  632 |     |     }
  633 |     | 
  634 |     |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {
  635 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  636 |     |     }
  637 |     | 
  638 |     |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {
  639 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  640 |     |     }
  641 |     | 
  642 |     |     function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {
  643 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  644 |     |     }
  645 |     | 
  646 |     |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {
  647 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  648 |     |     }
  649 |     | 
  650 |     |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {
  651 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  652 |     |     }
  653 |     | 
  654 |     |     function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {
  655 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  656 |     |     }
  657 |     | 
  658 |     |     function log(uint256 p0, string memory p1, address p2, address p3) internal pure {
  659 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  660 |     |     }
  661 |     | 
  662 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  663 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  664 |     |     }
  665 |     | 
  666 |     |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {
  667 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  668 |     |     }
  669 |     | 
  670 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  671 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  672 |     |     }
  673 |     | 
  674 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  675 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  676 |     |     }
  677 |     | 
  678 |     |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {
  679 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  680 |     |     }
  681 |     | 
  682 |     |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {
  683 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  684 |     |     }
  685 |     | 
  686 |     |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {
  687 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  688 |     |     }
  689 |     | 
  690 |     |     function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {
  691 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  692 |     |     }
  693 |     | 
  694 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  695 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  696 |     |     }
  697 |     | 
  698 |     |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {
  699 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  700 |     |     }
  701 |     | 
  702 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  703 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  704 |     |     }
  705 |     | 
  706 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  707 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  708 |     |     }
  709 |     | 
  710 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  711 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  712 |     |     }
  713 |     | 
  714 |     |     function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {
  715 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  716 |     |     }
  717 |     | 
  718 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  719 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  720 |     |     }
  721 |     | 
  722 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  723 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  724 |     |     }
  725 |     | 
  726 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  727 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  728 |     |     }
  729 |     | 
  730 |     |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {
  731 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  732 |     |     }
  733 |     | 
  734 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  735 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  736 |     |     }
  737 |     | 
  738 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  739 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  740 |     |     }
  741 |     | 
  742 |     |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {
  743 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  744 |     |     }
  745 |     | 
  746 |     |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {
  747 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  748 |     |     }
  749 |     | 
  750 |     |     function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {
  751 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  752 |     |     }
  753 |     | 
  754 |     |     function log(uint256 p0, address p1, string memory p2, address p3) internal pure {
  755 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  756 |     |     }
  757 |     | 
  758 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  759 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  760 |     |     }
  761 |     | 
  762 |     |     function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {
  763 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  764 |     |     }
  765 |     | 
  766 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  767 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  768 |     |     }
  769 |     | 
  770 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  771 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  772 |     |     }
  773 |     | 
  774 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  775 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  776 |     |     }
  777 |     | 
  778 |     |     function log(uint256 p0, address p1, address p2, string memory p3) internal pure {
  779 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  780 |     |     }
  781 |     | 
  782 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  783 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  784 |     |     }
  785 |     | 
  786 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  787 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  788 |     |     }
  789 |     | 
  790 |     |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  791 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  792 |     |     }
  793 |     | 
  794 |     |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  795 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  796 |     |     }
  797 |     | 
  798 |     |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {
  799 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  800 |     |     }
  801 |     | 
  802 |     |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {
  803 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  804 |     |     }
  805 |     | 
  806 |     |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  807 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  808 |     |     }
  809 |     | 
  810 |     |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {
  811 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  812 |     |     }
  813 |     | 
  814 |     |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {
  815 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  816 |     |     }
  817 |     | 
  818 |     |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {
  819 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  820 |     |     }
  821 |     | 
  822 |     |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {
  823 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  824 |     |     }
  825 |     | 
  826 |     |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {
  827 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  828 |     |     }
  829 |     | 
  830 |     |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {
  831 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  832 |     |     }
  833 |     | 
  834 |     |     function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {
  835 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  836 |     |     }
  837 |     | 
  838 |     |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {
  839 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  840 |     |     }
  841 |     | 
  842 |     |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {
  843 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  844 |     |     }
  845 |     | 
  846 |     |     function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {
  847 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  848 |     |     }
  849 |     | 
  850 |     |     function log(string memory p0, uint256 p1, address p2, address p3) internal pure {
  851 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  852 |     |     }
  853 |     | 
  854 |     |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  855 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  856 |     |     }
  857 |     | 
  858 |     |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {
  859 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  860 |     |     }
  861 |     | 
  862 |     |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {
  863 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  864 |     |     }
  865 |     | 
  866 |     |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {
  867 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  868 |     |     }
  869 |     | 
  870 |     |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {
  871 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  872 |     |     }
  873 |     | 
  874 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {
  875 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  876 |     |     }
  877 |     | 
  878 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {
  879 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  880 |     |     }
  881 |     | 
  882 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {
  883 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  884 |     |     }
  885 |     | 
  886 |     |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {
  887 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  888 |     |     }
  889 |     | 
  890 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {
  891 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  892 |     |     }
  893 |     | 
  894 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {
  895 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  896 |     |     }
  897 |     | 
  898 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal pure {
  899 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  900 |     |     }
  901 |     | 
  902 |     |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {
  903 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  904 |     |     }
  905 |     | 
  906 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {
  907 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  908 |     |     }
  909 |     | 
  910 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal pure {
  911 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  912 |     |     }
  913 |     | 
  914 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal pure {
  915 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  916 |     |     }
  917 |     | 
  918 |     |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {
  919 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  920 |     |     }
  921 |     | 
  922 |     |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {
  923 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  924 |     |     }
  925 |     | 
  926 |     |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {
  927 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  928 |     |     }
  929 |     | 
  930 |     |     function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {
  931 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  932 |     |     }
  933 |     | 
  934 |     |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {
  935 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  936 |     |     }
  937 |     | 
  938 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {
  939 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  940 |     |     }
  941 |     | 
  942 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {
  943 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  944 |     |     }
  945 |     | 
  946 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal pure {
  947 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  948 |     |     }
  949 |     | 
  950 |     |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {
  951 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  952 |     |     }
  953 |     | 
  954 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {
  955 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  956 |     |     }
  957 |     | 
  958 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal pure {
  959 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  960 |     |     }
  961 |     | 
  962 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal pure {
  963 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  964 |     |     }
  965 |     | 
  966 |     |     function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {
  967 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  968 |     |     }
  969 |     | 
  970 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal pure {
  971 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  972 |     |     }
  973 |     | 
  974 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal pure {
  975 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  976 |     |     }
  977 |     | 
  978 |     |     function log(string memory p0, bool p1, address p2, address p3) internal pure {
  979 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  980 |     |     }
  981 |     | 
  982 |     |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {
  983 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  984 |     |     }
  985 |     | 
  986 |     |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {
  987 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  988 |     |     }
  989 |     | 
  990 |     |     function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {
  991 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  992 |     |     }
  993 |     | 
  994 |     |     function log(string memory p0, address p1, uint256 p2, address p3) internal pure {
  995 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  996 |     |     }
  997 |     | 
  998 |     |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {
  999 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
 1000 |     |     }
 1001 |     | 
 1002 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {
 1003 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
 1004 |     |     }
 1005 |     | 
 1006 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal pure {
 1007 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
 1008 |     |     }
 1009 |     | 
 1010 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal pure {
 1011 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
 1012 |     |     }
 1013 |     | 
 1014 |     |     function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {
 1015 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
 1016 |     |     }
 1017 |     | 
 1018 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal pure {
 1019 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1020 |     |     }
 1021 |     | 
 1022 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal pure {
 1023 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1024 |     |     }
 1025 |     | 
 1026 |     |     function log(string memory p0, address p1, bool p2, address p3) internal pure {
 1027 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1028 |     |     }
 1029 |     | 
 1030 |     |     function log(string memory p0, address p1, address p2, uint256 p3) internal pure {
 1031 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1032 |     |     }
 1033 |     | 
 1034 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal pure {
 1035 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1036 |     |     }
 1037 |     | 
 1038 |     |     function log(string memory p0, address p1, address p2, bool p3) internal pure {
 1039 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1040 |     |     }
 1041 |     | 
 1042 |     |     function log(string memory p0, address p1, address p2, address p3) internal pure {
 1043 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1044 |     |     }
 1045 |     | 
 1046 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1047 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1048 |     |     }
 1049 |     | 
 1050 |     |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1051 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1052 |     |     }
 1053 |     | 
 1054 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1055 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1056 |     |     }
 1057 |     | 
 1058 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
 1059 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1060 |     |     }
 1061 |     | 
 1062 |     |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1063 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1064 |     |     }
 1065 |     | 
 1066 |     |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1067 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1068 |     |     }
 1069 |     | 
 1070 |     |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {
 1071 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1072 |     |     }
 1073 |     | 
 1074 |     |     function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {
 1075 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1076 |     |     }
 1077 |     | 
 1078 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1079 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1080 |     |     }
 1081 |     | 
 1082 |     |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {
 1083 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1084 |     |     }
 1085 |     | 
 1086 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
 1087 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1088 |     |     }
 1089 |     | 
 1090 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
 1091 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1092 |     |     }
 1093 |     | 
 1094 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
 1095 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1096 |     |     }
 1097 |     | 
 1098 |     |     function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {
 1099 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1100 |     |     }
 1101 |     | 
 1102 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
 1103 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1104 |     |     }
 1105 |     | 
 1106 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
 1107 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1108 |     |     }
 1109 |     | 
 1110 |     |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1111 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1112 |     |     }
 1113 |     | 
 1114 |     |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1115 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1116 |     |     }
 1117 |     | 
 1118 |     |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {
 1119 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1120 |     |     }
 1121 |     | 
 1122 |     |     function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {
 1123 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1124 |     |     }
 1125 |     | 
 1126 |     |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1127 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1128 |     |     }
 1129 |     | 
 1130 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {
 1131 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1132 |     |     }
 1133 |     | 
 1134 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {
 1135 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1136 |     |     }
 1137 |     | 
 1138 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal pure {
 1139 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1140 |     |     }
 1141 |     | 
 1142 |     |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {
 1143 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1144 |     |     }
 1145 |     | 
 1146 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {
 1147 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1148 |     |     }
 1149 |     | 
 1150 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal pure {
 1151 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1152 |     |     }
 1153 |     | 
 1154 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal pure {
 1155 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1156 |     |     }
 1157 |     | 
 1158 |     |     function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {
 1159 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1160 |     |     }
 1161 |     | 
 1162 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal pure {
 1163 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1164 |     |     }
 1165 |     | 
 1166 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal pure {
 1167 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1168 |     |     }
 1169 |     | 
 1170 |     |     function log(bool p0, string memory p1, address p2, address p3) internal pure {
 1171 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1172 |     |     }
 1173 |     | 
 1174 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1175 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1176 |     |     }
 1177 |     | 
 1178 |     |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {
 1179 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1180 |     |     }
 1181 |     | 
 1182 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
 1183 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1184 |     |     }
 1185 |     | 
 1186 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
 1187 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1188 |     |     }
 1189 |     | 
 1190 |     |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {
 1191 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1192 |     |     }
 1193 |     | 
 1194 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {
 1195 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1196 |     |     }
 1197 |     | 
 1198 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal pure {
 1199 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1200 |     |     }
 1201 |     | 
 1202 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal pure {
 1203 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1204 |     |     }
 1205 |     | 
 1206 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
 1207 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1208 |     |     }
 1209 |     | 
 1210 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal pure {
 1211 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1212 |     |     }
 1213 |     | 
 1214 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
 1215 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1216 |     |     }
 1217 |     | 
 1218 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
 1219 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1220 |     |     }
 1221 |     | 
 1222 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
 1223 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1224 |     |     }
 1225 |     | 
 1226 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal pure {
 1227 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1228 |     |     }
 1229 |     | 
 1230 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
 1231 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1232 |     |     }
 1233 |     | 
 1234 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
 1235 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1236 |     |     }
 1237 |     | 
 1238 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
 1239 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1240 |     |     }
 1241 |     | 
 1242 |     |     function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {
 1243 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1244 |     |     }
 1245 |     | 
 1246 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
 1247 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1248 |     |     }
 1249 |     | 
 1250 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
 1251 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1252 |     |     }
 1253 |     | 
 1254 |     |     function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {
 1255 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1256 |     |     }
 1257 |     | 
 1258 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal pure {
 1259 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1260 |     |     }
 1261 |     | 
 1262 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal pure {
 1263 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1264 |     |     }
 1265 |     | 
 1266 |     |     function log(bool p0, address p1, string memory p2, address p3) internal pure {
 1267 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1268 |     |     }
 1269 |     | 
 1270 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
 1271 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1272 |     |     }
 1273 |     | 
 1274 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal pure {
 1275 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1276 |     |     }
 1277 |     | 
 1278 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
 1279 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1280 |     |     }
 1281 |     | 
 1282 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
 1283 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1284 |     |     }
 1285 |     | 
 1286 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
 1287 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1288 |     |     }
 1289 |     | 
 1290 |     |     function log(bool p0, address p1, address p2, string memory p3) internal pure {
 1291 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1292 |     |     }
 1293 |     | 
 1294 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
 1295 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1296 |     |     }
 1297 |     | 
 1298 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
 1299 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1300 |     |     }
 1301 |     | 
 1302 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1303 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1304 |     |     }
 1305 |     | 
 1306 |     |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1307 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1308 |     |     }
 1309 |     | 
 1310 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1311 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1312 |     |     }
 1313 |     | 
 1314 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
 1315 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1316 |     |     }
 1317 |     | 
 1318 |     |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1319 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1320 |     |     }
 1321 |     | 
 1322 |     |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1323 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1324 |     |     }
 1325 |     | 
 1326 |     |     function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {
 1327 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1328 |     |     }
 1329 |     | 
 1330 |     |     function log(address p0, uint256 p1, string memory p2, address p3) internal pure {
 1331 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1332 |     |     }
 1333 |     | 
 1334 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1335 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1336 |     |     }
 1337 |     | 
 1338 |     |     function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {
 1339 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1340 |     |     }
 1341 |     | 
 1342 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
 1343 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1344 |     |     }
 1345 |     | 
 1346 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
 1347 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1348 |     |     }
 1349 |     | 
 1350 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
 1351 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1352 |     |     }
 1353 |     | 
 1354 |     |     function log(address p0, uint256 p1, address p2, string memory p3) internal pure {
 1355 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1356 |     |     }
 1357 |     | 
 1358 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
 1359 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1360 |     |     }
 1361 |     | 
 1362 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
 1363 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1364 |     |     }
 1365 |     | 
 1366 |     |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1367 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1368 |     |     }
 1369 |     | 
 1370 |     |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1371 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1372 |     |     }
 1373 |     | 
 1374 |     |     function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {
 1375 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1376 |     |     }
 1377 |     | 
 1378 |     |     function log(address p0, string memory p1, uint256 p2, address p3) internal pure {
 1379 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1380 |     |     }
 1381 |     | 
 1382 |     |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1383 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1384 |     |     }
 1385 |     | 
 1386 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {
 1387 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1388 |     |     }
 1389 |     | 
 1390 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal pure {
 1391 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1392 |     |     }
 1393 |     | 
 1394 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal pure {
 1395 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1396 |     |     }
 1397 |     | 
 1398 |     |     function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {
 1399 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1400 |     |     }
 1401 |     | 
 1402 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal pure {
 1403 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1404 |     |     }
 1405 |     | 
 1406 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal pure {
 1407 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1408 |     |     }
 1409 |     | 
 1410 |     |     function log(address p0, string memory p1, bool p2, address p3) internal pure {
 1411 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1412 |     |     }
 1413 |     | 
 1414 |     |     function log(address p0, string memory p1, address p2, uint256 p3) internal pure {
 1415 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1416 |     |     }
 1417 |     | 
 1418 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal pure {
 1419 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1420 |     |     }
 1421 |     | 
 1422 |     |     function log(address p0, string memory p1, address p2, bool p3) internal pure {
 1423 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1424 |     |     }
 1425 |     | 
 1426 |     |     function log(address p0, string memory p1, address p2, address p3) internal pure {
 1427 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1428 |     |     }
 1429 |     | 
 1430 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1431 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1432 |     |     }
 1433 |     | 
 1434 |     |     function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {
 1435 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1436 |     |     }
 1437 |     | 
 1438 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
 1439 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1440 |     |     }
 1441 |     | 
 1442 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
 1443 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1444 |     |     }
 1445 |     | 
 1446 |     |     function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {
 1447 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1448 |     |     }
 1449 |     | 
 1450 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal pure {
 1451 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1452 |     |     }
 1453 |     | 
 1454 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal pure {
 1455 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1456 |     |     }
 1457 |     | 
 1458 |     |     function log(address p0, bool p1, string memory p2, address p3) internal pure {
 1459 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1460 |     |     }
 1461 |     | 
 1462 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
 1463 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1464 |     |     }
 1465 |     | 
 1466 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal pure {
 1467 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1468 |     |     }
 1469 |     | 
 1470 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
 1471 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1472 |     |     }
 1473 |     | 
 1474 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
 1475 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1476 |     |     }
 1477 |     | 
 1478 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
 1479 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1480 |     |     }
 1481 |     | 
 1482 |     |     function log(address p0, bool p1, address p2, string memory p3) internal pure {
 1483 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1484 |     |     }
 1485 |     | 
 1486 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
 1487 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1488 |     |     }
 1489 |     | 
 1490 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
 1491 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1492 |     |     }
 1493 |     | 
 1494 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
 1495 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1496 |     |     }
 1497 |     | 
 1498 |     |     function log(address p0, address p1, uint256 p2, string memory p3) internal pure {
 1499 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1500 |     |     }
 1501 |     | 
 1502 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
 1503 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1504 |     |     }
 1505 |     | 
 1506 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
 1507 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1508 |     |     }
 1509 |     | 
 1510 |     |     function log(address p0, address p1, string memory p2, uint256 p3) internal pure {
 1511 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1512 |     |     }
 1513 |     | 
 1514 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal pure {
 1515 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1516 |     |     }
 1517 |     | 
 1518 |     |     function log(address p0, address p1, string memory p2, bool p3) internal pure {
 1519 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1520 |     |     }
 1521 |     | 
 1522 |     |     function log(address p0, address p1, string memory p2, address p3) internal pure {
 1523 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1524 |     |     }
 1525 |     | 
 1526 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
 1527 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1528 |     |     }
 1529 |     | 
 1530 |     |     function log(address p0, address p1, bool p2, string memory p3) internal pure {
 1531 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1532 |     |     }
 1533 |     | 
 1534 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
 1535 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1536 |     |     }
 1537 |     | 
 1538 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
 1539 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1540 |     |     }
 1541 |     | 
 1542 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
 1543 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1544 |     |     }
 1545 |     | 
 1546 |     |     function log(address p0, address p1, address p2, string memory p3) internal pure {
 1547 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1548 |     |     }
 1549 |     | 
 1550 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
 1551 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1552 |     |     }
 1553 |     | 
 1554 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
 1555 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1556 |     |     }
 1557 |     | 
 1558 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/interfaces/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2;
  3 |     | 
  4 |     | interface IERC165 {
  5 |     |     /// @notice Query if a contract implements an interface
  6 |     |     /// @param interfaceID The interface identifier, as specified in ERC-165
  7 |     |     /// @dev Interface identification is specified in ERC-165. This function
  8 |     |     /// uses less than 30,000 gas.
  9 |     |     /// @return `true` if the contract implements `interfaceID` and
 10 |     |     /// `interfaceID` is not 0xffffffff, `false` otherwise
 11 |     |     function supportsInterface(bytes4 interfaceID) external view returns (bool);
 12 |     | }
 13 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/interfaces/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2;
  3 |     | 
  4 |     | /// @dev Interface of the ERC20 standard as defined in the EIP.
  5 |     | /// @dev This includes the optional name, symbol, and decimals metadata.
  6 |     | interface IERC20 {
  7 |     |     /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).
  8 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  9 |     | 
 10 |     |     /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`
 11 |     |     /// is the new allowance.
 12 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 13 |     | 
 14 |     |     /// @notice Returns the amount of tokens in existence.
 15 |     |     function totalSupply() external view returns (uint256);
 16 |     | 
 17 |     |     /// @notice Returns the amount of tokens owned by `account`.
 18 |     |     function balanceOf(address account) external view returns (uint256);
 19 |     | 
 20 |     |     /// @notice Moves `amount` tokens from the caller's account to `to`.
 21 |     |     function transfer(address to, uint256 amount) external returns (bool);
 22 |     | 
 23 |     |     /// @notice Returns the remaining number of tokens that `spender` is allowed
 24 |     |     /// to spend on behalf of `owner`
 25 |     |     function allowance(address owner, address spender) external view returns (uint256);
 26 |     | 
 27 |     |     /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.
 28 |     |     /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 29 |     |     function approve(address spender, uint256 amount) external returns (bool);
 30 |     | 
 31 |     |     /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.
 32 |     |     /// `amount` is then deducted from the caller's allowance.
 33 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 34 |     | 
 35 |     |     /// @notice Returns the name of the token.
 36 |     |     function name() external view returns (string memory);
 37 |     | 
 38 |     |     /// @notice Returns the symbol of the token.
 39 |     |     function symbol() external view returns (string memory);
 40 |     | 
 41 |     |     /// @notice Returns the decimals places of the token.
 42 |     |     function decimals() external view returns (uint8);
 43 |     | }
 44 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/interfaces/IERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2;
   3 |     | 
   4 |     | import "./IERC165.sol";
   5 |     | 
   6 |     | /// @title ERC-721 Non-Fungible Token Standard
   7 |     | /// @dev See https://eips.ethereum.org/EIPS/eip-721
   8 |     | /// Note: the ERC-165 identifier for this interface is 0x80ac58cd.
   9 |     | interface IERC721 is IERC165 {
  10 |     |     /// @dev This emits when ownership of any NFT changes by any mechanism.
  11 |     |     /// This event emits when NFTs are created (`from` == 0) and destroyed
  12 |     |     /// (`to` == 0). Exception: during contract creation, any number of NFTs
  13 |     |     /// may be created and assigned without emitting Transfer. At the time of
  14 |     |     /// any transfer, the approved address for that NFT (if any) is reset to none.
  15 |     |     event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
  16 |     | 
  17 |     |     /// @dev This emits when the approved address for an NFT is changed or
  18 |     |     /// reaffirmed. The zero address indicates there is no approved address.
  19 |     |     /// When a Transfer event emits, this also indicates that the approved
  20 |     |     /// address for that NFT (if any) is reset to none.
  21 |     |     event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
  22 |     | 
  23 |     |     /// @dev This emits when an operator is enabled or disabled for an owner.
  24 |     |     /// The operator can manage all NFTs of the owner.
  25 |     |     event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
  26 |     | 
  27 |     |     /// @notice Count all NFTs assigned to an owner
  28 |     |     /// @dev NFTs assigned to the zero address are considered invalid, and this
  29 |     |     /// function throws for queries about the zero address.
  30 |     |     /// @param _owner An address for whom to query the balance
  31 |     |     /// @return The number of NFTs owned by `_owner`, possibly zero
  32 |     |     function balanceOf(address _owner) external view returns (uint256);
  33 |     | 
  34 |     |     /// @notice Find the owner of an NFT
  35 |     |     /// @dev NFTs assigned to zero address are considered invalid, and queries
  36 |     |     /// about them do throw.
  37 |     |     /// @param _tokenId The identifier for an NFT
  38 |     |     /// @return The address of the owner of the NFT
  39 |     |     function ownerOf(uint256 _tokenId) external view returns (address);
  40 |     | 
  41 |     |     /// @notice Transfers the ownership of an NFT from one address to another address
  42 |     |     /// @dev Throws unless `msg.sender` is the current owner, an authorized
  43 |     |     /// operator, or the approved address for this NFT. Throws if `_from` is
  44 |     |     /// not the current owner. Throws if `_to` is the zero address. Throws if
  45 |     |     /// `_tokenId` is not a valid NFT. When transfer is complete, this function
  46 |     |     /// checks if `_to` is a smart contract (code size > 0). If so, it calls
  47 |     |     /// `onERC721Received` on `_to` and throws if the return value is not
  48 |     |     /// `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
  49 |     |     /// @param _from The current owner of the NFT
  50 |     |     /// @param _to The new owner
  51 |     |     /// @param _tokenId The NFT to transfer
  52 |     |     /// @param data Additional data with no specified format, sent in call to `_to`
  53 |     |     function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;
  54 |     | 
  55 |     |     /// @notice Transfers the ownership of an NFT from one address to another address
  56 |     |     /// @dev This works identically to the other function with an extra data parameter,
  57 |     |     /// except this function just sets data to "".
  58 |     |     /// @param _from The current owner of the NFT
  59 |     |     /// @param _to The new owner
  60 |     |     /// @param _tokenId The NFT to transfer
  61 |     |     function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
  62 |     | 
  63 |     |     /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
  64 |     |     /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
  65 |     |     /// THEY MAY BE PERMANENTLY LOST
  66 |     |     /// @dev Throws unless `msg.sender` is the current owner, an authorized
  67 |     |     /// operator, or the approved address for this NFT. Throws if `_from` is
  68 |     |     /// not the current owner. Throws if `_to` is the zero address. Throws if
  69 |     |     /// `_tokenId` is not a valid NFT.
  70 |     |     /// @param _from The current owner of the NFT
  71 |     |     /// @param _to The new owner
  72 |     |     /// @param _tokenId The NFT to transfer
  73 |     |     function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
  74 |     | 
  75 |     |     /// @notice Change or reaffirm the approved address for an NFT
  76 |     |     /// @dev The zero address indicates there is no approved address.
  77 |     |     /// Throws unless `msg.sender` is the current NFT owner, or an authorized
  78 |     |     /// operator of the current owner.
  79 |     |     /// @param _approved The new approved NFT controller
  80 |     |     /// @param _tokenId The NFT to approve
  81 |     |     function approve(address _approved, uint256 _tokenId) external payable;
  82 |     | 
  83 |     |     /// @notice Enable or disable approval for a third party ("operator") to manage
  84 |     |     /// all of `msg.sender`'s assets
  85 |     |     /// @dev Emits the ApprovalForAll event. The contract MUST allow
  86 |     |     /// multiple operators per owner.
  87 |     |     /// @param _operator Address to add to the set of authorized operators
  88 |     |     /// @param _approved True if the operator is approved, false to revoke approval
  89 |     |     function setApprovalForAll(address _operator, bool _approved) external;
  90 |     | 
  91 |     |     /// @notice Get the approved address for a single NFT
  92 |     |     /// @dev Throws if `_tokenId` is not a valid NFT.
  93 |     |     /// @param _tokenId The NFT to find the approved address for
  94 |     |     /// @return The approved address for this NFT, or the zero address if there is none
  95 |     |     function getApproved(uint256 _tokenId) external view returns (address);
  96 |     | 
  97 |     |     /// @notice Query if an address is an authorized operator for another address
  98 |     |     /// @param _owner The address that owns the NFTs
  99 |     |     /// @param _operator The address that acts on behalf of the owner
 100 |     |     /// @return True if `_operator` is an approved operator for `_owner`, false otherwise
 101 |     |     function isApprovedForAll(address _owner, address _operator) external view returns (bool);
 102 |     | }
 103 |     | 
 104 |     | /// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.
 105 |     | interface IERC721TokenReceiver {
 106 |     |     /// @notice Handle the receipt of an NFT
 107 |     |     /// @dev The ERC721 smart contract calls this function on the recipient
 108 |     |     /// after a `transfer`. This function MAY throw to revert and reject the
 109 |     |     /// transfer. Return of other than the magic value MUST result in the
 110 |     |     /// transaction being reverted.
 111 |     |     /// Note: the contract address is always the message sender.
 112 |     |     /// @param _operator The address which called `safeTransferFrom` function
 113 |     |     /// @param _from The address which previously owned the token
 114 |     |     /// @param _tokenId The NFT identifier which is being transferred
 115 |     |     /// @param _data Additional data with no specified format
 116 |     |     /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
 117 |     |     ///  unless throwing
 118 |     |     function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)
 119 |     |         external
 120 |     |         returns (bytes4);
 121 |     | }
 122 |     | 
 123 |     | /// @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 124 |     | /// @dev See https://eips.ethereum.org/EIPS/eip-721
 125 |     | /// Note: the ERC-165 identifier for this interface is 0x5b5e139f.
 126 |     | interface IERC721Metadata is IERC721 {
 127 |     |     /// @notice A descriptive name for a collection of NFTs in this contract
 128 |     |     function name() external view returns (string memory _name);
 129 |     | 
 130 |     |     /// @notice An abbreviated name for NFTs in this contract
 131 |     |     function symbol() external view returns (string memory _symbol);
 132 |     | 
 133 |     |     /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
 134 |     |     /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
 135 |     |     /// 3986. The URI may point to a JSON file that conforms to the "ERC721
 136 |     |     /// Metadata JSON Schema".
 137 |     |     function tokenURI(uint256 _tokenId) external view returns (string memory);
 138 |     | }
 139 |     | 
 140 |     | /// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 141 |     | /// @dev See https://eips.ethereum.org/EIPS/eip-721
 142 |     | /// Note: the ERC-165 identifier for this interface is 0x780e9d63.
 143 |     | interface IERC721Enumerable is IERC721 {
 144 |     |     /// @notice Count NFTs tracked by this contract
 145 |     |     /// @return A count of valid NFTs tracked by this contract, where each one of
 146 |     |     /// them has an assigned and queryable owner not equal to the zero address
 147 |     |     function totalSupply() external view returns (uint256);
 148 |     | 
 149 |     |     /// @notice Enumerate valid NFTs
 150 |     |     /// @dev Throws if `_index` >= `totalSupply()`.
 151 |     |     /// @param _index A counter less than `totalSupply()`
 152 |     |     /// @return The token identifier for the `_index`th NFT,
 153 |     |     /// (sort order not specified)
 154 |     |     function tokenByIndex(uint256 _index) external view returns (uint256);
 155 |     | 
 156 |     |     /// @notice Enumerate NFTs assigned to an owner
 157 |     |     /// @dev Throws if `_index` >= `balanceOf(_owner)` or if
 158 |     |     /// `_owner` is the zero address, representing invalid NFTs.
 159 |     |     /// @param _owner An address where we are interested in NFTs owned by them
 160 |     |     /// @param _index A counter less than `balanceOf(_owner)`
 161 |     |     /// @return The token identifier for the `_index`th NFT assigned to `_owner`,
 162 |     |     /// (sort order not specified)
 163 |     |     function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);
 164 |     | }
 165 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/interfaces/IMulticall3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | interface IMulticall3 {
  7 |     |     struct Call {
  8 |     |         address target;
  9 |     |         bytes callData;
 10 |     |     }
 11 |     | 
 12 |     |     struct Call3 {
 13 |     |         address target;
 14 |     |         bool allowFailure;
 15 |     |         bytes callData;
 16 |     |     }
 17 |     | 
 18 |     |     struct Call3Value {
 19 |     |         address target;
 20 |     |         bool allowFailure;
 21 |     |         uint256 value;
 22 |     |         bytes callData;
 23 |     |     }
 24 |     | 
 25 |     |     struct Result {
 26 |     |         bool success;
 27 |     |         bytes returnData;
 28 |     |     }
 29 |     | 
 30 |     |     function aggregate(Call[] calldata calls)
 31 |     |         external
 32 |     |         payable
 33 |     |         returns (uint256 blockNumber, bytes[] memory returnData);
 34 |     | 
 35 |     |     function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);
 36 |     | 
 37 |     |     function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);
 38 |     | 
 39 |     |     function blockAndAggregate(Call[] calldata calls)
 40 |     |         external
 41 |     |         payable
 42 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 43 |     | 
 44 |     |     function getBasefee() external view returns (uint256 basefee);
 45 |     | 
 46 |     |     function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);
 47 |     | 
 48 |     |     function getBlockNumber() external view returns (uint256 blockNumber);
 49 |     | 
 50 |     |     function getChainId() external view returns (uint256 chainid);
 51 |     | 
 52 |     |     function getCurrentBlockCoinbase() external view returns (address coinbase);
 53 |     | 
 54 |     |     function getCurrentBlockDifficulty() external view returns (uint256 difficulty);
 55 |     | 
 56 |     |     function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);
 57 |     | 
 58 |     |     function getCurrentBlockTimestamp() external view returns (uint256 timestamp);
 59 |     | 
 60 |     |     function getEthBalance(address addr) external view returns (uint256 balance);
 61 |     | 
 62 |     |     function getLastBlockHash() external view returns (bytes32 blockHash);
 63 |     | 
 64 |     |     function tryAggregate(bool requireSuccess, Call[] calldata calls)
 65 |     |         external
 66 |     |         payable
 67 |     |         returns (Result[] memory returnData);
 68 |     | 
 69 |     |     function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)
 70 |     |         external
 71 |     |         payable
 72 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 73 |     | }
 74 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/mocks/MockERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {IERC20} from "../interfaces/IERC20.sol";
   5 |     | 
   6 |     | /// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.
   7 |     | /// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol
   8 |     | contract MockERC20 is IERC20 {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                             METADATA STORAGE
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     string internal _name;
  14 |     | 
  15 |     |     string internal _symbol;
  16 |     | 
  17 |     |     uint8 internal _decimals;
  18 |     | 
  19 |     |     function name() external view override returns (string memory) {
  20 |     |         return _name;
  21 |     |     }
  22 |     | 
  23 |     |     function symbol() external view override returns (string memory) {
  24 |     |         return _symbol;
  25 |     |     }
  26 |     | 
  27 |     |     function decimals() external view override returns (uint8) {
  28 |     |         return _decimals;
  29 |     |     }
  30 |     | 
  31 |     |     /*//////////////////////////////////////////////////////////////
  32 |     |                               ERC20 STORAGE
  33 |     |     //////////////////////////////////////////////////////////////*/
  34 |     | 
  35 |     |     uint256 internal _totalSupply;
  36 |     | 
  37 |     |     mapping(address => uint256) internal _balanceOf;
  38 |     | 
  39 |     |     mapping(address => mapping(address => uint256)) internal _allowance;
  40 |     | 
  41 |     |     function totalSupply() external view override returns (uint256) {
  42 |     |         return _totalSupply;
  43 |     |     }
  44 |     | 
  45 |     |     function balanceOf(address owner) external view override returns (uint256) {
  46 |     |         return _balanceOf[owner];
  47 |     |     }
  48 |     | 
  49 |     |     function allowance(address owner, address spender) external view override returns (uint256) {
  50 |     |         return _allowance[owner][spender];
  51 |     |     }
  52 |     | 
  53 |     |     /*//////////////////////////////////////////////////////////////
  54 |     |                             EIP-2612 STORAGE
  55 |     |     //////////////////////////////////////////////////////////////*/
  56 |     | 
  57 |     |     uint256 internal INITIAL_CHAIN_ID;
  58 |     | 
  59 |     |     bytes32 internal INITIAL_DOMAIN_SEPARATOR;
  60 |     | 
  61 |     |     mapping(address => uint256) public nonces;
  62 |     | 
  63 |     |     /*//////////////////////////////////////////////////////////////
  64 |     |                                INITIALIZE
  65 |     |     //////////////////////////////////////////////////////////////*/
  66 |     | 
  67 |     |     /// @dev A bool to track whether the contract has been initialized.
  68 |     |     bool private initialized;
  69 |     | 
  70 |     |     /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and
  71 |     |     /// syntaxes, we add an initialization function that can be called only once.
  72 |     |     function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {
  73 |     |         require(!initialized, "ALREADY_INITIALIZED");
  74 |     | 
  75 |     |         _name = name_;
  76 |     |         _symbol = symbol_;
  77 |     |         _decimals = decimals_;
  78 |     | 
  79 |     |         INITIAL_CHAIN_ID = _pureChainId();
  80 |     |         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
  81 |     | 
  82 |     |         initialized = true;
  83 |     |     }
  84 |     | 
  85 |     |     /*//////////////////////////////////////////////////////////////
  86 |     |                                ERC20 LOGIC
  87 |     |     //////////////////////////////////////////////////////////////*/
  88 |     | 
  89 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
  90 |     |         _allowance[msg.sender][spender] = amount;
  91 |     | 
  92 |     |         emit Approval(msg.sender, spender, amount);
  93 |     | 
  94 |     |         return true;
  95 |     |     }
  96 |     | 
  97 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
  98 |     |         _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);
  99 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 100 |     | 
 101 |     |         emit Transfer(msg.sender, to, amount);
 102 |     | 
 103 |     |         return true;
 104 |     |     }
 105 |     | 
 106 |     |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 107 |     |         uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.
 108 |     | 
 109 |     |         if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);
 110 |     | 
 111 |     |         _balanceOf[from] = _sub(_balanceOf[from], amount);
 112 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 113 |     | 
 114 |     |         emit Transfer(from, to, amount);
 115 |     | 
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /*//////////////////////////////////////////////////////////////
 120 |     |                              EIP-2612 LOGIC
 121 |     |     //////////////////////////////////////////////////////////////*/
 122 |     | 
 123 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)
 124 |     |         public
 125 |     |         virtual
 126 |     |     {
 127 |     |         require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");
 128 |     | 
 129 |     |         address recoveredAddress = ecrecover(
 130 |     |             keccak256(
 131 |     |                 abi.encodePacked(
 132 |     |                     "\x19\x01",
 133 |     |                     DOMAIN_SEPARATOR(),
 134 |     |                     keccak256(
 135 |     |                         abi.encode(
 136 |     |                             keccak256(
 137 |     |                                 "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
 138 |     |                             ),
 139 |     |                             owner,
 140 |     |                             spender,
 141 |     |                             value,
 142 |     |                             nonces[owner]++,
 143 |     |                             deadline
 144 |     |                         )
 145 |     |                     )
 146 |     |                 )
 147 |     |             ),
 148 |     |             v,
 149 |     |             r,
 150 |     |             s
 151 |     |         );
 152 |     | 
 153 |     |         require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");
 154 |     | 
 155 |     |         _allowance[recoveredAddress][spender] = value;
 156 |     | 
 157 |     |         emit Approval(owner, spender, value);
 158 |     |     }
 159 |     | 
 160 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 161 |     |         return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
 162 |     |     }
 163 |     | 
 164 |     |     function computeDomainSeparator() internal view virtual returns (bytes32) {
 165 |     |         return keccak256(
 166 |     |             abi.encode(
 167 |     |                 keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 168 |     |                 keccak256(bytes(_name)),
 169 |     |                 keccak256("1"),
 170 |     |                 _pureChainId(),
 171 |     |                 address(this)
 172 |     |             )
 173 |     |         );
 174 |     |     }
 175 |     | 
 176 |     |     /*//////////////////////////////////////////////////////////////
 177 |     |                         INTERNAL MINT/BURN LOGIC
 178 |     |     //////////////////////////////////////////////////////////////*/
 179 |     | 
 180 |     |     function _mint(address to, uint256 amount) internal virtual {
 181 |     |         _totalSupply = _add(_totalSupply, amount);
 182 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 183 |     | 
 184 |     |         emit Transfer(address(0), to, amount);
 185 |     |     }
 186 |     | 
 187 |     |     function _burn(address from, uint256 amount) internal virtual {
 188 |     |         _balanceOf[from] = _sub(_balanceOf[from], amount);
 189 |     |         _totalSupply = _sub(_totalSupply, amount);
 190 |     | 
 191 |     |         emit Transfer(from, address(0), amount);
 192 |     |     }
 193 |     | 
 194 |     |     /*//////////////////////////////////////////////////////////////
 195 |     |                         INTERNAL SAFE MATH LOGIC
 196 |     |     //////////////////////////////////////////////////////////////*/
 197 |     | 
 198 |     |     function _add(uint256 a, uint256 b) internal pure returns (uint256) {
 199 |     |         uint256 c = a + b;
 200 |     |         require(c >= a, "ERC20: addition overflow");
 201 |     |         return c;
 202 |     |     }
 203 |     | 
 204 |     |     function _sub(uint256 a, uint256 b) internal pure returns (uint256) {
 205 |     |         require(a >= b, "ERC20: subtraction underflow");
 206 |     |         return a - b;
 207 |     |     }
 208 |     | 
 209 |     |     /*//////////////////////////////////////////////////////////////
 210 |     |                                 HELPERS
 211 |     |     //////////////////////////////////////////////////////////////*/
 212 |     | 
 213 |     |     // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no
 214 |     |     // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We
 215 |     |     // can't simply access the chain ID in a normal view or pure function because the solc View Pure
 216 |     |     // Checker changed `chainid` from pure to view in 0.8.0.
 217 |     |     function _viewChainId() private view returns (uint256 chainId) {
 218 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 219 |     |         assembly {
 220 |     |             chainId := chainid()
 221 |     |         }
 222 |     | 
 223 |     |         address(this); // Silence warnings in older Solc versions.
 224 |     |     }
 225 |     | 
 226 |     |     function _pureChainId() private pure returns (uint256 chainId) {
 227 |     |         function() internal view returns (uint256) fnIn = _viewChainId;
 228 |     |         function() internal pure returns (uint256) pureChainId;
 229 |     |         assembly {
 230 |     |             pureChainId := fnIn
 231 |     |         }
 232 |     |         chainId = pureChainId();
 233 |     |     }
 234 |     | }
 235 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/mocks/MockERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {IERC721Metadata} from "../interfaces/IERC721.sol";
   5 |     | 
   6 |     | /// @notice This is a mock contract of the ERC721 standard for testing purposes only, it SHOULD NOT be used in production.
   7 |     | /// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC721.sol
   8 |     | contract MockERC721 is IERC721Metadata {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                          METADATA STORAGE/LOGIC
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     string internal _name;
  14 |     | 
  15 |     |     string internal _symbol;
  16 |     | 
  17 |     |     function name() external view override returns (string memory) {
  18 |     |         return _name;
  19 |     |     }
  20 |     | 
  21 |     |     function symbol() external view override returns (string memory) {
  22 |     |         return _symbol;
  23 |     |     }
  24 |     | 
  25 |     |     function tokenURI(uint256 id) public view virtual override returns (string memory) {}
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////
  28 |     |                       ERC721 BALANCE/OWNER STORAGE
  29 |     |     //////////////////////////////////////////////////////////////*/
  30 |     | 
  31 |     |     mapping(uint256 => address) internal _ownerOf;
  32 |     | 
  33 |     |     mapping(address => uint256) internal _balanceOf;
  34 |     | 
  35 |     |     function ownerOf(uint256 id) public view virtual override returns (address owner) {
  36 |     |         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");
  37 |     |     }
  38 |     | 
  39 |     |     function balanceOf(address owner) public view virtual override returns (uint256) {
  40 |     |         require(owner != address(0), "ZERO_ADDRESS");
  41 |     | 
  42 |     |         return _balanceOf[owner];
  43 |     |     }
  44 |     | 
  45 |     |     /*//////////////////////////////////////////////////////////////
  46 |     |                          ERC721 APPROVAL STORAGE
  47 |     |     //////////////////////////////////////////////////////////////*/
  48 |     | 
  49 |     |     mapping(uint256 => address) internal _getApproved;
  50 |     | 
  51 |     |     mapping(address => mapping(address => bool)) internal _isApprovedForAll;
  52 |     | 
  53 |     |     function getApproved(uint256 id) public view virtual override returns (address) {
  54 |     |         return _getApproved[id];
  55 |     |     }
  56 |     | 
  57 |     |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
  58 |     |         return _isApprovedForAll[owner][operator];
  59 |     |     }
  60 |     | 
  61 |     |     /*//////////////////////////////////////////////////////////////
  62 |     |                                INITIALIZE
  63 |     |     //////////////////////////////////////////////////////////////*/
  64 |     | 
  65 |     |     /// @dev A bool to track whether the contract has been initialized.
  66 |     |     bool private initialized;
  67 |     | 
  68 |     |     /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and
  69 |     |     /// syntaxes, we add an initialization function that can be called only once.
  70 |     |     function initialize(string memory name_, string memory symbol_) public {
  71 |     |         require(!initialized, "ALREADY_INITIALIZED");
  72 |     | 
  73 |     |         _name = name_;
  74 |     |         _symbol = symbol_;
  75 |     | 
  76 |     |         initialized = true;
  77 |     |     }
  78 |     | 
  79 |     |     /*//////////////////////////////////////////////////////////////
  80 |     |                               ERC721 LOGIC
  81 |     |     //////////////////////////////////////////////////////////////*/
  82 |     | 
  83 |     |     function approve(address spender, uint256 id) public payable virtual override {
  84 |     |         address owner = _ownerOf[id];
  85 |     | 
  86 |     |         require(msg.sender == owner || _isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");
  87 |     | 
  88 |     |         _getApproved[id] = spender;
  89 |     | 
  90 |     |         emit Approval(owner, spender, id);
  91 |     |     }
  92 |     | 
  93 |     |     function setApprovalForAll(address operator, bool approved) public virtual override {
  94 |     |         _isApprovedForAll[msg.sender][operator] = approved;
  95 |     | 
  96 |     |         emit ApprovalForAll(msg.sender, operator, approved);
  97 |     |     }
  98 |     | 
  99 |     |     function transferFrom(address from, address to, uint256 id) public payable virtual override {
 100 |     |         require(from == _ownerOf[id], "WRONG_FROM");
 101 |     | 
 102 |     |         require(to != address(0), "INVALID_RECIPIENT");
 103 |     | 
 104 |     |         require(
 105 |     |             msg.sender == from || _isApprovedForAll[from][msg.sender] || msg.sender == _getApproved[id],
 106 |     |             "NOT_AUTHORIZED"
 107 |     |         );
 108 |     | 
 109 |     |         // Underflow of the sender's balance is impossible because we check for
 110 |     |         // ownership above and the recipient's balance can't realistically overflow.
 111 |     |         _balanceOf[from]--;
 112 |     | 
 113 |     |         _balanceOf[to]++;
 114 |     | 
 115 |     |         _ownerOf[id] = to;
 116 |     | 
 117 |     |         delete _getApproved[id];
 118 |     | 
 119 |     |         emit Transfer(from, to, id);
 120 |     |     }
 121 |     | 
 122 |     |     function safeTransferFrom(address from, address to, uint256 id) public payable virtual override {
 123 |     |         transferFrom(from, to, id);
 124 |     | 
 125 |     |         require(
 126 |     |             !_isContract(to)
 127 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "")
 128 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 129 |     |             "UNSAFE_RECIPIENT"
 130 |     |         );
 131 |     |     }
 132 |     | 
 133 |     |     function safeTransferFrom(address from, address to, uint256 id, bytes memory data)
 134 |     |         public
 135 |     |         payable
 136 |     |         virtual
 137 |     |         override
 138 |     |     {
 139 |     |         transferFrom(from, to, id);
 140 |     | 
 141 |     |         require(
 142 |     |             !_isContract(to)
 143 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)
 144 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 145 |     |             "UNSAFE_RECIPIENT"
 146 |     |         );
 147 |     |     }
 148 |     | 
 149 |     |     /*//////////////////////////////////////////////////////////////
 150 |     |                               ERC165 LOGIC
 151 |     |     //////////////////////////////////////////////////////////////*/
 152 |     | 
 153 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 154 |     |         return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165
 155 |     |             || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721
 156 |     |             || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata
 157 |     |     }
 158 |     | 
 159 |     |     /*//////////////////////////////////////////////////////////////
 160 |     |                         INTERNAL MINT/BURN LOGIC
 161 |     |     //////////////////////////////////////////////////////////////*/
 162 |     | 
 163 |     |     function _mint(address to, uint256 id) internal virtual {
 164 |     |         require(to != address(0), "INVALID_RECIPIENT");
 165 |     | 
 166 |     |         require(_ownerOf[id] == address(0), "ALREADY_MINTED");
 167 |     | 
 168 |     |         // Counter overflow is incredibly unrealistic.
 169 |     | 
 170 |     |         _balanceOf[to]++;
 171 |     | 
 172 |     |         _ownerOf[id] = to;
 173 |     | 
 174 |     |         emit Transfer(address(0), to, id);
 175 |     |     }
 176 |     | 
 177 |     |     function _burn(uint256 id) internal virtual {
 178 |     |         address owner = _ownerOf[id];
 179 |     | 
 180 |     |         require(owner != address(0), "NOT_MINTED");
 181 |     | 
 182 |     |         _balanceOf[owner]--;
 183 |     | 
 184 |     |         delete _ownerOf[id];
 185 |     | 
 186 |     |         delete _getApproved[id];
 187 |     | 
 188 |     |         emit Transfer(owner, address(0), id);
 189 |     |     }
 190 |     | 
 191 |     |     /*//////////////////////////////////////////////////////////////
 192 |     |                         INTERNAL SAFE MINT LOGIC
 193 |     |     //////////////////////////////////////////////////////////////*/
 194 |     | 
 195 |     |     function _safeMint(address to, uint256 id) internal virtual {
 196 |     |         _mint(to, id);
 197 |     | 
 198 |     |         require(
 199 |     |             !_isContract(to)
 200 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
 201 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 202 |     |             "UNSAFE_RECIPIENT"
 203 |     |         );
 204 |     |     }
 205 |     | 
 206 |     |     function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
 207 |     |         _mint(to, id);
 208 |     | 
 209 |     |         require(
 210 |     |             !_isContract(to)
 211 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
 212 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 213 |     |             "UNSAFE_RECIPIENT"
 214 |     |         );
 215 |     |     }
 216 |     | 
 217 |     |     /*//////////////////////////////////////////////////////////////
 218 |     |                                 HELPERS
 219 |     |     //////////////////////////////////////////////////////////////*/
 220 |     | 
 221 |     |     function _isContract(address _addr) private view returns (bool) {
 222 |     |         uint256 codeLength;
 223 |     | 
 224 |     |         // Assembly required for versions < 0.8.0 to check extcodesize.
 225 |     |         assembly {
 226 |     |             codeLength := extcodesize(_addr)
 227 |     |         }
 228 |     | 
 229 |     |         return codeLength > 0;
 230 |     |     }
 231 |     | }
 232 |     | 
 233 |     | interface IERC721TokenReceiver {
 234 |     |     function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4);
 235 |     | }
 236 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/forge-std/src/safeconsole.sol
     1 |     | // SPDX-License-Identifier: MIT
     2 |     | pragma solidity >=0.6.2 <0.9.0;
     3 |     | 
     4 |     | /// @author philogy <https://github.com/philogy>
     5 |     | /// @dev Code generated automatically by script.
     6 |     | library safeconsole {
     7 |     |     uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;
     8 |     | 
     9 |     |     // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)
    10 |     |     // for the view-to-pure log trick.
    11 |     |     function _sendLogPayload(uint256 offset, uint256 size) private pure {
    12 |     |         function(uint256, uint256) internal view fnIn = _sendLogPayloadView;
    13 |     |         function(uint256, uint256) internal pure pureSendLogPayload;
    14 |     |         assembly {
    15 |     |             pureSendLogPayload := fnIn
    16 |     |         }
    17 |     |         pureSendLogPayload(offset, size);
    18 |     |     }
    19 |     | 
    20 |     |     function _sendLogPayloadView(uint256 offset, uint256 size) private view {
    21 |     |         assembly {
    22 |     |             pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))
    23 |     |         }
    24 |     |     }
    25 |     | 
    26 |     |     function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {
    27 |     |         function(uint256, uint256, uint256) internal view fnIn = _memcopyView;
    28 |     |         function(uint256, uint256, uint256) internal pure pureMemcopy;
    29 |     |         assembly {
    30 |     |             pureMemcopy := fnIn
    31 |     |         }
    32 |     |         pureMemcopy(fromOffset, toOffset, length);
    33 |     |     }
    34 |     | 
    35 |     |     function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {
    36 |     |         assembly {
    37 |     |             pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))
    38 |     |         }
    39 |     |     }
    40 |     | 
    41 |     |     function logMemory(uint256 offset, uint256 length) internal pure {
    42 |     |         if (offset >= 0x60) {
    43 |     |             // Sufficient memory before slice to prepare call header.
    44 |     |             bytes32 m0;
    45 |     |             bytes32 m1;
    46 |     |             bytes32 m2;
    47 |     |             assembly {
    48 |     |                 m0 := mload(sub(offset, 0x60))
    49 |     |                 m1 := mload(sub(offset, 0x40))
    50 |     |                 m2 := mload(sub(offset, 0x20))
    51 |     |                 // Selector of `logBytes(bytes)`.
    52 |     |                 mstore(sub(offset, 0x60), 0xe17bf956)
    53 |     |                 mstore(sub(offset, 0x40), 0x20)
    54 |     |                 mstore(sub(offset, 0x20), length)
    55 |     |             }
    56 |     |             _sendLogPayload(offset - 0x44, length + 0x44);
    57 |     |             assembly {
    58 |     |                 mstore(sub(offset, 0x60), m0)
    59 |     |                 mstore(sub(offset, 0x40), m1)
    60 |     |                 mstore(sub(offset, 0x20), m2)
    61 |     |             }
    62 |     |         } else {
    63 |     |             // Insufficient space, so copy slice forward, add header and reverse.
    64 |     |             bytes32 m0;
    65 |     |             bytes32 m1;
    66 |     |             bytes32 m2;
    67 |     |             uint256 endOffset = offset + length;
    68 |     |             assembly {
    69 |     |                 m0 := mload(add(endOffset, 0x00))
    70 |     |                 m1 := mload(add(endOffset, 0x20))
    71 |     |                 m2 := mload(add(endOffset, 0x40))
    72 |     |             }
    73 |     |             _memcopy(offset, offset + 0x60, length);
    74 |     |             assembly {
    75 |     |                 // Selector of `logBytes(bytes)`.
    76 |     |                 mstore(add(offset, 0x00), 0xe17bf956)
    77 |     |                 mstore(add(offset, 0x20), 0x20)
    78 |     |                 mstore(add(offset, 0x40), length)
    79 |     |             }
    80 |     |             _sendLogPayload(offset + 0x1c, length + 0x44);
    81 |     |             _memcopy(offset + 0x60, offset, length);
    82 |     |             assembly {
    83 |     |                 mstore(add(endOffset, 0x00), m0)
    84 |     |                 mstore(add(endOffset, 0x20), m1)
    85 |     |                 mstore(add(endOffset, 0x40), m2)
    86 |     |             }
    87 |     |         }
    88 |     |     }
    89 |     | 
    90 |     |     function log(address p0) internal pure {
    91 |     |         bytes32 m0;
    92 |     |         bytes32 m1;
    93 |     |         assembly {
    94 |     |             m0 := mload(0x00)
    95 |     |             m1 := mload(0x20)
    96 |     |             // Selector of `log(address)`.
    97 |     |             mstore(0x00, 0x2c2ecbc2)
    98 |     |             mstore(0x20, p0)
    99 |     |         }
   100 |     |         _sendLogPayload(0x1c, 0x24);
   101 |     |         assembly {
   102 |     |             mstore(0x00, m0)
   103 |     |             mstore(0x20, m1)
   104 |     |         }
   105 |     |     }
   106 |     | 
   107 |     |     function log(bool p0) internal pure {
   108 |     |         bytes32 m0;
   109 |     |         bytes32 m1;
   110 |     |         assembly {
   111 |     |             m0 := mload(0x00)
   112 |     |             m1 := mload(0x20)
   113 |     |             // Selector of `log(bool)`.
   114 |     |             mstore(0x00, 0x32458eed)
   115 |     |             mstore(0x20, p0)
   116 |     |         }
   117 |     |         _sendLogPayload(0x1c, 0x24);
   118 |     |         assembly {
   119 |     |             mstore(0x00, m0)
   120 |     |             mstore(0x20, m1)
   121 |     |         }
   122 |     |     }
   123 |     | 
   124 |     |     function log(uint256 p0) internal pure {
   125 |     |         bytes32 m0;
   126 |     |         bytes32 m1;
   127 |     |         assembly {
   128 |     |             m0 := mload(0x00)
   129 |     |             m1 := mload(0x20)
   130 |     |             // Selector of `log(uint256)`.
   131 |     |             mstore(0x00, 0xf82c50f1)
   132 |     |             mstore(0x20, p0)
   133 |     |         }
   134 |     |         _sendLogPayload(0x1c, 0x24);
   135 |     |         assembly {
   136 |     |             mstore(0x00, m0)
   137 |     |             mstore(0x20, m1)
   138 |     |         }
   139 |     |     }
   140 |     | 
   141 |     |     function log(bytes32 p0) internal pure {
   142 |     |         bytes32 m0;
   143 |     |         bytes32 m1;
   144 |     |         bytes32 m2;
   145 |     |         bytes32 m3;
   146 |     |         assembly {
   147 |     |             function writeString(pos, w) {
   148 |     |                 let length := 0
   149 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   150 |     |                 mstore(pos, length)
   151 |     |                 let shift := sub(256, shl(3, length))
   152 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   153 |     |             }
   154 |     |             m0 := mload(0x00)
   155 |     |             m1 := mload(0x20)
   156 |     |             m2 := mload(0x40)
   157 |     |             m3 := mload(0x60)
   158 |     |             // Selector of `log(string)`.
   159 |     |             mstore(0x00, 0x41304fac)
   160 |     |             mstore(0x20, 0x20)
   161 |     |             writeString(0x40, p0)
   162 |     |         }
   163 |     |         _sendLogPayload(0x1c, 0x64);
   164 |     |         assembly {
   165 |     |             mstore(0x00, m0)
   166 |     |             mstore(0x20, m1)
   167 |     |             mstore(0x40, m2)
   168 |     |             mstore(0x60, m3)
   169 |     |         }
   170 |     |     }
   171 |     | 
   172 |     |     function log(address p0, address p1) internal pure {
   173 |     |         bytes32 m0;
   174 |     |         bytes32 m1;
   175 |     |         bytes32 m2;
   176 |     |         assembly {
   177 |     |             m0 := mload(0x00)
   178 |     |             m1 := mload(0x20)
   179 |     |             m2 := mload(0x40)
   180 |     |             // Selector of `log(address,address)`.
   181 |     |             mstore(0x00, 0xdaf0d4aa)
   182 |     |             mstore(0x20, p0)
   183 |     |             mstore(0x40, p1)
   184 |     |         }
   185 |     |         _sendLogPayload(0x1c, 0x44);
   186 |     |         assembly {
   187 |     |             mstore(0x00, m0)
   188 |     |             mstore(0x20, m1)
   189 |     |             mstore(0x40, m2)
   190 |     |         }
   191 |     |     }
   192 |     | 
   193 |     |     function log(address p0, bool p1) internal pure {
   194 |     |         bytes32 m0;
   195 |     |         bytes32 m1;
   196 |     |         bytes32 m2;
   197 |     |         assembly {
   198 |     |             m0 := mload(0x00)
   199 |     |             m1 := mload(0x20)
   200 |     |             m2 := mload(0x40)
   201 |     |             // Selector of `log(address,bool)`.
   202 |     |             mstore(0x00, 0x75b605d3)
   203 |     |             mstore(0x20, p0)
   204 |     |             mstore(0x40, p1)
   205 |     |         }
   206 |     |         _sendLogPayload(0x1c, 0x44);
   207 |     |         assembly {
   208 |     |             mstore(0x00, m0)
   209 |     |             mstore(0x20, m1)
   210 |     |             mstore(0x40, m2)
   211 |     |         }
   212 |     |     }
   213 |     | 
   214 |     |     function log(address p0, uint256 p1) internal pure {
   215 |     |         bytes32 m0;
   216 |     |         bytes32 m1;
   217 |     |         bytes32 m2;
   218 |     |         assembly {
   219 |     |             m0 := mload(0x00)
   220 |     |             m1 := mload(0x20)
   221 |     |             m2 := mload(0x40)
   222 |     |             // Selector of `log(address,uint256)`.
   223 |     |             mstore(0x00, 0x8309e8a8)
   224 |     |             mstore(0x20, p0)
   225 |     |             mstore(0x40, p1)
   226 |     |         }
   227 |     |         _sendLogPayload(0x1c, 0x44);
   228 |     |         assembly {
   229 |     |             mstore(0x00, m0)
   230 |     |             mstore(0x20, m1)
   231 |     |             mstore(0x40, m2)
   232 |     |         }
   233 |     |     }
   234 |     | 
   235 |     |     function log(address p0, bytes32 p1) internal pure {
   236 |     |         bytes32 m0;
   237 |     |         bytes32 m1;
   238 |     |         bytes32 m2;
   239 |     |         bytes32 m3;
   240 |     |         bytes32 m4;
   241 |     |         assembly {
   242 |     |             function writeString(pos, w) {
   243 |     |                 let length := 0
   244 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   245 |     |                 mstore(pos, length)
   246 |     |                 let shift := sub(256, shl(3, length))
   247 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   248 |     |             }
   249 |     |             m0 := mload(0x00)
   250 |     |             m1 := mload(0x20)
   251 |     |             m2 := mload(0x40)
   252 |     |             m3 := mload(0x60)
   253 |     |             m4 := mload(0x80)
   254 |     |             // Selector of `log(address,string)`.
   255 |     |             mstore(0x00, 0x759f86bb)
   256 |     |             mstore(0x20, p0)
   257 |     |             mstore(0x40, 0x40)
   258 |     |             writeString(0x60, p1)
   259 |     |         }
   260 |     |         _sendLogPayload(0x1c, 0x84);
   261 |     |         assembly {
   262 |     |             mstore(0x00, m0)
   263 |     |             mstore(0x20, m1)
   264 |     |             mstore(0x40, m2)
   265 |     |             mstore(0x60, m3)
   266 |     |             mstore(0x80, m4)
   267 |     |         }
   268 |     |     }
   269 |     | 
   270 |     |     function log(bool p0, address p1) internal pure {
   271 |     |         bytes32 m0;
   272 |     |         bytes32 m1;
   273 |     |         bytes32 m2;
   274 |     |         assembly {
   275 |     |             m0 := mload(0x00)
   276 |     |             m1 := mload(0x20)
   277 |     |             m2 := mload(0x40)
   278 |     |             // Selector of `log(bool,address)`.
   279 |     |             mstore(0x00, 0x853c4849)
   280 |     |             mstore(0x20, p0)
   281 |     |             mstore(0x40, p1)
   282 |     |         }
   283 |     |         _sendLogPayload(0x1c, 0x44);
   284 |     |         assembly {
   285 |     |             mstore(0x00, m0)
   286 |     |             mstore(0x20, m1)
   287 |     |             mstore(0x40, m2)
   288 |     |         }
   289 |     |     }
   290 |     | 
   291 |     |     function log(bool p0, bool p1) internal pure {
   292 |     |         bytes32 m0;
   293 |     |         bytes32 m1;
   294 |     |         bytes32 m2;
   295 |     |         assembly {
   296 |     |             m0 := mload(0x00)
   297 |     |             m1 := mload(0x20)
   298 |     |             m2 := mload(0x40)
   299 |     |             // Selector of `log(bool,bool)`.
   300 |     |             mstore(0x00, 0x2a110e83)
   301 |     |             mstore(0x20, p0)
   302 |     |             mstore(0x40, p1)
   303 |     |         }
   304 |     |         _sendLogPayload(0x1c, 0x44);
   305 |     |         assembly {
   306 |     |             mstore(0x00, m0)
   307 |     |             mstore(0x20, m1)
   308 |     |             mstore(0x40, m2)
   309 |     |         }
   310 |     |     }
   311 |     | 
   312 |     |     function log(bool p0, uint256 p1) internal pure {
   313 |     |         bytes32 m0;
   314 |     |         bytes32 m1;
   315 |     |         bytes32 m2;
   316 |     |         assembly {
   317 |     |             m0 := mload(0x00)
   318 |     |             m1 := mload(0x20)
   319 |     |             m2 := mload(0x40)
   320 |     |             // Selector of `log(bool,uint256)`.
   321 |     |             mstore(0x00, 0x399174d3)
   322 |     |             mstore(0x20, p0)
   323 |     |             mstore(0x40, p1)
   324 |     |         }
   325 |     |         _sendLogPayload(0x1c, 0x44);
   326 |     |         assembly {
   327 |     |             mstore(0x00, m0)
   328 |     |             mstore(0x20, m1)
   329 |     |             mstore(0x40, m2)
   330 |     |         }
   331 |     |     }
   332 |     | 
   333 |     |     function log(bool p0, bytes32 p1) internal pure {
   334 |     |         bytes32 m0;
   335 |     |         bytes32 m1;
   336 |     |         bytes32 m2;
   337 |     |         bytes32 m3;
   338 |     |         bytes32 m4;
   339 |     |         assembly {
   340 |     |             function writeString(pos, w) {
   341 |     |                 let length := 0
   342 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   343 |     |                 mstore(pos, length)
   344 |     |                 let shift := sub(256, shl(3, length))
   345 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   346 |     |             }
   347 |     |             m0 := mload(0x00)
   348 |     |             m1 := mload(0x20)
   349 |     |             m2 := mload(0x40)
   350 |     |             m3 := mload(0x60)
   351 |     |             m4 := mload(0x80)
   352 |     |             // Selector of `log(bool,string)`.
   353 |     |             mstore(0x00, 0x8feac525)
   354 |     |             mstore(0x20, p0)
   355 |     |             mstore(0x40, 0x40)
   356 |     |             writeString(0x60, p1)
   357 |     |         }
   358 |     |         _sendLogPayload(0x1c, 0x84);
   359 |     |         assembly {
   360 |     |             mstore(0x00, m0)
   361 |     |             mstore(0x20, m1)
   362 |     |             mstore(0x40, m2)
   363 |     |             mstore(0x60, m3)
   364 |     |             mstore(0x80, m4)
   365 |     |         }
   366 |     |     }
   367 |     | 
   368 |     |     function log(uint256 p0, address p1) internal pure {
   369 |     |         bytes32 m0;
   370 |     |         bytes32 m1;
   371 |     |         bytes32 m2;
   372 |     |         assembly {
   373 |     |             m0 := mload(0x00)
   374 |     |             m1 := mload(0x20)
   375 |     |             m2 := mload(0x40)
   376 |     |             // Selector of `log(uint256,address)`.
   377 |     |             mstore(0x00, 0x69276c86)
   378 |     |             mstore(0x20, p0)
   379 |     |             mstore(0x40, p1)
   380 |     |         }
   381 |     |         _sendLogPayload(0x1c, 0x44);
   382 |     |         assembly {
   383 |     |             mstore(0x00, m0)
   384 |     |             mstore(0x20, m1)
   385 |     |             mstore(0x40, m2)
   386 |     |         }
   387 |     |     }
   388 |     | 
   389 |     |     function log(uint256 p0, bool p1) internal pure {
   390 |     |         bytes32 m0;
   391 |     |         bytes32 m1;
   392 |     |         bytes32 m2;
   393 |     |         assembly {
   394 |     |             m0 := mload(0x00)
   395 |     |             m1 := mload(0x20)
   396 |     |             m2 := mload(0x40)
   397 |     |             // Selector of `log(uint256,bool)`.
   398 |     |             mstore(0x00, 0x1c9d7eb3)
   399 |     |             mstore(0x20, p0)
   400 |     |             mstore(0x40, p1)
   401 |     |         }
   402 |     |         _sendLogPayload(0x1c, 0x44);
   403 |     |         assembly {
   404 |     |             mstore(0x00, m0)
   405 |     |             mstore(0x20, m1)
   406 |     |             mstore(0x40, m2)
   407 |     |         }
   408 |     |     }
   409 |     | 
   410 |     |     function log(uint256 p0, uint256 p1) internal pure {
   411 |     |         bytes32 m0;
   412 |     |         bytes32 m1;
   413 |     |         bytes32 m2;
   414 |     |         assembly {
   415 |     |             m0 := mload(0x00)
   416 |     |             m1 := mload(0x20)
   417 |     |             m2 := mload(0x40)
   418 |     |             // Selector of `log(uint256,uint256)`.
   419 |     |             mstore(0x00, 0xf666715a)
   420 |     |             mstore(0x20, p0)
   421 |     |             mstore(0x40, p1)
   422 |     |         }
   423 |     |         _sendLogPayload(0x1c, 0x44);
   424 |     |         assembly {
   425 |     |             mstore(0x00, m0)
   426 |     |             mstore(0x20, m1)
   427 |     |             mstore(0x40, m2)
   428 |     |         }
   429 |     |     }
   430 |     | 
   431 |     |     function log(uint256 p0, bytes32 p1) internal pure {
   432 |     |         bytes32 m0;
   433 |     |         bytes32 m1;
   434 |     |         bytes32 m2;
   435 |     |         bytes32 m3;
   436 |     |         bytes32 m4;
   437 |     |         assembly {
   438 |     |             function writeString(pos, w) {
   439 |     |                 let length := 0
   440 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   441 |     |                 mstore(pos, length)
   442 |     |                 let shift := sub(256, shl(3, length))
   443 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   444 |     |             }
   445 |     |             m0 := mload(0x00)
   446 |     |             m1 := mload(0x20)
   447 |     |             m2 := mload(0x40)
   448 |     |             m3 := mload(0x60)
   449 |     |             m4 := mload(0x80)
   450 |     |             // Selector of `log(uint256,string)`.
   451 |     |             mstore(0x00, 0x643fd0df)
   452 |     |             mstore(0x20, p0)
   453 |     |             mstore(0x40, 0x40)
   454 |     |             writeString(0x60, p1)
   455 |     |         }
   456 |     |         _sendLogPayload(0x1c, 0x84);
   457 |     |         assembly {
   458 |     |             mstore(0x00, m0)
   459 |     |             mstore(0x20, m1)
   460 |     |             mstore(0x40, m2)
   461 |     |             mstore(0x60, m3)
   462 |     |             mstore(0x80, m4)
   463 |     |         }
   464 |     |     }
   465 |     | 
   466 |     |     function log(bytes32 p0, address p1) internal pure {
   467 |     |         bytes32 m0;
   468 |     |         bytes32 m1;
   469 |     |         bytes32 m2;
   470 |     |         bytes32 m3;
   471 |     |         bytes32 m4;
   472 |     |         assembly {
   473 |     |             function writeString(pos, w) {
   474 |     |                 let length := 0
   475 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   476 |     |                 mstore(pos, length)
   477 |     |                 let shift := sub(256, shl(3, length))
   478 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   479 |     |             }
   480 |     |             m0 := mload(0x00)
   481 |     |             m1 := mload(0x20)
   482 |     |             m2 := mload(0x40)
   483 |     |             m3 := mload(0x60)
   484 |     |             m4 := mload(0x80)
   485 |     |             // Selector of `log(string,address)`.
   486 |     |             mstore(0x00, 0x319af333)
   487 |     |             mstore(0x20, 0x40)
   488 |     |             mstore(0x40, p1)
   489 |     |             writeString(0x60, p0)
   490 |     |         }
   491 |     |         _sendLogPayload(0x1c, 0x84);
   492 |     |         assembly {
   493 |     |             mstore(0x00, m0)
   494 |     |             mstore(0x20, m1)
   495 |     |             mstore(0x40, m2)
   496 |     |             mstore(0x60, m3)
   497 |     |             mstore(0x80, m4)
   498 |     |         }
   499 |     |     }
   500 |     | 
   501 |     |     function log(bytes32 p0, bool p1) internal pure {
   502 |     |         bytes32 m0;
   503 |     |         bytes32 m1;
   504 |     |         bytes32 m2;
   505 |     |         bytes32 m3;
   506 |     |         bytes32 m4;
   507 |     |         assembly {
   508 |     |             function writeString(pos, w) {
   509 |     |                 let length := 0
   510 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   511 |     |                 mstore(pos, length)
   512 |     |                 let shift := sub(256, shl(3, length))
   513 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   514 |     |             }
   515 |     |             m0 := mload(0x00)
   516 |     |             m1 := mload(0x20)
   517 |     |             m2 := mload(0x40)
   518 |     |             m3 := mload(0x60)
   519 |     |             m4 := mload(0x80)
   520 |     |             // Selector of `log(string,bool)`.
   521 |     |             mstore(0x00, 0xc3b55635)
   522 |     |             mstore(0x20, 0x40)
   523 |     |             mstore(0x40, p1)
   524 |     |             writeString(0x60, p0)
   525 |     |         }
   526 |     |         _sendLogPayload(0x1c, 0x84);
   527 |     |         assembly {
   528 |     |             mstore(0x00, m0)
   529 |     |             mstore(0x20, m1)
   530 |     |             mstore(0x40, m2)
   531 |     |             mstore(0x60, m3)
   532 |     |             mstore(0x80, m4)
   533 |     |         }
   534 |     |     }
   535 |     | 
   536 |     |     function log(bytes32 p0, uint256 p1) internal pure {
   537 |     |         bytes32 m0;
   538 |     |         bytes32 m1;
   539 |     |         bytes32 m2;
   540 |     |         bytes32 m3;
   541 |     |         bytes32 m4;
   542 |     |         assembly {
   543 |     |             function writeString(pos, w) {
   544 |     |                 let length := 0
   545 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   546 |     |                 mstore(pos, length)
   547 |     |                 let shift := sub(256, shl(3, length))
   548 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   549 |     |             }
   550 |     |             m0 := mload(0x00)
   551 |     |             m1 := mload(0x20)
   552 |     |             m2 := mload(0x40)
   553 |     |             m3 := mload(0x60)
   554 |     |             m4 := mload(0x80)
   555 |     |             // Selector of `log(string,uint256)`.
   556 |     |             mstore(0x00, 0xb60e72cc)
   557 |     |             mstore(0x20, 0x40)
   558 |     |             mstore(0x40, p1)
   559 |     |             writeString(0x60, p0)
   560 |     |         }
   561 |     |         _sendLogPayload(0x1c, 0x84);
   562 |     |         assembly {
   563 |     |             mstore(0x00, m0)
   564 |     |             mstore(0x20, m1)
   565 |     |             mstore(0x40, m2)
   566 |     |             mstore(0x60, m3)
   567 |     |             mstore(0x80, m4)
   568 |     |         }
   569 |     |     }
   570 |     | 
   571 |     |     function log(bytes32 p0, bytes32 p1) internal pure {
   572 |     |         bytes32 m0;
   573 |     |         bytes32 m1;
   574 |     |         bytes32 m2;
   575 |     |         bytes32 m3;
   576 |     |         bytes32 m4;
   577 |     |         bytes32 m5;
   578 |     |         bytes32 m6;
   579 |     |         assembly {
   580 |     |             function writeString(pos, w) {
   581 |     |                 let length := 0
   582 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   583 |     |                 mstore(pos, length)
   584 |     |                 let shift := sub(256, shl(3, length))
   585 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   586 |     |             }
   587 |     |             m0 := mload(0x00)
   588 |     |             m1 := mload(0x20)
   589 |     |             m2 := mload(0x40)
   590 |     |             m3 := mload(0x60)
   591 |     |             m4 := mload(0x80)
   592 |     |             m5 := mload(0xa0)
   593 |     |             m6 := mload(0xc0)
   594 |     |             // Selector of `log(string,string)`.
   595 |     |             mstore(0x00, 0x4b5c4277)
   596 |     |             mstore(0x20, 0x40)
   597 |     |             mstore(0x40, 0x80)
   598 |     |             writeString(0x60, p0)
   599 |     |             writeString(0xa0, p1)
   600 |     |         }
   601 |     |         _sendLogPayload(0x1c, 0xc4);
   602 |     |         assembly {
   603 |     |             mstore(0x00, m0)
   604 |     |             mstore(0x20, m1)
   605 |     |             mstore(0x40, m2)
   606 |     |             mstore(0x60, m3)
   607 |     |             mstore(0x80, m4)
   608 |     |             mstore(0xa0, m5)
   609 |     |             mstore(0xc0, m6)
   610 |     |         }
   611 |     |     }
   612 |     | 
   613 |     |     function log(address p0, address p1, address p2) internal pure {
   614 |     |         bytes32 m0;
   615 |     |         bytes32 m1;
   616 |     |         bytes32 m2;
   617 |     |         bytes32 m3;
   618 |     |         assembly {
   619 |     |             m0 := mload(0x00)
   620 |     |             m1 := mload(0x20)
   621 |     |             m2 := mload(0x40)
   622 |     |             m3 := mload(0x60)
   623 |     |             // Selector of `log(address,address,address)`.
   624 |     |             mstore(0x00, 0x018c84c2)
   625 |     |             mstore(0x20, p0)
   626 |     |             mstore(0x40, p1)
   627 |     |             mstore(0x60, p2)
   628 |     |         }
   629 |     |         _sendLogPayload(0x1c, 0x64);
   630 |     |         assembly {
   631 |     |             mstore(0x00, m0)
   632 |     |             mstore(0x20, m1)
   633 |     |             mstore(0x40, m2)
   634 |     |             mstore(0x60, m3)
   635 |     |         }
   636 |     |     }
   637 |     | 
   638 |     |     function log(address p0, address p1, bool p2) internal pure {
   639 |     |         bytes32 m0;
   640 |     |         bytes32 m1;
   641 |     |         bytes32 m2;
   642 |     |         bytes32 m3;
   643 |     |         assembly {
   644 |     |             m0 := mload(0x00)
   645 |     |             m1 := mload(0x20)
   646 |     |             m2 := mload(0x40)
   647 |     |             m3 := mload(0x60)
   648 |     |             // Selector of `log(address,address,bool)`.
   649 |     |             mstore(0x00, 0xf2a66286)
   650 |     |             mstore(0x20, p0)
   651 |     |             mstore(0x40, p1)
   652 |     |             mstore(0x60, p2)
   653 |     |         }
   654 |     |         _sendLogPayload(0x1c, 0x64);
   655 |     |         assembly {
   656 |     |             mstore(0x00, m0)
   657 |     |             mstore(0x20, m1)
   658 |     |             mstore(0x40, m2)
   659 |     |             mstore(0x60, m3)
   660 |     |         }
   661 |     |     }
   662 |     | 
   663 |     |     function log(address p0, address p1, uint256 p2) internal pure {
   664 |     |         bytes32 m0;
   665 |     |         bytes32 m1;
   666 |     |         bytes32 m2;
   667 |     |         bytes32 m3;
   668 |     |         assembly {
   669 |     |             m0 := mload(0x00)
   670 |     |             m1 := mload(0x20)
   671 |     |             m2 := mload(0x40)
   672 |     |             m3 := mload(0x60)
   673 |     |             // Selector of `log(address,address,uint256)`.
   674 |     |             mstore(0x00, 0x17fe6185)
   675 |     |             mstore(0x20, p0)
   676 |     |             mstore(0x40, p1)
   677 |     |             mstore(0x60, p2)
   678 |     |         }
   679 |     |         _sendLogPayload(0x1c, 0x64);
   680 |     |         assembly {
   681 |     |             mstore(0x00, m0)
   682 |     |             mstore(0x20, m1)
   683 |     |             mstore(0x40, m2)
   684 |     |             mstore(0x60, m3)
   685 |     |         }
   686 |     |     }
   687 |     | 
   688 |     |     function log(address p0, address p1, bytes32 p2) internal pure {
   689 |     |         bytes32 m0;
   690 |     |         bytes32 m1;
   691 |     |         bytes32 m2;
   692 |     |         bytes32 m3;
   693 |     |         bytes32 m4;
   694 |     |         bytes32 m5;
   695 |     |         assembly {
   696 |     |             function writeString(pos, w) {
   697 |     |                 let length := 0
   698 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   699 |     |                 mstore(pos, length)
   700 |     |                 let shift := sub(256, shl(3, length))
   701 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   702 |     |             }
   703 |     |             m0 := mload(0x00)
   704 |     |             m1 := mload(0x20)
   705 |     |             m2 := mload(0x40)
   706 |     |             m3 := mload(0x60)
   707 |     |             m4 := mload(0x80)
   708 |     |             m5 := mload(0xa0)
   709 |     |             // Selector of `log(address,address,string)`.
   710 |     |             mstore(0x00, 0x007150be)
   711 |     |             mstore(0x20, p0)
   712 |     |             mstore(0x40, p1)
   713 |     |             mstore(0x60, 0x60)
   714 |     |             writeString(0x80, p2)
   715 |     |         }
   716 |     |         _sendLogPayload(0x1c, 0xa4);
   717 |     |         assembly {
   718 |     |             mstore(0x00, m0)
   719 |     |             mstore(0x20, m1)
   720 |     |             mstore(0x40, m2)
   721 |     |             mstore(0x60, m3)
   722 |     |             mstore(0x80, m4)
   723 |     |             mstore(0xa0, m5)
   724 |     |         }
   725 |     |     }
   726 |     | 
   727 |     |     function log(address p0, bool p1, address p2) internal pure {
   728 |     |         bytes32 m0;
   729 |     |         bytes32 m1;
   730 |     |         bytes32 m2;
   731 |     |         bytes32 m3;
   732 |     |         assembly {
   733 |     |             m0 := mload(0x00)
   734 |     |             m1 := mload(0x20)
   735 |     |             m2 := mload(0x40)
   736 |     |             m3 := mload(0x60)
   737 |     |             // Selector of `log(address,bool,address)`.
   738 |     |             mstore(0x00, 0xf11699ed)
   739 |     |             mstore(0x20, p0)
   740 |     |             mstore(0x40, p1)
   741 |     |             mstore(0x60, p2)
   742 |     |         }
   743 |     |         _sendLogPayload(0x1c, 0x64);
   744 |     |         assembly {
   745 |     |             mstore(0x00, m0)
   746 |     |             mstore(0x20, m1)
   747 |     |             mstore(0x40, m2)
   748 |     |             mstore(0x60, m3)
   749 |     |         }
   750 |     |     }
   751 |     | 
   752 |     |     function log(address p0, bool p1, bool p2) internal pure {
   753 |     |         bytes32 m0;
   754 |     |         bytes32 m1;
   755 |     |         bytes32 m2;
   756 |     |         bytes32 m3;
   757 |     |         assembly {
   758 |     |             m0 := mload(0x00)
   759 |     |             m1 := mload(0x20)
   760 |     |             m2 := mload(0x40)
   761 |     |             m3 := mload(0x60)
   762 |     |             // Selector of `log(address,bool,bool)`.
   763 |     |             mstore(0x00, 0xeb830c92)
   764 |     |             mstore(0x20, p0)
   765 |     |             mstore(0x40, p1)
   766 |     |             mstore(0x60, p2)
   767 |     |         }
   768 |     |         _sendLogPayload(0x1c, 0x64);
   769 |     |         assembly {
   770 |     |             mstore(0x00, m0)
   771 |     |             mstore(0x20, m1)
   772 |     |             mstore(0x40, m2)
   773 |     |             mstore(0x60, m3)
   774 |     |         }
   775 |     |     }
   776 |     | 
   777 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
   778 |     |         bytes32 m0;
   779 |     |         bytes32 m1;
   780 |     |         bytes32 m2;
   781 |     |         bytes32 m3;
   782 |     |         assembly {
   783 |     |             m0 := mload(0x00)
   784 |     |             m1 := mload(0x20)
   785 |     |             m2 := mload(0x40)
   786 |     |             m3 := mload(0x60)
   787 |     |             // Selector of `log(address,bool,uint256)`.
   788 |     |             mstore(0x00, 0x9c4f99fb)
   789 |     |             mstore(0x20, p0)
   790 |     |             mstore(0x40, p1)
   791 |     |             mstore(0x60, p2)
   792 |     |         }
   793 |     |         _sendLogPayload(0x1c, 0x64);
   794 |     |         assembly {
   795 |     |             mstore(0x00, m0)
   796 |     |             mstore(0x20, m1)
   797 |     |             mstore(0x40, m2)
   798 |     |             mstore(0x60, m3)
   799 |     |         }
   800 |     |     }
   801 |     | 
   802 |     |     function log(address p0, bool p1, bytes32 p2) internal pure {
   803 |     |         bytes32 m0;
   804 |     |         bytes32 m1;
   805 |     |         bytes32 m2;
   806 |     |         bytes32 m3;
   807 |     |         bytes32 m4;
   808 |     |         bytes32 m5;
   809 |     |         assembly {
   810 |     |             function writeString(pos, w) {
   811 |     |                 let length := 0
   812 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   813 |     |                 mstore(pos, length)
   814 |     |                 let shift := sub(256, shl(3, length))
   815 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   816 |     |             }
   817 |     |             m0 := mload(0x00)
   818 |     |             m1 := mload(0x20)
   819 |     |             m2 := mload(0x40)
   820 |     |             m3 := mload(0x60)
   821 |     |             m4 := mload(0x80)
   822 |     |             m5 := mload(0xa0)
   823 |     |             // Selector of `log(address,bool,string)`.
   824 |     |             mstore(0x00, 0x212255cc)
   825 |     |             mstore(0x20, p0)
   826 |     |             mstore(0x40, p1)
   827 |     |             mstore(0x60, 0x60)
   828 |     |             writeString(0x80, p2)
   829 |     |         }
   830 |     |         _sendLogPayload(0x1c, 0xa4);
   831 |     |         assembly {
   832 |     |             mstore(0x00, m0)
   833 |     |             mstore(0x20, m1)
   834 |     |             mstore(0x40, m2)
   835 |     |             mstore(0x60, m3)
   836 |     |             mstore(0x80, m4)
   837 |     |             mstore(0xa0, m5)
   838 |     |         }
   839 |     |     }
   840 |     | 
   841 |     |     function log(address p0, uint256 p1, address p2) internal pure {
   842 |     |         bytes32 m0;
   843 |     |         bytes32 m1;
   844 |     |         bytes32 m2;
   845 |     |         bytes32 m3;
   846 |     |         assembly {
   847 |     |             m0 := mload(0x00)
   848 |     |             m1 := mload(0x20)
   849 |     |             m2 := mload(0x40)
   850 |     |             m3 := mload(0x60)
   851 |     |             // Selector of `log(address,uint256,address)`.
   852 |     |             mstore(0x00, 0x7bc0d848)
   853 |     |             mstore(0x20, p0)
   854 |     |             mstore(0x40, p1)
   855 |     |             mstore(0x60, p2)
   856 |     |         }
   857 |     |         _sendLogPayload(0x1c, 0x64);
   858 |     |         assembly {
   859 |     |             mstore(0x00, m0)
   860 |     |             mstore(0x20, m1)
   861 |     |             mstore(0x40, m2)
   862 |     |             mstore(0x60, m3)
   863 |     |         }
   864 |     |     }
   865 |     | 
   866 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
   867 |     |         bytes32 m0;
   868 |     |         bytes32 m1;
   869 |     |         bytes32 m2;
   870 |     |         bytes32 m3;
   871 |     |         assembly {
   872 |     |             m0 := mload(0x00)
   873 |     |             m1 := mload(0x20)
   874 |     |             m2 := mload(0x40)
   875 |     |             m3 := mload(0x60)
   876 |     |             // Selector of `log(address,uint256,bool)`.
   877 |     |             mstore(0x00, 0x678209a8)
   878 |     |             mstore(0x20, p0)
   879 |     |             mstore(0x40, p1)
   880 |     |             mstore(0x60, p2)
   881 |     |         }
   882 |     |         _sendLogPayload(0x1c, 0x64);
   883 |     |         assembly {
   884 |     |             mstore(0x00, m0)
   885 |     |             mstore(0x20, m1)
   886 |     |             mstore(0x40, m2)
   887 |     |             mstore(0x60, m3)
   888 |     |         }
   889 |     |     }
   890 |     | 
   891 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
   892 |     |         bytes32 m0;
   893 |     |         bytes32 m1;
   894 |     |         bytes32 m2;
   895 |     |         bytes32 m3;
   896 |     |         assembly {
   897 |     |             m0 := mload(0x00)
   898 |     |             m1 := mload(0x20)
   899 |     |             m2 := mload(0x40)
   900 |     |             m3 := mload(0x60)
   901 |     |             // Selector of `log(address,uint256,uint256)`.
   902 |     |             mstore(0x00, 0xb69bcaf6)
   903 |     |             mstore(0x20, p0)
   904 |     |             mstore(0x40, p1)
   905 |     |             mstore(0x60, p2)
   906 |     |         }
   907 |     |         _sendLogPayload(0x1c, 0x64);
   908 |     |         assembly {
   909 |     |             mstore(0x00, m0)
   910 |     |             mstore(0x20, m1)
   911 |     |             mstore(0x40, m2)
   912 |     |             mstore(0x60, m3)
   913 |     |         }
   914 |     |     }
   915 |     | 
   916 |     |     function log(address p0, uint256 p1, bytes32 p2) internal pure {
   917 |     |         bytes32 m0;
   918 |     |         bytes32 m1;
   919 |     |         bytes32 m2;
   920 |     |         bytes32 m3;
   921 |     |         bytes32 m4;
   922 |     |         bytes32 m5;
   923 |     |         assembly {
   924 |     |             function writeString(pos, w) {
   925 |     |                 let length := 0
   926 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   927 |     |                 mstore(pos, length)
   928 |     |                 let shift := sub(256, shl(3, length))
   929 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   930 |     |             }
   931 |     |             m0 := mload(0x00)
   932 |     |             m1 := mload(0x20)
   933 |     |             m2 := mload(0x40)
   934 |     |             m3 := mload(0x60)
   935 |     |             m4 := mload(0x80)
   936 |     |             m5 := mload(0xa0)
   937 |     |             // Selector of `log(address,uint256,string)`.
   938 |     |             mstore(0x00, 0xa1f2e8aa)
   939 |     |             mstore(0x20, p0)
   940 |     |             mstore(0x40, p1)
   941 |     |             mstore(0x60, 0x60)
   942 |     |             writeString(0x80, p2)
   943 |     |         }
   944 |     |         _sendLogPayload(0x1c, 0xa4);
   945 |     |         assembly {
   946 |     |             mstore(0x00, m0)
   947 |     |             mstore(0x20, m1)
   948 |     |             mstore(0x40, m2)
   949 |     |             mstore(0x60, m3)
   950 |     |             mstore(0x80, m4)
   951 |     |             mstore(0xa0, m5)
   952 |     |         }
   953 |     |     }
   954 |     | 
   955 |     |     function log(address p0, bytes32 p1, address p2) internal pure {
   956 |     |         bytes32 m0;
   957 |     |         bytes32 m1;
   958 |     |         bytes32 m2;
   959 |     |         bytes32 m3;
   960 |     |         bytes32 m4;
   961 |     |         bytes32 m5;
   962 |     |         assembly {
   963 |     |             function writeString(pos, w) {
   964 |     |                 let length := 0
   965 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   966 |     |                 mstore(pos, length)
   967 |     |                 let shift := sub(256, shl(3, length))
   968 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   969 |     |             }
   970 |     |             m0 := mload(0x00)
   971 |     |             m1 := mload(0x20)
   972 |     |             m2 := mload(0x40)
   973 |     |             m3 := mload(0x60)
   974 |     |             m4 := mload(0x80)
   975 |     |             m5 := mload(0xa0)
   976 |     |             // Selector of `log(address,string,address)`.
   977 |     |             mstore(0x00, 0xf08744e8)
   978 |     |             mstore(0x20, p0)
   979 |     |             mstore(0x40, 0x60)
   980 |     |             mstore(0x60, p2)
   981 |     |             writeString(0x80, p1)
   982 |     |         }
   983 |     |         _sendLogPayload(0x1c, 0xa4);
   984 |     |         assembly {
   985 |     |             mstore(0x00, m0)
   986 |     |             mstore(0x20, m1)
   987 |     |             mstore(0x40, m2)
   988 |     |             mstore(0x60, m3)
   989 |     |             mstore(0x80, m4)
   990 |     |             mstore(0xa0, m5)
   991 |     |         }
   992 |     |     }
   993 |     | 
   994 |     |     function log(address p0, bytes32 p1, bool p2) internal pure {
   995 |     |         bytes32 m0;
   996 |     |         bytes32 m1;
   997 |     |         bytes32 m2;
   998 |     |         bytes32 m3;
   999 |     |         bytes32 m4;
  1000 |     |         bytes32 m5;
  1001 |     |         assembly {
  1002 |     |             function writeString(pos, w) {
  1003 |     |                 let length := 0
  1004 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1005 |     |                 mstore(pos, length)
  1006 |     |                 let shift := sub(256, shl(3, length))
  1007 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1008 |     |             }
  1009 |     |             m0 := mload(0x00)
  1010 |     |             m1 := mload(0x20)
  1011 |     |             m2 := mload(0x40)
  1012 |     |             m3 := mload(0x60)
  1013 |     |             m4 := mload(0x80)
  1014 |     |             m5 := mload(0xa0)
  1015 |     |             // Selector of `log(address,string,bool)`.
  1016 |     |             mstore(0x00, 0xcf020fb1)
  1017 |     |             mstore(0x20, p0)
  1018 |     |             mstore(0x40, 0x60)
  1019 |     |             mstore(0x60, p2)
  1020 |     |             writeString(0x80, p1)
  1021 |     |         }
  1022 |     |         _sendLogPayload(0x1c, 0xa4);
  1023 |     |         assembly {
  1024 |     |             mstore(0x00, m0)
  1025 |     |             mstore(0x20, m1)
  1026 |     |             mstore(0x40, m2)
  1027 |     |             mstore(0x60, m3)
  1028 |     |             mstore(0x80, m4)
  1029 |     |             mstore(0xa0, m5)
  1030 |     |         }
  1031 |     |     }
  1032 |     | 
  1033 |     |     function log(address p0, bytes32 p1, uint256 p2) internal pure {
  1034 |     |         bytes32 m0;
  1035 |     |         bytes32 m1;
  1036 |     |         bytes32 m2;
  1037 |     |         bytes32 m3;
  1038 |     |         bytes32 m4;
  1039 |     |         bytes32 m5;
  1040 |     |         assembly {
  1041 |     |             function writeString(pos, w) {
  1042 |     |                 let length := 0
  1043 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1044 |     |                 mstore(pos, length)
  1045 |     |                 let shift := sub(256, shl(3, length))
  1046 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1047 |     |             }
  1048 |     |             m0 := mload(0x00)
  1049 |     |             m1 := mload(0x20)
  1050 |     |             m2 := mload(0x40)
  1051 |     |             m3 := mload(0x60)
  1052 |     |             m4 := mload(0x80)
  1053 |     |             m5 := mload(0xa0)
  1054 |     |             // Selector of `log(address,string,uint256)`.
  1055 |     |             mstore(0x00, 0x67dd6ff1)
  1056 |     |             mstore(0x20, p0)
  1057 |     |             mstore(0x40, 0x60)
  1058 |     |             mstore(0x60, p2)
  1059 |     |             writeString(0x80, p1)
  1060 |     |         }
  1061 |     |         _sendLogPayload(0x1c, 0xa4);
  1062 |     |         assembly {
  1063 |     |             mstore(0x00, m0)
  1064 |     |             mstore(0x20, m1)
  1065 |     |             mstore(0x40, m2)
  1066 |     |             mstore(0x60, m3)
  1067 |     |             mstore(0x80, m4)
  1068 |     |             mstore(0xa0, m5)
  1069 |     |         }
  1070 |     |     }
  1071 |     | 
  1072 |     |     function log(address p0, bytes32 p1, bytes32 p2) internal pure {
  1073 |     |         bytes32 m0;
  1074 |     |         bytes32 m1;
  1075 |     |         bytes32 m2;
  1076 |     |         bytes32 m3;
  1077 |     |         bytes32 m4;
  1078 |     |         bytes32 m5;
  1079 |     |         bytes32 m6;
  1080 |     |         bytes32 m7;
  1081 |     |         assembly {
  1082 |     |             function writeString(pos, w) {
  1083 |     |                 let length := 0
  1084 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1085 |     |                 mstore(pos, length)
  1086 |     |                 let shift := sub(256, shl(3, length))
  1087 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1088 |     |             }
  1089 |     |             m0 := mload(0x00)
  1090 |     |             m1 := mload(0x20)
  1091 |     |             m2 := mload(0x40)
  1092 |     |             m3 := mload(0x60)
  1093 |     |             m4 := mload(0x80)
  1094 |     |             m5 := mload(0xa0)
  1095 |     |             m6 := mload(0xc0)
  1096 |     |             m7 := mload(0xe0)
  1097 |     |             // Selector of `log(address,string,string)`.
  1098 |     |             mstore(0x00, 0xfb772265)
  1099 |     |             mstore(0x20, p0)
  1100 |     |             mstore(0x40, 0x60)
  1101 |     |             mstore(0x60, 0xa0)
  1102 |     |             writeString(0x80, p1)
  1103 |     |             writeString(0xc0, p2)
  1104 |     |         }
  1105 |     |         _sendLogPayload(0x1c, 0xe4);
  1106 |     |         assembly {
  1107 |     |             mstore(0x00, m0)
  1108 |     |             mstore(0x20, m1)
  1109 |     |             mstore(0x40, m2)
  1110 |     |             mstore(0x60, m3)
  1111 |     |             mstore(0x80, m4)
  1112 |     |             mstore(0xa0, m5)
  1113 |     |             mstore(0xc0, m6)
  1114 |     |             mstore(0xe0, m7)
  1115 |     |         }
  1116 |     |     }
  1117 |     | 
  1118 |     |     function log(bool p0, address p1, address p2) internal pure {
  1119 |     |         bytes32 m0;
  1120 |     |         bytes32 m1;
  1121 |     |         bytes32 m2;
  1122 |     |         bytes32 m3;
  1123 |     |         assembly {
  1124 |     |             m0 := mload(0x00)
  1125 |     |             m1 := mload(0x20)
  1126 |     |             m2 := mload(0x40)
  1127 |     |             m3 := mload(0x60)
  1128 |     |             // Selector of `log(bool,address,address)`.
  1129 |     |             mstore(0x00, 0xd2763667)
  1130 |     |             mstore(0x20, p0)
  1131 |     |             mstore(0x40, p1)
  1132 |     |             mstore(0x60, p2)
  1133 |     |         }
  1134 |     |         _sendLogPayload(0x1c, 0x64);
  1135 |     |         assembly {
  1136 |     |             mstore(0x00, m0)
  1137 |     |             mstore(0x20, m1)
  1138 |     |             mstore(0x40, m2)
  1139 |     |             mstore(0x60, m3)
  1140 |     |         }
  1141 |     |     }
  1142 |     | 
  1143 |     |     function log(bool p0, address p1, bool p2) internal pure {
  1144 |     |         bytes32 m0;
  1145 |     |         bytes32 m1;
  1146 |     |         bytes32 m2;
  1147 |     |         bytes32 m3;
  1148 |     |         assembly {
  1149 |     |             m0 := mload(0x00)
  1150 |     |             m1 := mload(0x20)
  1151 |     |             m2 := mload(0x40)
  1152 |     |             m3 := mload(0x60)
  1153 |     |             // Selector of `log(bool,address,bool)`.
  1154 |     |             mstore(0x00, 0x18c9c746)
  1155 |     |             mstore(0x20, p0)
  1156 |     |             mstore(0x40, p1)
  1157 |     |             mstore(0x60, p2)
  1158 |     |         }
  1159 |     |         _sendLogPayload(0x1c, 0x64);
  1160 |     |         assembly {
  1161 |     |             mstore(0x00, m0)
  1162 |     |             mstore(0x20, m1)
  1163 |     |             mstore(0x40, m2)
  1164 |     |             mstore(0x60, m3)
  1165 |     |         }
  1166 |     |     }
  1167 |     | 
  1168 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  1169 |     |         bytes32 m0;
  1170 |     |         bytes32 m1;
  1171 |     |         bytes32 m2;
  1172 |     |         bytes32 m3;
  1173 |     |         assembly {
  1174 |     |             m0 := mload(0x00)
  1175 |     |             m1 := mload(0x20)
  1176 |     |             m2 := mload(0x40)
  1177 |     |             m3 := mload(0x60)
  1178 |     |             // Selector of `log(bool,address,uint256)`.
  1179 |     |             mstore(0x00, 0x5f7b9afb)
  1180 |     |             mstore(0x20, p0)
  1181 |     |             mstore(0x40, p1)
  1182 |     |             mstore(0x60, p2)
  1183 |     |         }
  1184 |     |         _sendLogPayload(0x1c, 0x64);
  1185 |     |         assembly {
  1186 |     |             mstore(0x00, m0)
  1187 |     |             mstore(0x20, m1)
  1188 |     |             mstore(0x40, m2)
  1189 |     |             mstore(0x60, m3)
  1190 |     |         }
  1191 |     |     }
  1192 |     | 
  1193 |     |     function log(bool p0, address p1, bytes32 p2) internal pure {
  1194 |     |         bytes32 m0;
  1195 |     |         bytes32 m1;
  1196 |     |         bytes32 m2;
  1197 |     |         bytes32 m3;
  1198 |     |         bytes32 m4;
  1199 |     |         bytes32 m5;
  1200 |     |         assembly {
  1201 |     |             function writeString(pos, w) {
  1202 |     |                 let length := 0
  1203 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1204 |     |                 mstore(pos, length)
  1205 |     |                 let shift := sub(256, shl(3, length))
  1206 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1207 |     |             }
  1208 |     |             m0 := mload(0x00)
  1209 |     |             m1 := mload(0x20)
  1210 |     |             m2 := mload(0x40)
  1211 |     |             m3 := mload(0x60)
  1212 |     |             m4 := mload(0x80)
  1213 |     |             m5 := mload(0xa0)
  1214 |     |             // Selector of `log(bool,address,string)`.
  1215 |     |             mstore(0x00, 0xde9a9270)
  1216 |     |             mstore(0x20, p0)
  1217 |     |             mstore(0x40, p1)
  1218 |     |             mstore(0x60, 0x60)
  1219 |     |             writeString(0x80, p2)
  1220 |     |         }
  1221 |     |         _sendLogPayload(0x1c, 0xa4);
  1222 |     |         assembly {
  1223 |     |             mstore(0x00, m0)
  1224 |     |             mstore(0x20, m1)
  1225 |     |             mstore(0x40, m2)
  1226 |     |             mstore(0x60, m3)
  1227 |     |             mstore(0x80, m4)
  1228 |     |             mstore(0xa0, m5)
  1229 |     |         }
  1230 |     |     }
  1231 |     | 
  1232 |     |     function log(bool p0, bool p1, address p2) internal pure {
  1233 |     |         bytes32 m0;
  1234 |     |         bytes32 m1;
  1235 |     |         bytes32 m2;
  1236 |     |         bytes32 m3;
  1237 |     |         assembly {
  1238 |     |             m0 := mload(0x00)
  1239 |     |             m1 := mload(0x20)
  1240 |     |             m2 := mload(0x40)
  1241 |     |             m3 := mload(0x60)
  1242 |     |             // Selector of `log(bool,bool,address)`.
  1243 |     |             mstore(0x00, 0x1078f68d)
  1244 |     |             mstore(0x20, p0)
  1245 |     |             mstore(0x40, p1)
  1246 |     |             mstore(0x60, p2)
  1247 |     |         }
  1248 |     |         _sendLogPayload(0x1c, 0x64);
  1249 |     |         assembly {
  1250 |     |             mstore(0x00, m0)
  1251 |     |             mstore(0x20, m1)
  1252 |     |             mstore(0x40, m2)
  1253 |     |             mstore(0x60, m3)
  1254 |     |         }
  1255 |     |     }
  1256 |     | 
  1257 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  1258 |     |         bytes32 m0;
  1259 |     |         bytes32 m1;
  1260 |     |         bytes32 m2;
  1261 |     |         bytes32 m3;
  1262 |     |         assembly {
  1263 |     |             m0 := mload(0x00)
  1264 |     |             m1 := mload(0x20)
  1265 |     |             m2 := mload(0x40)
  1266 |     |             m3 := mload(0x60)
  1267 |     |             // Selector of `log(bool,bool,bool)`.
  1268 |     |             mstore(0x00, 0x50709698)
  1269 |     |             mstore(0x20, p0)
  1270 |     |             mstore(0x40, p1)
  1271 |     |             mstore(0x60, p2)
  1272 |     |         }
  1273 |     |         _sendLogPayload(0x1c, 0x64);
  1274 |     |         assembly {
  1275 |     |             mstore(0x00, m0)
  1276 |     |             mstore(0x20, m1)
  1277 |     |             mstore(0x40, m2)
  1278 |     |             mstore(0x60, m3)
  1279 |     |         }
  1280 |     |     }
  1281 |     | 
  1282 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  1283 |     |         bytes32 m0;
  1284 |     |         bytes32 m1;
  1285 |     |         bytes32 m2;
  1286 |     |         bytes32 m3;
  1287 |     |         assembly {
  1288 |     |             m0 := mload(0x00)
  1289 |     |             m1 := mload(0x20)
  1290 |     |             m2 := mload(0x40)
  1291 |     |             m3 := mload(0x60)
  1292 |     |             // Selector of `log(bool,bool,uint256)`.
  1293 |     |             mstore(0x00, 0x12f21602)
  1294 |     |             mstore(0x20, p0)
  1295 |     |             mstore(0x40, p1)
  1296 |     |             mstore(0x60, p2)
  1297 |     |         }
  1298 |     |         _sendLogPayload(0x1c, 0x64);
  1299 |     |         assembly {
  1300 |     |             mstore(0x00, m0)
  1301 |     |             mstore(0x20, m1)
  1302 |     |             mstore(0x40, m2)
  1303 |     |             mstore(0x60, m3)
  1304 |     |         }
  1305 |     |     }
  1306 |     | 
  1307 |     |     function log(bool p0, bool p1, bytes32 p2) internal pure {
  1308 |     |         bytes32 m0;
  1309 |     |         bytes32 m1;
  1310 |     |         bytes32 m2;
  1311 |     |         bytes32 m3;
  1312 |     |         bytes32 m4;
  1313 |     |         bytes32 m5;
  1314 |     |         assembly {
  1315 |     |             function writeString(pos, w) {
  1316 |     |                 let length := 0
  1317 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1318 |     |                 mstore(pos, length)
  1319 |     |                 let shift := sub(256, shl(3, length))
  1320 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1321 |     |             }
  1322 |     |             m0 := mload(0x00)
  1323 |     |             m1 := mload(0x20)
  1324 |     |             m2 := mload(0x40)
  1325 |     |             m3 := mload(0x60)
  1326 |     |             m4 := mload(0x80)
  1327 |     |             m5 := mload(0xa0)
  1328 |     |             // Selector of `log(bool,bool,string)`.
  1329 |     |             mstore(0x00, 0x2555fa46)
  1330 |     |             mstore(0x20, p0)
  1331 |     |             mstore(0x40, p1)
  1332 |     |             mstore(0x60, 0x60)
  1333 |     |             writeString(0x80, p2)
  1334 |     |         }
  1335 |     |         _sendLogPayload(0x1c, 0xa4);
  1336 |     |         assembly {
  1337 |     |             mstore(0x00, m0)
  1338 |     |             mstore(0x20, m1)
  1339 |     |             mstore(0x40, m2)
  1340 |     |             mstore(0x60, m3)
  1341 |     |             mstore(0x80, m4)
  1342 |     |             mstore(0xa0, m5)
  1343 |     |         }
  1344 |     |     }
  1345 |     | 
  1346 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  1347 |     |         bytes32 m0;
  1348 |     |         bytes32 m1;
  1349 |     |         bytes32 m2;
  1350 |     |         bytes32 m3;
  1351 |     |         assembly {
  1352 |     |             m0 := mload(0x00)
  1353 |     |             m1 := mload(0x20)
  1354 |     |             m2 := mload(0x40)
  1355 |     |             m3 := mload(0x60)
  1356 |     |             // Selector of `log(bool,uint256,address)`.
  1357 |     |             mstore(0x00, 0x088ef9d2)
  1358 |     |             mstore(0x20, p0)
  1359 |     |             mstore(0x40, p1)
  1360 |     |             mstore(0x60, p2)
  1361 |     |         }
  1362 |     |         _sendLogPayload(0x1c, 0x64);
  1363 |     |         assembly {
  1364 |     |             mstore(0x00, m0)
  1365 |     |             mstore(0x20, m1)
  1366 |     |             mstore(0x40, m2)
  1367 |     |             mstore(0x60, m3)
  1368 |     |         }
  1369 |     |     }
  1370 |     | 
  1371 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  1372 |     |         bytes32 m0;
  1373 |     |         bytes32 m1;
  1374 |     |         bytes32 m2;
  1375 |     |         bytes32 m3;
  1376 |     |         assembly {
  1377 |     |             m0 := mload(0x00)
  1378 |     |             m1 := mload(0x20)
  1379 |     |             m2 := mload(0x40)
  1380 |     |             m3 := mload(0x60)
  1381 |     |             // Selector of `log(bool,uint256,bool)`.
  1382 |     |             mstore(0x00, 0xe8defba9)
  1383 |     |             mstore(0x20, p0)
  1384 |     |             mstore(0x40, p1)
  1385 |     |             mstore(0x60, p2)
  1386 |     |         }
  1387 |     |         _sendLogPayload(0x1c, 0x64);
  1388 |     |         assembly {
  1389 |     |             mstore(0x00, m0)
  1390 |     |             mstore(0x20, m1)
  1391 |     |             mstore(0x40, m2)
  1392 |     |             mstore(0x60, m3)
  1393 |     |         }
  1394 |     |     }
  1395 |     | 
  1396 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  1397 |     |         bytes32 m0;
  1398 |     |         bytes32 m1;
  1399 |     |         bytes32 m2;
  1400 |     |         bytes32 m3;
  1401 |     |         assembly {
  1402 |     |             m0 := mload(0x00)
  1403 |     |             m1 := mload(0x20)
  1404 |     |             m2 := mload(0x40)
  1405 |     |             m3 := mload(0x60)
  1406 |     |             // Selector of `log(bool,uint256,uint256)`.
  1407 |     |             mstore(0x00, 0x37103367)
  1408 |     |             mstore(0x20, p0)
  1409 |     |             mstore(0x40, p1)
  1410 |     |             mstore(0x60, p2)
  1411 |     |         }
  1412 |     |         _sendLogPayload(0x1c, 0x64);
  1413 |     |         assembly {
  1414 |     |             mstore(0x00, m0)
  1415 |     |             mstore(0x20, m1)
  1416 |     |             mstore(0x40, m2)
  1417 |     |             mstore(0x60, m3)
  1418 |     |         }
  1419 |     |     }
  1420 |     | 
  1421 |     |     function log(bool p0, uint256 p1, bytes32 p2) internal pure {
  1422 |     |         bytes32 m0;
  1423 |     |         bytes32 m1;
  1424 |     |         bytes32 m2;
  1425 |     |         bytes32 m3;
  1426 |     |         bytes32 m4;
  1427 |     |         bytes32 m5;
  1428 |     |         assembly {
  1429 |     |             function writeString(pos, w) {
  1430 |     |                 let length := 0
  1431 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1432 |     |                 mstore(pos, length)
  1433 |     |                 let shift := sub(256, shl(3, length))
  1434 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1435 |     |             }
  1436 |     |             m0 := mload(0x00)
  1437 |     |             m1 := mload(0x20)
  1438 |     |             m2 := mload(0x40)
  1439 |     |             m3 := mload(0x60)
  1440 |     |             m4 := mload(0x80)
  1441 |     |             m5 := mload(0xa0)
  1442 |     |             // Selector of `log(bool,uint256,string)`.
  1443 |     |             mstore(0x00, 0xc3fc3970)
  1444 |     |             mstore(0x20, p0)
  1445 |     |             mstore(0x40, p1)
  1446 |     |             mstore(0x60, 0x60)
  1447 |     |             writeString(0x80, p2)
  1448 |     |         }
  1449 |     |         _sendLogPayload(0x1c, 0xa4);
  1450 |     |         assembly {
  1451 |     |             mstore(0x00, m0)
  1452 |     |             mstore(0x20, m1)
  1453 |     |             mstore(0x40, m2)
  1454 |     |             mstore(0x60, m3)
  1455 |     |             mstore(0x80, m4)
  1456 |     |             mstore(0xa0, m5)
  1457 |     |         }
  1458 |     |     }
  1459 |     | 
  1460 |     |     function log(bool p0, bytes32 p1, address p2) internal pure {
  1461 |     |         bytes32 m0;
  1462 |     |         bytes32 m1;
  1463 |     |         bytes32 m2;
  1464 |     |         bytes32 m3;
  1465 |     |         bytes32 m4;
  1466 |     |         bytes32 m5;
  1467 |     |         assembly {
  1468 |     |             function writeString(pos, w) {
  1469 |     |                 let length := 0
  1470 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1471 |     |                 mstore(pos, length)
  1472 |     |                 let shift := sub(256, shl(3, length))
  1473 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1474 |     |             }
  1475 |     |             m0 := mload(0x00)
  1476 |     |             m1 := mload(0x20)
  1477 |     |             m2 := mload(0x40)
  1478 |     |             m3 := mload(0x60)
  1479 |     |             m4 := mload(0x80)
  1480 |     |             m5 := mload(0xa0)
  1481 |     |             // Selector of `log(bool,string,address)`.
  1482 |     |             mstore(0x00, 0x9591b953)
  1483 |     |             mstore(0x20, p0)
  1484 |     |             mstore(0x40, 0x60)
  1485 |     |             mstore(0x60, p2)
  1486 |     |             writeString(0x80, p1)
  1487 |     |         }
  1488 |     |         _sendLogPayload(0x1c, 0xa4);
  1489 |     |         assembly {
  1490 |     |             mstore(0x00, m0)
  1491 |     |             mstore(0x20, m1)
  1492 |     |             mstore(0x40, m2)
  1493 |     |             mstore(0x60, m3)
  1494 |     |             mstore(0x80, m4)
  1495 |     |             mstore(0xa0, m5)
  1496 |     |         }
  1497 |     |     }
  1498 |     | 
  1499 |     |     function log(bool p0, bytes32 p1, bool p2) internal pure {
  1500 |     |         bytes32 m0;
  1501 |     |         bytes32 m1;
  1502 |     |         bytes32 m2;
  1503 |     |         bytes32 m3;
  1504 |     |         bytes32 m4;
  1505 |     |         bytes32 m5;
  1506 |     |         assembly {
  1507 |     |             function writeString(pos, w) {
  1508 |     |                 let length := 0
  1509 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1510 |     |                 mstore(pos, length)
  1511 |     |                 let shift := sub(256, shl(3, length))
  1512 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1513 |     |             }
  1514 |     |             m0 := mload(0x00)
  1515 |     |             m1 := mload(0x20)
  1516 |     |             m2 := mload(0x40)
  1517 |     |             m3 := mload(0x60)
  1518 |     |             m4 := mload(0x80)
  1519 |     |             m5 := mload(0xa0)
  1520 |     |             // Selector of `log(bool,string,bool)`.
  1521 |     |             mstore(0x00, 0xdbb4c247)
  1522 |     |             mstore(0x20, p0)
  1523 |     |             mstore(0x40, 0x60)
  1524 |     |             mstore(0x60, p2)
  1525 |     |             writeString(0x80, p1)
  1526 |     |         }
  1527 |     |         _sendLogPayload(0x1c, 0xa4);
  1528 |     |         assembly {
  1529 |     |             mstore(0x00, m0)
  1530 |     |             mstore(0x20, m1)
  1531 |     |             mstore(0x40, m2)
  1532 |     |             mstore(0x60, m3)
  1533 |     |             mstore(0x80, m4)
  1534 |     |             mstore(0xa0, m5)
  1535 |     |         }
  1536 |     |     }
  1537 |     | 
  1538 |     |     function log(bool p0, bytes32 p1, uint256 p2) internal pure {
  1539 |     |         bytes32 m0;
  1540 |     |         bytes32 m1;
  1541 |     |         bytes32 m2;
  1542 |     |         bytes32 m3;
  1543 |     |         bytes32 m4;
  1544 |     |         bytes32 m5;
  1545 |     |         assembly {
  1546 |     |             function writeString(pos, w) {
  1547 |     |                 let length := 0
  1548 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1549 |     |                 mstore(pos, length)
  1550 |     |                 let shift := sub(256, shl(3, length))
  1551 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1552 |     |             }
  1553 |     |             m0 := mload(0x00)
  1554 |     |             m1 := mload(0x20)
  1555 |     |             m2 := mload(0x40)
  1556 |     |             m3 := mload(0x60)
  1557 |     |             m4 := mload(0x80)
  1558 |     |             m5 := mload(0xa0)
  1559 |     |             // Selector of `log(bool,string,uint256)`.
  1560 |     |             mstore(0x00, 0x1093ee11)
  1561 |     |             mstore(0x20, p0)
  1562 |     |             mstore(0x40, 0x60)
  1563 |     |             mstore(0x60, p2)
  1564 |     |             writeString(0x80, p1)
  1565 |     |         }
  1566 |     |         _sendLogPayload(0x1c, 0xa4);
  1567 |     |         assembly {
  1568 |     |             mstore(0x00, m0)
  1569 |     |             mstore(0x20, m1)
  1570 |     |             mstore(0x40, m2)
  1571 |     |             mstore(0x60, m3)
  1572 |     |             mstore(0x80, m4)
  1573 |     |             mstore(0xa0, m5)
  1574 |     |         }
  1575 |     |     }
  1576 |     | 
  1577 |     |     function log(bool p0, bytes32 p1, bytes32 p2) internal pure {
  1578 |     |         bytes32 m0;
  1579 |     |         bytes32 m1;
  1580 |     |         bytes32 m2;
  1581 |     |         bytes32 m3;
  1582 |     |         bytes32 m4;
  1583 |     |         bytes32 m5;
  1584 |     |         bytes32 m6;
  1585 |     |         bytes32 m7;
  1586 |     |         assembly {
  1587 |     |             function writeString(pos, w) {
  1588 |     |                 let length := 0
  1589 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1590 |     |                 mstore(pos, length)
  1591 |     |                 let shift := sub(256, shl(3, length))
  1592 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1593 |     |             }
  1594 |     |             m0 := mload(0x00)
  1595 |     |             m1 := mload(0x20)
  1596 |     |             m2 := mload(0x40)
  1597 |     |             m3 := mload(0x60)
  1598 |     |             m4 := mload(0x80)
  1599 |     |             m5 := mload(0xa0)
  1600 |     |             m6 := mload(0xc0)
  1601 |     |             m7 := mload(0xe0)
  1602 |     |             // Selector of `log(bool,string,string)`.
  1603 |     |             mstore(0x00, 0xb076847f)
  1604 |     |             mstore(0x20, p0)
  1605 |     |             mstore(0x40, 0x60)
  1606 |     |             mstore(0x60, 0xa0)
  1607 |     |             writeString(0x80, p1)
  1608 |     |             writeString(0xc0, p2)
  1609 |     |         }
  1610 |     |         _sendLogPayload(0x1c, 0xe4);
  1611 |     |         assembly {
  1612 |     |             mstore(0x00, m0)
  1613 |     |             mstore(0x20, m1)
  1614 |     |             mstore(0x40, m2)
  1615 |     |             mstore(0x60, m3)
  1616 |     |             mstore(0x80, m4)
  1617 |     |             mstore(0xa0, m5)
  1618 |     |             mstore(0xc0, m6)
  1619 |     |             mstore(0xe0, m7)
  1620 |     |         }
  1621 |     |     }
  1622 |     | 
  1623 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  1624 |     |         bytes32 m0;
  1625 |     |         bytes32 m1;
  1626 |     |         bytes32 m2;
  1627 |     |         bytes32 m3;
  1628 |     |         assembly {
  1629 |     |             m0 := mload(0x00)
  1630 |     |             m1 := mload(0x20)
  1631 |     |             m2 := mload(0x40)
  1632 |     |             m3 := mload(0x60)
  1633 |     |             // Selector of `log(uint256,address,address)`.
  1634 |     |             mstore(0x00, 0xbcfd9be0)
  1635 |     |             mstore(0x20, p0)
  1636 |     |             mstore(0x40, p1)
  1637 |     |             mstore(0x60, p2)
  1638 |     |         }
  1639 |     |         _sendLogPayload(0x1c, 0x64);
  1640 |     |         assembly {
  1641 |     |             mstore(0x00, m0)
  1642 |     |             mstore(0x20, m1)
  1643 |     |             mstore(0x40, m2)
  1644 |     |             mstore(0x60, m3)
  1645 |     |         }
  1646 |     |     }
  1647 |     | 
  1648 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  1649 |     |         bytes32 m0;
  1650 |     |         bytes32 m1;
  1651 |     |         bytes32 m2;
  1652 |     |         bytes32 m3;
  1653 |     |         assembly {
  1654 |     |             m0 := mload(0x00)
  1655 |     |             m1 := mload(0x20)
  1656 |     |             m2 := mload(0x40)
  1657 |     |             m3 := mload(0x60)
  1658 |     |             // Selector of `log(uint256,address,bool)`.
  1659 |     |             mstore(0x00, 0x9b6ec042)
  1660 |     |             mstore(0x20, p0)
  1661 |     |             mstore(0x40, p1)
  1662 |     |             mstore(0x60, p2)
  1663 |     |         }
  1664 |     |         _sendLogPayload(0x1c, 0x64);
  1665 |     |         assembly {
  1666 |     |             mstore(0x00, m0)
  1667 |     |             mstore(0x20, m1)
  1668 |     |             mstore(0x40, m2)
  1669 |     |             mstore(0x60, m3)
  1670 |     |         }
  1671 |     |     }
  1672 |     | 
  1673 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  1674 |     |         bytes32 m0;
  1675 |     |         bytes32 m1;
  1676 |     |         bytes32 m2;
  1677 |     |         bytes32 m3;
  1678 |     |         assembly {
  1679 |     |             m0 := mload(0x00)
  1680 |     |             m1 := mload(0x20)
  1681 |     |             m2 := mload(0x40)
  1682 |     |             m3 := mload(0x60)
  1683 |     |             // Selector of `log(uint256,address,uint256)`.
  1684 |     |             mstore(0x00, 0x5a9b5ed5)
  1685 |     |             mstore(0x20, p0)
  1686 |     |             mstore(0x40, p1)
  1687 |     |             mstore(0x60, p2)
  1688 |     |         }
  1689 |     |         _sendLogPayload(0x1c, 0x64);
  1690 |     |         assembly {
  1691 |     |             mstore(0x00, m0)
  1692 |     |             mstore(0x20, m1)
  1693 |     |             mstore(0x40, m2)
  1694 |     |             mstore(0x60, m3)
  1695 |     |         }
  1696 |     |     }
  1697 |     | 
  1698 |     |     function log(uint256 p0, address p1, bytes32 p2) internal pure {
  1699 |     |         bytes32 m0;
  1700 |     |         bytes32 m1;
  1701 |     |         bytes32 m2;
  1702 |     |         bytes32 m3;
  1703 |     |         bytes32 m4;
  1704 |     |         bytes32 m5;
  1705 |     |         assembly {
  1706 |     |             function writeString(pos, w) {
  1707 |     |                 let length := 0
  1708 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1709 |     |                 mstore(pos, length)
  1710 |     |                 let shift := sub(256, shl(3, length))
  1711 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1712 |     |             }
  1713 |     |             m0 := mload(0x00)
  1714 |     |             m1 := mload(0x20)
  1715 |     |             m2 := mload(0x40)
  1716 |     |             m3 := mload(0x60)
  1717 |     |             m4 := mload(0x80)
  1718 |     |             m5 := mload(0xa0)
  1719 |     |             // Selector of `log(uint256,address,string)`.
  1720 |     |             mstore(0x00, 0x63cb41f9)
  1721 |     |             mstore(0x20, p0)
  1722 |     |             mstore(0x40, p1)
  1723 |     |             mstore(0x60, 0x60)
  1724 |     |             writeString(0x80, p2)
  1725 |     |         }
  1726 |     |         _sendLogPayload(0x1c, 0xa4);
  1727 |     |         assembly {
  1728 |     |             mstore(0x00, m0)
  1729 |     |             mstore(0x20, m1)
  1730 |     |             mstore(0x40, m2)
  1731 |     |             mstore(0x60, m3)
  1732 |     |             mstore(0x80, m4)
  1733 |     |             mstore(0xa0, m5)
  1734 |     |         }
  1735 |     |     }
  1736 |     | 
  1737 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  1738 |     |         bytes32 m0;
  1739 |     |         bytes32 m1;
  1740 |     |         bytes32 m2;
  1741 |     |         bytes32 m3;
  1742 |     |         assembly {
  1743 |     |             m0 := mload(0x00)
  1744 |     |             m1 := mload(0x20)
  1745 |     |             m2 := mload(0x40)
  1746 |     |             m3 := mload(0x60)
  1747 |     |             // Selector of `log(uint256,bool,address)`.
  1748 |     |             mstore(0x00, 0x35085f7b)
  1749 |     |             mstore(0x20, p0)
  1750 |     |             mstore(0x40, p1)
  1751 |     |             mstore(0x60, p2)
  1752 |     |         }
  1753 |     |         _sendLogPayload(0x1c, 0x64);
  1754 |     |         assembly {
  1755 |     |             mstore(0x00, m0)
  1756 |     |             mstore(0x20, m1)
  1757 |     |             mstore(0x40, m2)
  1758 |     |             mstore(0x60, m3)
  1759 |     |         }
  1760 |     |     }
  1761 |     | 
  1762 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  1763 |     |         bytes32 m0;
  1764 |     |         bytes32 m1;
  1765 |     |         bytes32 m2;
  1766 |     |         bytes32 m3;
  1767 |     |         assembly {
  1768 |     |             m0 := mload(0x00)
  1769 |     |             m1 := mload(0x20)
  1770 |     |             m2 := mload(0x40)
  1771 |     |             m3 := mload(0x60)
  1772 |     |             // Selector of `log(uint256,bool,bool)`.
  1773 |     |             mstore(0x00, 0x20718650)
  1774 |     |             mstore(0x20, p0)
  1775 |     |             mstore(0x40, p1)
  1776 |     |             mstore(0x60, p2)
  1777 |     |         }
  1778 |     |         _sendLogPayload(0x1c, 0x64);
  1779 |     |         assembly {
  1780 |     |             mstore(0x00, m0)
  1781 |     |             mstore(0x20, m1)
  1782 |     |             mstore(0x40, m2)
  1783 |     |             mstore(0x60, m3)
  1784 |     |         }
  1785 |     |     }
  1786 |     | 
  1787 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  1788 |     |         bytes32 m0;
  1789 |     |         bytes32 m1;
  1790 |     |         bytes32 m2;
  1791 |     |         bytes32 m3;
  1792 |     |         assembly {
  1793 |     |             m0 := mload(0x00)
  1794 |     |             m1 := mload(0x20)
  1795 |     |             m2 := mload(0x40)
  1796 |     |             m3 := mload(0x60)
  1797 |     |             // Selector of `log(uint256,bool,uint256)`.
  1798 |     |             mstore(0x00, 0x20098014)
  1799 |     |             mstore(0x20, p0)
  1800 |     |             mstore(0x40, p1)
  1801 |     |             mstore(0x60, p2)
  1802 |     |         }
  1803 |     |         _sendLogPayload(0x1c, 0x64);
  1804 |     |         assembly {
  1805 |     |             mstore(0x00, m0)
  1806 |     |             mstore(0x20, m1)
  1807 |     |             mstore(0x40, m2)
  1808 |     |             mstore(0x60, m3)
  1809 |     |         }
  1810 |     |     }
  1811 |     | 
  1812 |     |     function log(uint256 p0, bool p1, bytes32 p2) internal pure {
  1813 |     |         bytes32 m0;
  1814 |     |         bytes32 m1;
  1815 |     |         bytes32 m2;
  1816 |     |         bytes32 m3;
  1817 |     |         bytes32 m4;
  1818 |     |         bytes32 m5;
  1819 |     |         assembly {
  1820 |     |             function writeString(pos, w) {
  1821 |     |                 let length := 0
  1822 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1823 |     |                 mstore(pos, length)
  1824 |     |                 let shift := sub(256, shl(3, length))
  1825 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1826 |     |             }
  1827 |     |             m0 := mload(0x00)
  1828 |     |             m1 := mload(0x20)
  1829 |     |             m2 := mload(0x40)
  1830 |     |             m3 := mload(0x60)
  1831 |     |             m4 := mload(0x80)
  1832 |     |             m5 := mload(0xa0)
  1833 |     |             // Selector of `log(uint256,bool,string)`.
  1834 |     |             mstore(0x00, 0x85775021)
  1835 |     |             mstore(0x20, p0)
  1836 |     |             mstore(0x40, p1)
  1837 |     |             mstore(0x60, 0x60)
  1838 |     |             writeString(0x80, p2)
  1839 |     |         }
  1840 |     |         _sendLogPayload(0x1c, 0xa4);
  1841 |     |         assembly {
  1842 |     |             mstore(0x00, m0)
  1843 |     |             mstore(0x20, m1)
  1844 |     |             mstore(0x40, m2)
  1845 |     |             mstore(0x60, m3)
  1846 |     |             mstore(0x80, m4)
  1847 |     |             mstore(0xa0, m5)
  1848 |     |         }
  1849 |     |     }
  1850 |     | 
  1851 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  1852 |     |         bytes32 m0;
  1853 |     |         bytes32 m1;
  1854 |     |         bytes32 m2;
  1855 |     |         bytes32 m3;
  1856 |     |         assembly {
  1857 |     |             m0 := mload(0x00)
  1858 |     |             m1 := mload(0x20)
  1859 |     |             m2 := mload(0x40)
  1860 |     |             m3 := mload(0x60)
  1861 |     |             // Selector of `log(uint256,uint256,address)`.
  1862 |     |             mstore(0x00, 0x5c96b331)
  1863 |     |             mstore(0x20, p0)
  1864 |     |             mstore(0x40, p1)
  1865 |     |             mstore(0x60, p2)
  1866 |     |         }
  1867 |     |         _sendLogPayload(0x1c, 0x64);
  1868 |     |         assembly {
  1869 |     |             mstore(0x00, m0)
  1870 |     |             mstore(0x20, m1)
  1871 |     |             mstore(0x40, m2)
  1872 |     |             mstore(0x60, m3)
  1873 |     |         }
  1874 |     |     }
  1875 |     | 
  1876 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  1877 |     |         bytes32 m0;
  1878 |     |         bytes32 m1;
  1879 |     |         bytes32 m2;
  1880 |     |         bytes32 m3;
  1881 |     |         assembly {
  1882 |     |             m0 := mload(0x00)
  1883 |     |             m1 := mload(0x20)
  1884 |     |             m2 := mload(0x40)
  1885 |     |             m3 := mload(0x60)
  1886 |     |             // Selector of `log(uint256,uint256,bool)`.
  1887 |     |             mstore(0x00, 0x4766da72)
  1888 |     |             mstore(0x20, p0)
  1889 |     |             mstore(0x40, p1)
  1890 |     |             mstore(0x60, p2)
  1891 |     |         }
  1892 |     |         _sendLogPayload(0x1c, 0x64);
  1893 |     |         assembly {
  1894 |     |             mstore(0x00, m0)
  1895 |     |             mstore(0x20, m1)
  1896 |     |             mstore(0x40, m2)
  1897 |     |             mstore(0x60, m3)
  1898 |     |         }
  1899 |     |     }
  1900 |     | 
  1901 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  1902 |     |         bytes32 m0;
  1903 |     |         bytes32 m1;
  1904 |     |         bytes32 m2;
  1905 |     |         bytes32 m3;
  1906 |     |         assembly {
  1907 |     |             m0 := mload(0x00)
  1908 |     |             m1 := mload(0x20)
  1909 |     |             m2 := mload(0x40)
  1910 |     |             m3 := mload(0x60)
  1911 |     |             // Selector of `log(uint256,uint256,uint256)`.
  1912 |     |             mstore(0x00, 0xd1ed7a3c)
  1913 |     |             mstore(0x20, p0)
  1914 |     |             mstore(0x40, p1)
  1915 |     |             mstore(0x60, p2)
  1916 |     |         }
  1917 |     |         _sendLogPayload(0x1c, 0x64);
  1918 |     |         assembly {
  1919 |     |             mstore(0x00, m0)
  1920 |     |             mstore(0x20, m1)
  1921 |     |             mstore(0x40, m2)
  1922 |     |             mstore(0x60, m3)
  1923 |     |         }
  1924 |     |     }
  1925 |     | 
  1926 |     |     function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {
  1927 |     |         bytes32 m0;
  1928 |     |         bytes32 m1;
  1929 |     |         bytes32 m2;
  1930 |     |         bytes32 m3;
  1931 |     |         bytes32 m4;
  1932 |     |         bytes32 m5;
  1933 |     |         assembly {
  1934 |     |             function writeString(pos, w) {
  1935 |     |                 let length := 0
  1936 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1937 |     |                 mstore(pos, length)
  1938 |     |                 let shift := sub(256, shl(3, length))
  1939 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1940 |     |             }
  1941 |     |             m0 := mload(0x00)
  1942 |     |             m1 := mload(0x20)
  1943 |     |             m2 := mload(0x40)
  1944 |     |             m3 := mload(0x60)
  1945 |     |             m4 := mload(0x80)
  1946 |     |             m5 := mload(0xa0)
  1947 |     |             // Selector of `log(uint256,uint256,string)`.
  1948 |     |             mstore(0x00, 0x71d04af2)
  1949 |     |             mstore(0x20, p0)
  1950 |     |             mstore(0x40, p1)
  1951 |     |             mstore(0x60, 0x60)
  1952 |     |             writeString(0x80, p2)
  1953 |     |         }
  1954 |     |         _sendLogPayload(0x1c, 0xa4);
  1955 |     |         assembly {
  1956 |     |             mstore(0x00, m0)
  1957 |     |             mstore(0x20, m1)
  1958 |     |             mstore(0x40, m2)
  1959 |     |             mstore(0x60, m3)
  1960 |     |             mstore(0x80, m4)
  1961 |     |             mstore(0xa0, m5)
  1962 |     |         }
  1963 |     |     }
  1964 |     | 
  1965 |     |     function log(uint256 p0, bytes32 p1, address p2) internal pure {
  1966 |     |         bytes32 m0;
  1967 |     |         bytes32 m1;
  1968 |     |         bytes32 m2;
  1969 |     |         bytes32 m3;
  1970 |     |         bytes32 m4;
  1971 |     |         bytes32 m5;
  1972 |     |         assembly {
  1973 |     |             function writeString(pos, w) {
  1974 |     |                 let length := 0
  1975 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1976 |     |                 mstore(pos, length)
  1977 |     |                 let shift := sub(256, shl(3, length))
  1978 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1979 |     |             }
  1980 |     |             m0 := mload(0x00)
  1981 |     |             m1 := mload(0x20)
  1982 |     |             m2 := mload(0x40)
  1983 |     |             m3 := mload(0x60)
  1984 |     |             m4 := mload(0x80)
  1985 |     |             m5 := mload(0xa0)
  1986 |     |             // Selector of `log(uint256,string,address)`.
  1987 |     |             mstore(0x00, 0x7afac959)
  1988 |     |             mstore(0x20, p0)
  1989 |     |             mstore(0x40, 0x60)
  1990 |     |             mstore(0x60, p2)
  1991 |     |             writeString(0x80, p1)
  1992 |     |         }
  1993 |     |         _sendLogPayload(0x1c, 0xa4);
  1994 |     |         assembly {
  1995 |     |             mstore(0x00, m0)
  1996 |     |             mstore(0x20, m1)
  1997 |     |             mstore(0x40, m2)
  1998 |     |             mstore(0x60, m3)
  1999 |     |             mstore(0x80, m4)
  2000 |     |             mstore(0xa0, m5)
  2001 |     |         }
  2002 |     |     }
  2003 |     | 
  2004 |     |     function log(uint256 p0, bytes32 p1, bool p2) internal pure {
  2005 |     |         bytes32 m0;
  2006 |     |         bytes32 m1;
  2007 |     |         bytes32 m2;
  2008 |     |         bytes32 m3;
  2009 |     |         bytes32 m4;
  2010 |     |         bytes32 m5;
  2011 |     |         assembly {
  2012 |     |             function writeString(pos, w) {
  2013 |     |                 let length := 0
  2014 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2015 |     |                 mstore(pos, length)
  2016 |     |                 let shift := sub(256, shl(3, length))
  2017 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2018 |     |             }
  2019 |     |             m0 := mload(0x00)
  2020 |     |             m1 := mload(0x20)
  2021 |     |             m2 := mload(0x40)
  2022 |     |             m3 := mload(0x60)
  2023 |     |             m4 := mload(0x80)
  2024 |     |             m5 := mload(0xa0)
  2025 |     |             // Selector of `log(uint256,string,bool)`.
  2026 |     |             mstore(0x00, 0x4ceda75a)
  2027 |     |             mstore(0x20, p0)
  2028 |     |             mstore(0x40, 0x60)
  2029 |     |             mstore(0x60, p2)
  2030 |     |             writeString(0x80, p1)
  2031 |     |         }
  2032 |     |         _sendLogPayload(0x1c, 0xa4);
  2033 |     |         assembly {
  2034 |     |             mstore(0x00, m0)
  2035 |     |             mstore(0x20, m1)
  2036 |     |             mstore(0x40, m2)
  2037 |     |             mstore(0x60, m3)
  2038 |     |             mstore(0x80, m4)
  2039 |     |             mstore(0xa0, m5)
  2040 |     |         }
  2041 |     |     }
  2042 |     | 
  2043 |     |     function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {
  2044 |     |         bytes32 m0;
  2045 |     |         bytes32 m1;
  2046 |     |         bytes32 m2;
  2047 |     |         bytes32 m3;
  2048 |     |         bytes32 m4;
  2049 |     |         bytes32 m5;
  2050 |     |         assembly {
  2051 |     |             function writeString(pos, w) {
  2052 |     |                 let length := 0
  2053 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2054 |     |                 mstore(pos, length)
  2055 |     |                 let shift := sub(256, shl(3, length))
  2056 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2057 |     |             }
  2058 |     |             m0 := mload(0x00)
  2059 |     |             m1 := mload(0x20)
  2060 |     |             m2 := mload(0x40)
  2061 |     |             m3 := mload(0x60)
  2062 |     |             m4 := mload(0x80)
  2063 |     |             m5 := mload(0xa0)
  2064 |     |             // Selector of `log(uint256,string,uint256)`.
  2065 |     |             mstore(0x00, 0x37aa7d4c)
  2066 |     |             mstore(0x20, p0)
  2067 |     |             mstore(0x40, 0x60)
  2068 |     |             mstore(0x60, p2)
  2069 |     |             writeString(0x80, p1)
  2070 |     |         }
  2071 |     |         _sendLogPayload(0x1c, 0xa4);
  2072 |     |         assembly {
  2073 |     |             mstore(0x00, m0)
  2074 |     |             mstore(0x20, m1)
  2075 |     |             mstore(0x40, m2)
  2076 |     |             mstore(0x60, m3)
  2077 |     |             mstore(0x80, m4)
  2078 |     |             mstore(0xa0, m5)
  2079 |     |         }
  2080 |     |     }
  2081 |     | 
  2082 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {
  2083 |     |         bytes32 m0;
  2084 |     |         bytes32 m1;
  2085 |     |         bytes32 m2;
  2086 |     |         bytes32 m3;
  2087 |     |         bytes32 m4;
  2088 |     |         bytes32 m5;
  2089 |     |         bytes32 m6;
  2090 |     |         bytes32 m7;
  2091 |     |         assembly {
  2092 |     |             function writeString(pos, w) {
  2093 |     |                 let length := 0
  2094 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2095 |     |                 mstore(pos, length)
  2096 |     |                 let shift := sub(256, shl(3, length))
  2097 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2098 |     |             }
  2099 |     |             m0 := mload(0x00)
  2100 |     |             m1 := mload(0x20)
  2101 |     |             m2 := mload(0x40)
  2102 |     |             m3 := mload(0x60)
  2103 |     |             m4 := mload(0x80)
  2104 |     |             m5 := mload(0xa0)
  2105 |     |             m6 := mload(0xc0)
  2106 |     |             m7 := mload(0xe0)
  2107 |     |             // Selector of `log(uint256,string,string)`.
  2108 |     |             mstore(0x00, 0xb115611f)
  2109 |     |             mstore(0x20, p0)
  2110 |     |             mstore(0x40, 0x60)
  2111 |     |             mstore(0x60, 0xa0)
  2112 |     |             writeString(0x80, p1)
  2113 |     |             writeString(0xc0, p2)
  2114 |     |         }
  2115 |     |         _sendLogPayload(0x1c, 0xe4);
  2116 |     |         assembly {
  2117 |     |             mstore(0x00, m0)
  2118 |     |             mstore(0x20, m1)
  2119 |     |             mstore(0x40, m2)
  2120 |     |             mstore(0x60, m3)
  2121 |     |             mstore(0x80, m4)
  2122 |     |             mstore(0xa0, m5)
  2123 |     |             mstore(0xc0, m6)
  2124 |     |             mstore(0xe0, m7)
  2125 |     |         }
  2126 |     |     }
  2127 |     | 
  2128 |     |     function log(bytes32 p0, address p1, address p2) internal pure {
  2129 |     |         bytes32 m0;
  2130 |     |         bytes32 m1;
  2131 |     |         bytes32 m2;
  2132 |     |         bytes32 m3;
  2133 |     |         bytes32 m4;
  2134 |     |         bytes32 m5;
  2135 |     |         assembly {
  2136 |     |             function writeString(pos, w) {
  2137 |     |                 let length := 0
  2138 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2139 |     |                 mstore(pos, length)
  2140 |     |                 let shift := sub(256, shl(3, length))
  2141 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2142 |     |             }
  2143 |     |             m0 := mload(0x00)
  2144 |     |             m1 := mload(0x20)
  2145 |     |             m2 := mload(0x40)
  2146 |     |             m3 := mload(0x60)
  2147 |     |             m4 := mload(0x80)
  2148 |     |             m5 := mload(0xa0)
  2149 |     |             // Selector of `log(string,address,address)`.
  2150 |     |             mstore(0x00, 0xfcec75e0)
  2151 |     |             mstore(0x20, 0x60)
  2152 |     |             mstore(0x40, p1)
  2153 |     |             mstore(0x60, p2)
  2154 |     |             writeString(0x80, p0)
  2155 |     |         }
  2156 |     |         _sendLogPayload(0x1c, 0xa4);
  2157 |     |         assembly {
  2158 |     |             mstore(0x00, m0)
  2159 |     |             mstore(0x20, m1)
  2160 |     |             mstore(0x40, m2)
  2161 |     |             mstore(0x60, m3)
  2162 |     |             mstore(0x80, m4)
  2163 |     |             mstore(0xa0, m5)
  2164 |     |         }
  2165 |     |     }
  2166 |     | 
  2167 |     |     function log(bytes32 p0, address p1, bool p2) internal pure {
  2168 |     |         bytes32 m0;
  2169 |     |         bytes32 m1;
  2170 |     |         bytes32 m2;
  2171 |     |         bytes32 m3;
  2172 |     |         bytes32 m4;
  2173 |     |         bytes32 m5;
  2174 |     |         assembly {
  2175 |     |             function writeString(pos, w) {
  2176 |     |                 let length := 0
  2177 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2178 |     |                 mstore(pos, length)
  2179 |     |                 let shift := sub(256, shl(3, length))
  2180 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2181 |     |             }
  2182 |     |             m0 := mload(0x00)
  2183 |     |             m1 := mload(0x20)
  2184 |     |             m2 := mload(0x40)
  2185 |     |             m3 := mload(0x60)
  2186 |     |             m4 := mload(0x80)
  2187 |     |             m5 := mload(0xa0)
  2188 |     |             // Selector of `log(string,address,bool)`.
  2189 |     |             mstore(0x00, 0xc91d5ed4)
  2190 |     |             mstore(0x20, 0x60)
  2191 |     |             mstore(0x40, p1)
  2192 |     |             mstore(0x60, p2)
  2193 |     |             writeString(0x80, p0)
  2194 |     |         }
  2195 |     |         _sendLogPayload(0x1c, 0xa4);
  2196 |     |         assembly {
  2197 |     |             mstore(0x00, m0)
  2198 |     |             mstore(0x20, m1)
  2199 |     |             mstore(0x40, m2)
  2200 |     |             mstore(0x60, m3)
  2201 |     |             mstore(0x80, m4)
  2202 |     |             mstore(0xa0, m5)
  2203 |     |         }
  2204 |     |     }
  2205 |     | 
  2206 |     |     function log(bytes32 p0, address p1, uint256 p2) internal pure {
  2207 |     |         bytes32 m0;
  2208 |     |         bytes32 m1;
  2209 |     |         bytes32 m2;
  2210 |     |         bytes32 m3;
  2211 |     |         bytes32 m4;
  2212 |     |         bytes32 m5;
  2213 |     |         assembly {
  2214 |     |             function writeString(pos, w) {
  2215 |     |                 let length := 0
  2216 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2217 |     |                 mstore(pos, length)
  2218 |     |                 let shift := sub(256, shl(3, length))
  2219 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2220 |     |             }
  2221 |     |             m0 := mload(0x00)
  2222 |     |             m1 := mload(0x20)
  2223 |     |             m2 := mload(0x40)
  2224 |     |             m3 := mload(0x60)
  2225 |     |             m4 := mload(0x80)
  2226 |     |             m5 := mload(0xa0)
  2227 |     |             // Selector of `log(string,address,uint256)`.
  2228 |     |             mstore(0x00, 0x0d26b925)
  2229 |     |             mstore(0x20, 0x60)
  2230 |     |             mstore(0x40, p1)
  2231 |     |             mstore(0x60, p2)
  2232 |     |             writeString(0x80, p0)
  2233 |     |         }
  2234 |     |         _sendLogPayload(0x1c, 0xa4);
  2235 |     |         assembly {
  2236 |     |             mstore(0x00, m0)
  2237 |     |             mstore(0x20, m1)
  2238 |     |             mstore(0x40, m2)
  2239 |     |             mstore(0x60, m3)
  2240 |     |             mstore(0x80, m4)
  2241 |     |             mstore(0xa0, m5)
  2242 |     |         }
  2243 |     |     }
  2244 |     | 
  2245 |     |     function log(bytes32 p0, address p1, bytes32 p2) internal pure {
  2246 |     |         bytes32 m0;
  2247 |     |         bytes32 m1;
  2248 |     |         bytes32 m2;
  2249 |     |         bytes32 m3;
  2250 |     |         bytes32 m4;
  2251 |     |         bytes32 m5;
  2252 |     |         bytes32 m6;
  2253 |     |         bytes32 m7;
  2254 |     |         assembly {
  2255 |     |             function writeString(pos, w) {
  2256 |     |                 let length := 0
  2257 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2258 |     |                 mstore(pos, length)
  2259 |     |                 let shift := sub(256, shl(3, length))
  2260 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2261 |     |             }
  2262 |     |             m0 := mload(0x00)
  2263 |     |             m1 := mload(0x20)
  2264 |     |             m2 := mload(0x40)
  2265 |     |             m3 := mload(0x60)
  2266 |     |             m4 := mload(0x80)
  2267 |     |             m5 := mload(0xa0)
  2268 |     |             m6 := mload(0xc0)
  2269 |     |             m7 := mload(0xe0)
  2270 |     |             // Selector of `log(string,address,string)`.
  2271 |     |             mstore(0x00, 0xe0e9ad4f)
  2272 |     |             mstore(0x20, 0x60)
  2273 |     |             mstore(0x40, p1)
  2274 |     |             mstore(0x60, 0xa0)
  2275 |     |             writeString(0x80, p0)
  2276 |     |             writeString(0xc0, p2)
  2277 |     |         }
  2278 |     |         _sendLogPayload(0x1c, 0xe4);
  2279 |     |         assembly {
  2280 |     |             mstore(0x00, m0)
  2281 |     |             mstore(0x20, m1)
  2282 |     |             mstore(0x40, m2)
  2283 |     |             mstore(0x60, m3)
  2284 |     |             mstore(0x80, m4)
  2285 |     |             mstore(0xa0, m5)
  2286 |     |             mstore(0xc0, m6)
  2287 |     |             mstore(0xe0, m7)
  2288 |     |         }
  2289 |     |     }
  2290 |     | 
  2291 |     |     function log(bytes32 p0, bool p1, address p2) internal pure {
  2292 |     |         bytes32 m0;
  2293 |     |         bytes32 m1;
  2294 |     |         bytes32 m2;
  2295 |     |         bytes32 m3;
  2296 |     |         bytes32 m4;
  2297 |     |         bytes32 m5;
  2298 |     |         assembly {
  2299 |     |             function writeString(pos, w) {
  2300 |     |                 let length := 0
  2301 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2302 |     |                 mstore(pos, length)
  2303 |     |                 let shift := sub(256, shl(3, length))
  2304 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2305 |     |             }
  2306 |     |             m0 := mload(0x00)
  2307 |     |             m1 := mload(0x20)
  2308 |     |             m2 := mload(0x40)
  2309 |     |             m3 := mload(0x60)
  2310 |     |             m4 := mload(0x80)
  2311 |     |             m5 := mload(0xa0)
  2312 |     |             // Selector of `log(string,bool,address)`.
  2313 |     |             mstore(0x00, 0x932bbb38)
  2314 |     |             mstore(0x20, 0x60)
  2315 |     |             mstore(0x40, p1)
  2316 |     |             mstore(0x60, p2)
  2317 |     |             writeString(0x80, p0)
  2318 |     |         }
  2319 |     |         _sendLogPayload(0x1c, 0xa4);
  2320 |     |         assembly {
  2321 |     |             mstore(0x00, m0)
  2322 |     |             mstore(0x20, m1)
  2323 |     |             mstore(0x40, m2)
  2324 |     |             mstore(0x60, m3)
  2325 |     |             mstore(0x80, m4)
  2326 |     |             mstore(0xa0, m5)
  2327 |     |         }
  2328 |     |     }
  2329 |     | 
  2330 |     |     function log(bytes32 p0, bool p1, bool p2) internal pure {
  2331 |     |         bytes32 m0;
  2332 |     |         bytes32 m1;
  2333 |     |         bytes32 m2;
  2334 |     |         bytes32 m3;
  2335 |     |         bytes32 m4;
  2336 |     |         bytes32 m5;
  2337 |     |         assembly {
  2338 |     |             function writeString(pos, w) {
  2339 |     |                 let length := 0
  2340 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2341 |     |                 mstore(pos, length)
  2342 |     |                 let shift := sub(256, shl(3, length))
  2343 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2344 |     |             }
  2345 |     |             m0 := mload(0x00)
  2346 |     |             m1 := mload(0x20)
  2347 |     |             m2 := mload(0x40)
  2348 |     |             m3 := mload(0x60)
  2349 |     |             m4 := mload(0x80)
  2350 |     |             m5 := mload(0xa0)
  2351 |     |             // Selector of `log(string,bool,bool)`.
  2352 |     |             mstore(0x00, 0x850b7ad6)
  2353 |     |             mstore(0x20, 0x60)
  2354 |     |             mstore(0x40, p1)
  2355 |     |             mstore(0x60, p2)
  2356 |     |             writeString(0x80, p0)
  2357 |     |         }
  2358 |     |         _sendLogPayload(0x1c, 0xa4);
  2359 |     |         assembly {
  2360 |     |             mstore(0x00, m0)
  2361 |     |             mstore(0x20, m1)
  2362 |     |             mstore(0x40, m2)
  2363 |     |             mstore(0x60, m3)
  2364 |     |             mstore(0x80, m4)
  2365 |     |             mstore(0xa0, m5)
  2366 |     |         }
  2367 |     |     }
  2368 |     | 
  2369 |     |     function log(bytes32 p0, bool p1, uint256 p2) internal pure {
  2370 |     |         bytes32 m0;
  2371 |     |         bytes32 m1;
  2372 |     |         bytes32 m2;
  2373 |     |         bytes32 m3;
  2374 |     |         bytes32 m4;
  2375 |     |         bytes32 m5;
  2376 |     |         assembly {
  2377 |     |             function writeString(pos, w) {
  2378 |     |                 let length := 0
  2379 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2380 |     |                 mstore(pos, length)
  2381 |     |                 let shift := sub(256, shl(3, length))
  2382 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2383 |     |             }
  2384 |     |             m0 := mload(0x00)
  2385 |     |             m1 := mload(0x20)
  2386 |     |             m2 := mload(0x40)
  2387 |     |             m3 := mload(0x60)
  2388 |     |             m4 := mload(0x80)
  2389 |     |             m5 := mload(0xa0)
  2390 |     |             // Selector of `log(string,bool,uint256)`.
  2391 |     |             mstore(0x00, 0xc95958d6)
  2392 |     |             mstore(0x20, 0x60)
  2393 |     |             mstore(0x40, p1)
  2394 |     |             mstore(0x60, p2)
  2395 |     |             writeString(0x80, p0)
  2396 |     |         }
  2397 |     |         _sendLogPayload(0x1c, 0xa4);
  2398 |     |         assembly {
  2399 |     |             mstore(0x00, m0)
  2400 |     |             mstore(0x20, m1)
  2401 |     |             mstore(0x40, m2)
  2402 |     |             mstore(0x60, m3)
  2403 |     |             mstore(0x80, m4)
  2404 |     |             mstore(0xa0, m5)
  2405 |     |         }
  2406 |     |     }
  2407 |     | 
  2408 |     |     function log(bytes32 p0, bool p1, bytes32 p2) internal pure {
  2409 |     |         bytes32 m0;
  2410 |     |         bytes32 m1;
  2411 |     |         bytes32 m2;
  2412 |     |         bytes32 m3;
  2413 |     |         bytes32 m4;
  2414 |     |         bytes32 m5;
  2415 |     |         bytes32 m6;
  2416 |     |         bytes32 m7;
  2417 |     |         assembly {
  2418 |     |             function writeString(pos, w) {
  2419 |     |                 let length := 0
  2420 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2421 |     |                 mstore(pos, length)
  2422 |     |                 let shift := sub(256, shl(3, length))
  2423 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2424 |     |             }
  2425 |     |             m0 := mload(0x00)
  2426 |     |             m1 := mload(0x20)
  2427 |     |             m2 := mload(0x40)
  2428 |     |             m3 := mload(0x60)
  2429 |     |             m4 := mload(0x80)
  2430 |     |             m5 := mload(0xa0)
  2431 |     |             m6 := mload(0xc0)
  2432 |     |             m7 := mload(0xe0)
  2433 |     |             // Selector of `log(string,bool,string)`.
  2434 |     |             mstore(0x00, 0xe298f47d)
  2435 |     |             mstore(0x20, 0x60)
  2436 |     |             mstore(0x40, p1)
  2437 |     |             mstore(0x60, 0xa0)
  2438 |     |             writeString(0x80, p0)
  2439 |     |             writeString(0xc0, p2)
  2440 |     |         }
  2441 |     |         _sendLogPayload(0x1c, 0xe4);
  2442 |     |         assembly {
  2443 |     |             mstore(0x00, m0)
  2444 |     |             mstore(0x20, m1)
  2445 |     |             mstore(0x40, m2)
  2446 |     |             mstore(0x60, m3)
  2447 |     |             mstore(0x80, m4)
  2448 |     |             mstore(0xa0, m5)
  2449 |     |             mstore(0xc0, m6)
  2450 |     |             mstore(0xe0, m7)
  2451 |     |         }
  2452 |     |     }
  2453 |     | 
  2454 |     |     function log(bytes32 p0, uint256 p1, address p2) internal pure {
  2455 |     |         bytes32 m0;
  2456 |     |         bytes32 m1;
  2457 |     |         bytes32 m2;
  2458 |     |         bytes32 m3;
  2459 |     |         bytes32 m4;
  2460 |     |         bytes32 m5;
  2461 |     |         assembly {
  2462 |     |             function writeString(pos, w) {
  2463 |     |                 let length := 0
  2464 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2465 |     |                 mstore(pos, length)
  2466 |     |                 let shift := sub(256, shl(3, length))
  2467 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2468 |     |             }
  2469 |     |             m0 := mload(0x00)
  2470 |     |             m1 := mload(0x20)
  2471 |     |             m2 := mload(0x40)
  2472 |     |             m3 := mload(0x60)
  2473 |     |             m4 := mload(0x80)
  2474 |     |             m5 := mload(0xa0)
  2475 |     |             // Selector of `log(string,uint256,address)`.
  2476 |     |             mstore(0x00, 0x1c7ec448)
  2477 |     |             mstore(0x20, 0x60)
  2478 |     |             mstore(0x40, p1)
  2479 |     |             mstore(0x60, p2)
  2480 |     |             writeString(0x80, p0)
  2481 |     |         }
  2482 |     |         _sendLogPayload(0x1c, 0xa4);
  2483 |     |         assembly {
  2484 |     |             mstore(0x00, m0)
  2485 |     |             mstore(0x20, m1)
  2486 |     |             mstore(0x40, m2)
  2487 |     |             mstore(0x60, m3)
  2488 |     |             mstore(0x80, m4)
  2489 |     |             mstore(0xa0, m5)
  2490 |     |         }
  2491 |     |     }
  2492 |     | 
  2493 |     |     function log(bytes32 p0, uint256 p1, bool p2) internal pure {
  2494 |     |         bytes32 m0;
  2495 |     |         bytes32 m1;
  2496 |     |         bytes32 m2;
  2497 |     |         bytes32 m3;
  2498 |     |         bytes32 m4;
  2499 |     |         bytes32 m5;
  2500 |     |         assembly {
  2501 |     |             function writeString(pos, w) {
  2502 |     |                 let length := 0
  2503 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2504 |     |                 mstore(pos, length)
  2505 |     |                 let shift := sub(256, shl(3, length))
  2506 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2507 |     |             }
  2508 |     |             m0 := mload(0x00)
  2509 |     |             m1 := mload(0x20)
  2510 |     |             m2 := mload(0x40)
  2511 |     |             m3 := mload(0x60)
  2512 |     |             m4 := mload(0x80)
  2513 |     |             m5 := mload(0xa0)
  2514 |     |             // Selector of `log(string,uint256,bool)`.
  2515 |     |             mstore(0x00, 0xca7733b1)
  2516 |     |             mstore(0x20, 0x60)
  2517 |     |             mstore(0x40, p1)
  2518 |     |             mstore(0x60, p2)
  2519 |     |             writeString(0x80, p0)
  2520 |     |         }
  2521 |     |         _sendLogPayload(0x1c, 0xa4);
  2522 |     |         assembly {
  2523 |     |             mstore(0x00, m0)
  2524 |     |             mstore(0x20, m1)
  2525 |     |             mstore(0x40, m2)
  2526 |     |             mstore(0x60, m3)
  2527 |     |             mstore(0x80, m4)
  2528 |     |             mstore(0xa0, m5)
  2529 |     |         }
  2530 |     |     }
  2531 |     | 
  2532 |     |     function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {
  2533 |     |         bytes32 m0;
  2534 |     |         bytes32 m1;
  2535 |     |         bytes32 m2;
  2536 |     |         bytes32 m3;
  2537 |     |         bytes32 m4;
  2538 |     |         bytes32 m5;
  2539 |     |         assembly {
  2540 |     |             function writeString(pos, w) {
  2541 |     |                 let length := 0
  2542 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2543 |     |                 mstore(pos, length)
  2544 |     |                 let shift := sub(256, shl(3, length))
  2545 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2546 |     |             }
  2547 |     |             m0 := mload(0x00)
  2548 |     |             m1 := mload(0x20)
  2549 |     |             m2 := mload(0x40)
  2550 |     |             m3 := mload(0x60)
  2551 |     |             m4 := mload(0x80)
  2552 |     |             m5 := mload(0xa0)
  2553 |     |             // Selector of `log(string,uint256,uint256)`.
  2554 |     |             mstore(0x00, 0xca47c4eb)
  2555 |     |             mstore(0x20, 0x60)
  2556 |     |             mstore(0x40, p1)
  2557 |     |             mstore(0x60, p2)
  2558 |     |             writeString(0x80, p0)
  2559 |     |         }
  2560 |     |         _sendLogPayload(0x1c, 0xa4);
  2561 |     |         assembly {
  2562 |     |             mstore(0x00, m0)
  2563 |     |             mstore(0x20, m1)
  2564 |     |             mstore(0x40, m2)
  2565 |     |             mstore(0x60, m3)
  2566 |     |             mstore(0x80, m4)
  2567 |     |             mstore(0xa0, m5)
  2568 |     |         }
  2569 |     |     }
  2570 |     | 
  2571 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {
  2572 |     |         bytes32 m0;
  2573 |     |         bytes32 m1;
  2574 |     |         bytes32 m2;
  2575 |     |         bytes32 m3;
  2576 |     |         bytes32 m4;
  2577 |     |         bytes32 m5;
  2578 |     |         bytes32 m6;
  2579 |     |         bytes32 m7;
  2580 |     |         assembly {
  2581 |     |             function writeString(pos, w) {
  2582 |     |                 let length := 0
  2583 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2584 |     |                 mstore(pos, length)
  2585 |     |                 let shift := sub(256, shl(3, length))
  2586 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2587 |     |             }
  2588 |     |             m0 := mload(0x00)
  2589 |     |             m1 := mload(0x20)
  2590 |     |             m2 := mload(0x40)
  2591 |     |             m3 := mload(0x60)
  2592 |     |             m4 := mload(0x80)
  2593 |     |             m5 := mload(0xa0)
  2594 |     |             m6 := mload(0xc0)
  2595 |     |             m7 := mload(0xe0)
  2596 |     |             // Selector of `log(string,uint256,string)`.
  2597 |     |             mstore(0x00, 0x5970e089)
  2598 |     |             mstore(0x20, 0x60)
  2599 |     |             mstore(0x40, p1)
  2600 |     |             mstore(0x60, 0xa0)
  2601 |     |             writeString(0x80, p0)
  2602 |     |             writeString(0xc0, p2)
  2603 |     |         }
  2604 |     |         _sendLogPayload(0x1c, 0xe4);
  2605 |     |         assembly {
  2606 |     |             mstore(0x00, m0)
  2607 |     |             mstore(0x20, m1)
  2608 |     |             mstore(0x40, m2)
  2609 |     |             mstore(0x60, m3)
  2610 |     |             mstore(0x80, m4)
  2611 |     |             mstore(0xa0, m5)
  2612 |     |             mstore(0xc0, m6)
  2613 |     |             mstore(0xe0, m7)
  2614 |     |         }
  2615 |     |     }
  2616 |     | 
  2617 |     |     function log(bytes32 p0, bytes32 p1, address p2) internal pure {
  2618 |     |         bytes32 m0;
  2619 |     |         bytes32 m1;
  2620 |     |         bytes32 m2;
  2621 |     |         bytes32 m3;
  2622 |     |         bytes32 m4;
  2623 |     |         bytes32 m5;
  2624 |     |         bytes32 m6;
  2625 |     |         bytes32 m7;
  2626 |     |         assembly {
  2627 |     |             function writeString(pos, w) {
  2628 |     |                 let length := 0
  2629 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2630 |     |                 mstore(pos, length)
  2631 |     |                 let shift := sub(256, shl(3, length))
  2632 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2633 |     |             }
  2634 |     |             m0 := mload(0x00)
  2635 |     |             m1 := mload(0x20)
  2636 |     |             m2 := mload(0x40)
  2637 |     |             m3 := mload(0x60)
  2638 |     |             m4 := mload(0x80)
  2639 |     |             m5 := mload(0xa0)
  2640 |     |             m6 := mload(0xc0)
  2641 |     |             m7 := mload(0xe0)
  2642 |     |             // Selector of `log(string,string,address)`.
  2643 |     |             mstore(0x00, 0x95ed0195)
  2644 |     |             mstore(0x20, 0x60)
  2645 |     |             mstore(0x40, 0xa0)
  2646 |     |             mstore(0x60, p2)
  2647 |     |             writeString(0x80, p0)
  2648 |     |             writeString(0xc0, p1)
  2649 |     |         }
  2650 |     |         _sendLogPayload(0x1c, 0xe4);
  2651 |     |         assembly {
  2652 |     |             mstore(0x00, m0)
  2653 |     |             mstore(0x20, m1)
  2654 |     |             mstore(0x40, m2)
  2655 |     |             mstore(0x60, m3)
  2656 |     |             mstore(0x80, m4)
  2657 |     |             mstore(0xa0, m5)
  2658 |     |             mstore(0xc0, m6)
  2659 |     |             mstore(0xe0, m7)
  2660 |     |         }
  2661 |     |     }
  2662 |     | 
  2663 |     |     function log(bytes32 p0, bytes32 p1, bool p2) internal pure {
  2664 |     |         bytes32 m0;
  2665 |     |         bytes32 m1;
  2666 |     |         bytes32 m2;
  2667 |     |         bytes32 m3;
  2668 |     |         bytes32 m4;
  2669 |     |         bytes32 m5;
  2670 |     |         bytes32 m6;
  2671 |     |         bytes32 m7;
  2672 |     |         assembly {
  2673 |     |             function writeString(pos, w) {
  2674 |     |                 let length := 0
  2675 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2676 |     |                 mstore(pos, length)
  2677 |     |                 let shift := sub(256, shl(3, length))
  2678 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2679 |     |             }
  2680 |     |             m0 := mload(0x00)
  2681 |     |             m1 := mload(0x20)
  2682 |     |             m2 := mload(0x40)
  2683 |     |             m3 := mload(0x60)
  2684 |     |             m4 := mload(0x80)
  2685 |     |             m5 := mload(0xa0)
  2686 |     |             m6 := mload(0xc0)
  2687 |     |             m7 := mload(0xe0)
  2688 |     |             // Selector of `log(string,string,bool)`.
  2689 |     |             mstore(0x00, 0xb0e0f9b5)
  2690 |     |             mstore(0x20, 0x60)
  2691 |     |             mstore(0x40, 0xa0)
  2692 |     |             mstore(0x60, p2)
  2693 |     |             writeString(0x80, p0)
  2694 |     |             writeString(0xc0, p1)
  2695 |     |         }
  2696 |     |         _sendLogPayload(0x1c, 0xe4);
  2697 |     |         assembly {
  2698 |     |             mstore(0x00, m0)
  2699 |     |             mstore(0x20, m1)
  2700 |     |             mstore(0x40, m2)
  2701 |     |             mstore(0x60, m3)
  2702 |     |             mstore(0x80, m4)
  2703 |     |             mstore(0xa0, m5)
  2704 |     |             mstore(0xc0, m6)
  2705 |     |             mstore(0xe0, m7)
  2706 |     |         }
  2707 |     |     }
  2708 |     | 
  2709 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {
  2710 |     |         bytes32 m0;
  2711 |     |         bytes32 m1;
  2712 |     |         bytes32 m2;
  2713 |     |         bytes32 m3;
  2714 |     |         bytes32 m4;
  2715 |     |         bytes32 m5;
  2716 |     |         bytes32 m6;
  2717 |     |         bytes32 m7;
  2718 |     |         assembly {
  2719 |     |             function writeString(pos, w) {
  2720 |     |                 let length := 0
  2721 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2722 |     |                 mstore(pos, length)
  2723 |     |                 let shift := sub(256, shl(3, length))
  2724 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2725 |     |             }
  2726 |     |             m0 := mload(0x00)
  2727 |     |             m1 := mload(0x20)
  2728 |     |             m2 := mload(0x40)
  2729 |     |             m3 := mload(0x60)
  2730 |     |             m4 := mload(0x80)
  2731 |     |             m5 := mload(0xa0)
  2732 |     |             m6 := mload(0xc0)
  2733 |     |             m7 := mload(0xe0)
  2734 |     |             // Selector of `log(string,string,uint256)`.
  2735 |     |             mstore(0x00, 0x5821efa1)
  2736 |     |             mstore(0x20, 0x60)
  2737 |     |             mstore(0x40, 0xa0)
  2738 |     |             mstore(0x60, p2)
  2739 |     |             writeString(0x80, p0)
  2740 |     |             writeString(0xc0, p1)
  2741 |     |         }
  2742 |     |         _sendLogPayload(0x1c, 0xe4);
  2743 |     |         assembly {
  2744 |     |             mstore(0x00, m0)
  2745 |     |             mstore(0x20, m1)
  2746 |     |             mstore(0x40, m2)
  2747 |     |             mstore(0x60, m3)
  2748 |     |             mstore(0x80, m4)
  2749 |     |             mstore(0xa0, m5)
  2750 |     |             mstore(0xc0, m6)
  2751 |     |             mstore(0xe0, m7)
  2752 |     |         }
  2753 |     |     }
  2754 |     | 
  2755 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {
  2756 |     |         bytes32 m0;
  2757 |     |         bytes32 m1;
  2758 |     |         bytes32 m2;
  2759 |     |         bytes32 m3;
  2760 |     |         bytes32 m4;
  2761 |     |         bytes32 m5;
  2762 |     |         bytes32 m6;
  2763 |     |         bytes32 m7;
  2764 |     |         bytes32 m8;
  2765 |     |         bytes32 m9;
  2766 |     |         assembly {
  2767 |     |             function writeString(pos, w) {
  2768 |     |                 let length := 0
  2769 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2770 |     |                 mstore(pos, length)
  2771 |     |                 let shift := sub(256, shl(3, length))
  2772 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2773 |     |             }
  2774 |     |             m0 := mload(0x00)
  2775 |     |             m1 := mload(0x20)
  2776 |     |             m2 := mload(0x40)
  2777 |     |             m3 := mload(0x60)
  2778 |     |             m4 := mload(0x80)
  2779 |     |             m5 := mload(0xa0)
  2780 |     |             m6 := mload(0xc0)
  2781 |     |             m7 := mload(0xe0)
  2782 |     |             m8 := mload(0x100)
  2783 |     |             m9 := mload(0x120)
  2784 |     |             // Selector of `log(string,string,string)`.
  2785 |     |             mstore(0x00, 0x2ced7cef)
  2786 |     |             mstore(0x20, 0x60)
  2787 |     |             mstore(0x40, 0xa0)
  2788 |     |             mstore(0x60, 0xe0)
  2789 |     |             writeString(0x80, p0)
  2790 |     |             writeString(0xc0, p1)
  2791 |     |             writeString(0x100, p2)
  2792 |     |         }
  2793 |     |         _sendLogPayload(0x1c, 0x124);
  2794 |     |         assembly {
  2795 |     |             mstore(0x00, m0)
  2796 |     |             mstore(0x20, m1)
  2797 |     |             mstore(0x40, m2)
  2798 |     |             mstore(0x60, m3)
  2799 |     |             mstore(0x80, m4)
  2800 |     |             mstore(0xa0, m5)
  2801 |     |             mstore(0xc0, m6)
  2802 |     |             mstore(0xe0, m7)
  2803 |     |             mstore(0x100, m8)
  2804 |     |             mstore(0x120, m9)
  2805 |     |         }
  2806 |     |     }
  2807 |     | 
  2808 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
  2809 |     |         bytes32 m0;
  2810 |     |         bytes32 m1;
  2811 |     |         bytes32 m2;
  2812 |     |         bytes32 m3;
  2813 |     |         bytes32 m4;
  2814 |     |         assembly {
  2815 |     |             m0 := mload(0x00)
  2816 |     |             m1 := mload(0x20)
  2817 |     |             m2 := mload(0x40)
  2818 |     |             m3 := mload(0x60)
  2819 |     |             m4 := mload(0x80)
  2820 |     |             // Selector of `log(address,address,address,address)`.
  2821 |     |             mstore(0x00, 0x665bf134)
  2822 |     |             mstore(0x20, p0)
  2823 |     |             mstore(0x40, p1)
  2824 |     |             mstore(0x60, p2)
  2825 |     |             mstore(0x80, p3)
  2826 |     |         }
  2827 |     |         _sendLogPayload(0x1c, 0x84);
  2828 |     |         assembly {
  2829 |     |             mstore(0x00, m0)
  2830 |     |             mstore(0x20, m1)
  2831 |     |             mstore(0x40, m2)
  2832 |     |             mstore(0x60, m3)
  2833 |     |             mstore(0x80, m4)
  2834 |     |         }
  2835 |     |     }
  2836 |     | 
  2837 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
  2838 |     |         bytes32 m0;
  2839 |     |         bytes32 m1;
  2840 |     |         bytes32 m2;
  2841 |     |         bytes32 m3;
  2842 |     |         bytes32 m4;
  2843 |     |         assembly {
  2844 |     |             m0 := mload(0x00)
  2845 |     |             m1 := mload(0x20)
  2846 |     |             m2 := mload(0x40)
  2847 |     |             m3 := mload(0x60)
  2848 |     |             m4 := mload(0x80)
  2849 |     |             // Selector of `log(address,address,address,bool)`.
  2850 |     |             mstore(0x00, 0x0e378994)
  2851 |     |             mstore(0x20, p0)
  2852 |     |             mstore(0x40, p1)
  2853 |     |             mstore(0x60, p2)
  2854 |     |             mstore(0x80, p3)
  2855 |     |         }
  2856 |     |         _sendLogPayload(0x1c, 0x84);
  2857 |     |         assembly {
  2858 |     |             mstore(0x00, m0)
  2859 |     |             mstore(0x20, m1)
  2860 |     |             mstore(0x40, m2)
  2861 |     |             mstore(0x60, m3)
  2862 |     |             mstore(0x80, m4)
  2863 |     |         }
  2864 |     |     }
  2865 |     | 
  2866 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
  2867 |     |         bytes32 m0;
  2868 |     |         bytes32 m1;
  2869 |     |         bytes32 m2;
  2870 |     |         bytes32 m3;
  2871 |     |         bytes32 m4;
  2872 |     |         assembly {
  2873 |     |             m0 := mload(0x00)
  2874 |     |             m1 := mload(0x20)
  2875 |     |             m2 := mload(0x40)
  2876 |     |             m3 := mload(0x60)
  2877 |     |             m4 := mload(0x80)
  2878 |     |             // Selector of `log(address,address,address,uint256)`.
  2879 |     |             mstore(0x00, 0x94250d77)
  2880 |     |             mstore(0x20, p0)
  2881 |     |             mstore(0x40, p1)
  2882 |     |             mstore(0x60, p2)
  2883 |     |             mstore(0x80, p3)
  2884 |     |         }
  2885 |     |         _sendLogPayload(0x1c, 0x84);
  2886 |     |         assembly {
  2887 |     |             mstore(0x00, m0)
  2888 |     |             mstore(0x20, m1)
  2889 |     |             mstore(0x40, m2)
  2890 |     |             mstore(0x60, m3)
  2891 |     |             mstore(0x80, m4)
  2892 |     |         }
  2893 |     |     }
  2894 |     | 
  2895 |     |     function log(address p0, address p1, address p2, bytes32 p3) internal pure {
  2896 |     |         bytes32 m0;
  2897 |     |         bytes32 m1;
  2898 |     |         bytes32 m2;
  2899 |     |         bytes32 m3;
  2900 |     |         bytes32 m4;
  2901 |     |         bytes32 m5;
  2902 |     |         bytes32 m6;
  2903 |     |         assembly {
  2904 |     |             function writeString(pos, w) {
  2905 |     |                 let length := 0
  2906 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2907 |     |                 mstore(pos, length)
  2908 |     |                 let shift := sub(256, shl(3, length))
  2909 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2910 |     |             }
  2911 |     |             m0 := mload(0x00)
  2912 |     |             m1 := mload(0x20)
  2913 |     |             m2 := mload(0x40)
  2914 |     |             m3 := mload(0x60)
  2915 |     |             m4 := mload(0x80)
  2916 |     |             m5 := mload(0xa0)
  2917 |     |             m6 := mload(0xc0)
  2918 |     |             // Selector of `log(address,address,address,string)`.
  2919 |     |             mstore(0x00, 0xf808da20)
  2920 |     |             mstore(0x20, p0)
  2921 |     |             mstore(0x40, p1)
  2922 |     |             mstore(0x60, p2)
  2923 |     |             mstore(0x80, 0x80)
  2924 |     |             writeString(0xa0, p3)
  2925 |     |         }
  2926 |     |         _sendLogPayload(0x1c, 0xc4);
  2927 |     |         assembly {
  2928 |     |             mstore(0x00, m0)
  2929 |     |             mstore(0x20, m1)
  2930 |     |             mstore(0x40, m2)
  2931 |     |             mstore(0x60, m3)
  2932 |     |             mstore(0x80, m4)
  2933 |     |             mstore(0xa0, m5)
  2934 |     |             mstore(0xc0, m6)
  2935 |     |         }
  2936 |     |     }
  2937 |     | 
  2938 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
  2939 |     |         bytes32 m0;
  2940 |     |         bytes32 m1;
  2941 |     |         bytes32 m2;
  2942 |     |         bytes32 m3;
  2943 |     |         bytes32 m4;
  2944 |     |         assembly {
  2945 |     |             m0 := mload(0x00)
  2946 |     |             m1 := mload(0x20)
  2947 |     |             m2 := mload(0x40)
  2948 |     |             m3 := mload(0x60)
  2949 |     |             m4 := mload(0x80)
  2950 |     |             // Selector of `log(address,address,bool,address)`.
  2951 |     |             mstore(0x00, 0x9f1bc36e)
  2952 |     |             mstore(0x20, p0)
  2953 |     |             mstore(0x40, p1)
  2954 |     |             mstore(0x60, p2)
  2955 |     |             mstore(0x80, p3)
  2956 |     |         }
  2957 |     |         _sendLogPayload(0x1c, 0x84);
  2958 |     |         assembly {
  2959 |     |             mstore(0x00, m0)
  2960 |     |             mstore(0x20, m1)
  2961 |     |             mstore(0x40, m2)
  2962 |     |             mstore(0x60, m3)
  2963 |     |             mstore(0x80, m4)
  2964 |     |         }
  2965 |     |     }
  2966 |     | 
  2967 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
  2968 |     |         bytes32 m0;
  2969 |     |         bytes32 m1;
  2970 |     |         bytes32 m2;
  2971 |     |         bytes32 m3;
  2972 |     |         bytes32 m4;
  2973 |     |         assembly {
  2974 |     |             m0 := mload(0x00)
  2975 |     |             m1 := mload(0x20)
  2976 |     |             m2 := mload(0x40)
  2977 |     |             m3 := mload(0x60)
  2978 |     |             m4 := mload(0x80)
  2979 |     |             // Selector of `log(address,address,bool,bool)`.
  2980 |     |             mstore(0x00, 0x2cd4134a)
  2981 |     |             mstore(0x20, p0)
  2982 |     |             mstore(0x40, p1)
  2983 |     |             mstore(0x60, p2)
  2984 |     |             mstore(0x80, p3)
  2985 |     |         }
  2986 |     |         _sendLogPayload(0x1c, 0x84);
  2987 |     |         assembly {
  2988 |     |             mstore(0x00, m0)
  2989 |     |             mstore(0x20, m1)
  2990 |     |             mstore(0x40, m2)
  2991 |     |             mstore(0x60, m3)
  2992 |     |             mstore(0x80, m4)
  2993 |     |         }
  2994 |     |     }
  2995 |     | 
  2996 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
  2997 |     |         bytes32 m0;
  2998 |     |         bytes32 m1;
  2999 |     |         bytes32 m2;
  3000 |     |         bytes32 m3;
  3001 |     |         bytes32 m4;
  3002 |     |         assembly {
  3003 |     |             m0 := mload(0x00)
  3004 |     |             m1 := mload(0x20)
  3005 |     |             m2 := mload(0x40)
  3006 |     |             m3 := mload(0x60)
  3007 |     |             m4 := mload(0x80)
  3008 |     |             // Selector of `log(address,address,bool,uint256)`.
  3009 |     |             mstore(0x00, 0x3971e78c)
  3010 |     |             mstore(0x20, p0)
  3011 |     |             mstore(0x40, p1)
  3012 |     |             mstore(0x60, p2)
  3013 |     |             mstore(0x80, p3)
  3014 |     |         }
  3015 |     |         _sendLogPayload(0x1c, 0x84);
  3016 |     |         assembly {
  3017 |     |             mstore(0x00, m0)
  3018 |     |             mstore(0x20, m1)
  3019 |     |             mstore(0x40, m2)
  3020 |     |             mstore(0x60, m3)
  3021 |     |             mstore(0x80, m4)
  3022 |     |         }
  3023 |     |     }
  3024 |     | 
  3025 |     |     function log(address p0, address p1, bool p2, bytes32 p3) internal pure {
  3026 |     |         bytes32 m0;
  3027 |     |         bytes32 m1;
  3028 |     |         bytes32 m2;
  3029 |     |         bytes32 m3;
  3030 |     |         bytes32 m4;
  3031 |     |         bytes32 m5;
  3032 |     |         bytes32 m6;
  3033 |     |         assembly {
  3034 |     |             function writeString(pos, w) {
  3035 |     |                 let length := 0
  3036 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3037 |     |                 mstore(pos, length)
  3038 |     |                 let shift := sub(256, shl(3, length))
  3039 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3040 |     |             }
  3041 |     |             m0 := mload(0x00)
  3042 |     |             m1 := mload(0x20)
  3043 |     |             m2 := mload(0x40)
  3044 |     |             m3 := mload(0x60)
  3045 |     |             m4 := mload(0x80)
  3046 |     |             m5 := mload(0xa0)
  3047 |     |             m6 := mload(0xc0)
  3048 |     |             // Selector of `log(address,address,bool,string)`.
  3049 |     |             mstore(0x00, 0xaa6540c8)
  3050 |     |             mstore(0x20, p0)
  3051 |     |             mstore(0x40, p1)
  3052 |     |             mstore(0x60, p2)
  3053 |     |             mstore(0x80, 0x80)
  3054 |     |             writeString(0xa0, p3)
  3055 |     |         }
  3056 |     |         _sendLogPayload(0x1c, 0xc4);
  3057 |     |         assembly {
  3058 |     |             mstore(0x00, m0)
  3059 |     |             mstore(0x20, m1)
  3060 |     |             mstore(0x40, m2)
  3061 |     |             mstore(0x60, m3)
  3062 |     |             mstore(0x80, m4)
  3063 |     |             mstore(0xa0, m5)
  3064 |     |             mstore(0xc0, m6)
  3065 |     |         }
  3066 |     |     }
  3067 |     | 
  3068 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
  3069 |     |         bytes32 m0;
  3070 |     |         bytes32 m1;
  3071 |     |         bytes32 m2;
  3072 |     |         bytes32 m3;
  3073 |     |         bytes32 m4;
  3074 |     |         assembly {
  3075 |     |             m0 := mload(0x00)
  3076 |     |             m1 := mload(0x20)
  3077 |     |             m2 := mload(0x40)
  3078 |     |             m3 := mload(0x60)
  3079 |     |             m4 := mload(0x80)
  3080 |     |             // Selector of `log(address,address,uint256,address)`.
  3081 |     |             mstore(0x00, 0x8da6def5)
  3082 |     |             mstore(0x20, p0)
  3083 |     |             mstore(0x40, p1)
  3084 |     |             mstore(0x60, p2)
  3085 |     |             mstore(0x80, p3)
  3086 |     |         }
  3087 |     |         _sendLogPayload(0x1c, 0x84);
  3088 |     |         assembly {
  3089 |     |             mstore(0x00, m0)
  3090 |     |             mstore(0x20, m1)
  3091 |     |             mstore(0x40, m2)
  3092 |     |             mstore(0x60, m3)
  3093 |     |             mstore(0x80, m4)
  3094 |     |         }
  3095 |     |     }
  3096 |     | 
  3097 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
  3098 |     |         bytes32 m0;
  3099 |     |         bytes32 m1;
  3100 |     |         bytes32 m2;
  3101 |     |         bytes32 m3;
  3102 |     |         bytes32 m4;
  3103 |     |         assembly {
  3104 |     |             m0 := mload(0x00)
  3105 |     |             m1 := mload(0x20)
  3106 |     |             m2 := mload(0x40)
  3107 |     |             m3 := mload(0x60)
  3108 |     |             m4 := mload(0x80)
  3109 |     |             // Selector of `log(address,address,uint256,bool)`.
  3110 |     |             mstore(0x00, 0x9b4254e2)
  3111 |     |             mstore(0x20, p0)
  3112 |     |             mstore(0x40, p1)
  3113 |     |             mstore(0x60, p2)
  3114 |     |             mstore(0x80, p3)
  3115 |     |         }
  3116 |     |         _sendLogPayload(0x1c, 0x84);
  3117 |     |         assembly {
  3118 |     |             mstore(0x00, m0)
  3119 |     |             mstore(0x20, m1)
  3120 |     |             mstore(0x40, m2)
  3121 |     |             mstore(0x60, m3)
  3122 |     |             mstore(0x80, m4)
  3123 |     |         }
  3124 |     |     }
  3125 |     | 
  3126 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
  3127 |     |         bytes32 m0;
  3128 |     |         bytes32 m1;
  3129 |     |         bytes32 m2;
  3130 |     |         bytes32 m3;
  3131 |     |         bytes32 m4;
  3132 |     |         assembly {
  3133 |     |             m0 := mload(0x00)
  3134 |     |             m1 := mload(0x20)
  3135 |     |             m2 := mload(0x40)
  3136 |     |             m3 := mload(0x60)
  3137 |     |             m4 := mload(0x80)
  3138 |     |             // Selector of `log(address,address,uint256,uint256)`.
  3139 |     |             mstore(0x00, 0xbe553481)
  3140 |     |             mstore(0x20, p0)
  3141 |     |             mstore(0x40, p1)
  3142 |     |             mstore(0x60, p2)
  3143 |     |             mstore(0x80, p3)
  3144 |     |         }
  3145 |     |         _sendLogPayload(0x1c, 0x84);
  3146 |     |         assembly {
  3147 |     |             mstore(0x00, m0)
  3148 |     |             mstore(0x20, m1)
  3149 |     |             mstore(0x40, m2)
  3150 |     |             mstore(0x60, m3)
  3151 |     |             mstore(0x80, m4)
  3152 |     |         }
  3153 |     |     }
  3154 |     | 
  3155 |     |     function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {
  3156 |     |         bytes32 m0;
  3157 |     |         bytes32 m1;
  3158 |     |         bytes32 m2;
  3159 |     |         bytes32 m3;
  3160 |     |         bytes32 m4;
  3161 |     |         bytes32 m5;
  3162 |     |         bytes32 m6;
  3163 |     |         assembly {
  3164 |     |             function writeString(pos, w) {
  3165 |     |                 let length := 0
  3166 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3167 |     |                 mstore(pos, length)
  3168 |     |                 let shift := sub(256, shl(3, length))
  3169 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3170 |     |             }
  3171 |     |             m0 := mload(0x00)
  3172 |     |             m1 := mload(0x20)
  3173 |     |             m2 := mload(0x40)
  3174 |     |             m3 := mload(0x60)
  3175 |     |             m4 := mload(0x80)
  3176 |     |             m5 := mload(0xa0)
  3177 |     |             m6 := mload(0xc0)
  3178 |     |             // Selector of `log(address,address,uint256,string)`.
  3179 |     |             mstore(0x00, 0xfdb4f990)
  3180 |     |             mstore(0x20, p0)
  3181 |     |             mstore(0x40, p1)
  3182 |     |             mstore(0x60, p2)
  3183 |     |             mstore(0x80, 0x80)
  3184 |     |             writeString(0xa0, p3)
  3185 |     |         }
  3186 |     |         _sendLogPayload(0x1c, 0xc4);
  3187 |     |         assembly {
  3188 |     |             mstore(0x00, m0)
  3189 |     |             mstore(0x20, m1)
  3190 |     |             mstore(0x40, m2)
  3191 |     |             mstore(0x60, m3)
  3192 |     |             mstore(0x80, m4)
  3193 |     |             mstore(0xa0, m5)
  3194 |     |             mstore(0xc0, m6)
  3195 |     |         }
  3196 |     |     }
  3197 |     | 
  3198 |     |     function log(address p0, address p1, bytes32 p2, address p3) internal pure {
  3199 |     |         bytes32 m0;
  3200 |     |         bytes32 m1;
  3201 |     |         bytes32 m2;
  3202 |     |         bytes32 m3;
  3203 |     |         bytes32 m4;
  3204 |     |         bytes32 m5;
  3205 |     |         bytes32 m6;
  3206 |     |         assembly {
  3207 |     |             function writeString(pos, w) {
  3208 |     |                 let length := 0
  3209 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3210 |     |                 mstore(pos, length)
  3211 |     |                 let shift := sub(256, shl(3, length))
  3212 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3213 |     |             }
  3214 |     |             m0 := mload(0x00)
  3215 |     |             m1 := mload(0x20)
  3216 |     |             m2 := mload(0x40)
  3217 |     |             m3 := mload(0x60)
  3218 |     |             m4 := mload(0x80)
  3219 |     |             m5 := mload(0xa0)
  3220 |     |             m6 := mload(0xc0)
  3221 |     |             // Selector of `log(address,address,string,address)`.
  3222 |     |             mstore(0x00, 0x8f736d16)
  3223 |     |             mstore(0x20, p0)
  3224 |     |             mstore(0x40, p1)
  3225 |     |             mstore(0x60, 0x80)
  3226 |     |             mstore(0x80, p3)
  3227 |     |             writeString(0xa0, p2)
  3228 |     |         }
  3229 |     |         _sendLogPayload(0x1c, 0xc4);
  3230 |     |         assembly {
  3231 |     |             mstore(0x00, m0)
  3232 |     |             mstore(0x20, m1)
  3233 |     |             mstore(0x40, m2)
  3234 |     |             mstore(0x60, m3)
  3235 |     |             mstore(0x80, m4)
  3236 |     |             mstore(0xa0, m5)
  3237 |     |             mstore(0xc0, m6)
  3238 |     |         }
  3239 |     |     }
  3240 |     | 
  3241 |     |     function log(address p0, address p1, bytes32 p2, bool p3) internal pure {
  3242 |     |         bytes32 m0;
  3243 |     |         bytes32 m1;
  3244 |     |         bytes32 m2;
  3245 |     |         bytes32 m3;
  3246 |     |         bytes32 m4;
  3247 |     |         bytes32 m5;
  3248 |     |         bytes32 m6;
  3249 |     |         assembly {
  3250 |     |             function writeString(pos, w) {
  3251 |     |                 let length := 0
  3252 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3253 |     |                 mstore(pos, length)
  3254 |     |                 let shift := sub(256, shl(3, length))
  3255 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3256 |     |             }
  3257 |     |             m0 := mload(0x00)
  3258 |     |             m1 := mload(0x20)
  3259 |     |             m2 := mload(0x40)
  3260 |     |             m3 := mload(0x60)
  3261 |     |             m4 := mload(0x80)
  3262 |     |             m5 := mload(0xa0)
  3263 |     |             m6 := mload(0xc0)
  3264 |     |             // Selector of `log(address,address,string,bool)`.
  3265 |     |             mstore(0x00, 0x6f1a594e)
  3266 |     |             mstore(0x20, p0)
  3267 |     |             mstore(0x40, p1)
  3268 |     |             mstore(0x60, 0x80)
  3269 |     |             mstore(0x80, p3)
  3270 |     |             writeString(0xa0, p2)
  3271 |     |         }
  3272 |     |         _sendLogPayload(0x1c, 0xc4);
  3273 |     |         assembly {
  3274 |     |             mstore(0x00, m0)
  3275 |     |             mstore(0x20, m1)
  3276 |     |             mstore(0x40, m2)
  3277 |     |             mstore(0x60, m3)
  3278 |     |             mstore(0x80, m4)
  3279 |     |             mstore(0xa0, m5)
  3280 |     |             mstore(0xc0, m6)
  3281 |     |         }
  3282 |     |     }
  3283 |     | 
  3284 |     |     function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {
  3285 |     |         bytes32 m0;
  3286 |     |         bytes32 m1;
  3287 |     |         bytes32 m2;
  3288 |     |         bytes32 m3;
  3289 |     |         bytes32 m4;
  3290 |     |         bytes32 m5;
  3291 |     |         bytes32 m6;
  3292 |     |         assembly {
  3293 |     |             function writeString(pos, w) {
  3294 |     |                 let length := 0
  3295 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3296 |     |                 mstore(pos, length)
  3297 |     |                 let shift := sub(256, shl(3, length))
  3298 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3299 |     |             }
  3300 |     |             m0 := mload(0x00)
  3301 |     |             m1 := mload(0x20)
  3302 |     |             m2 := mload(0x40)
  3303 |     |             m3 := mload(0x60)
  3304 |     |             m4 := mload(0x80)
  3305 |     |             m5 := mload(0xa0)
  3306 |     |             m6 := mload(0xc0)
  3307 |     |             // Selector of `log(address,address,string,uint256)`.
  3308 |     |             mstore(0x00, 0xef1cefe7)
  3309 |     |             mstore(0x20, p0)
  3310 |     |             mstore(0x40, p1)
  3311 |     |             mstore(0x60, 0x80)
  3312 |     |             mstore(0x80, p3)
  3313 |     |             writeString(0xa0, p2)
  3314 |     |         }
  3315 |     |         _sendLogPayload(0x1c, 0xc4);
  3316 |     |         assembly {
  3317 |     |             mstore(0x00, m0)
  3318 |     |             mstore(0x20, m1)
  3319 |     |             mstore(0x40, m2)
  3320 |     |             mstore(0x60, m3)
  3321 |     |             mstore(0x80, m4)
  3322 |     |             mstore(0xa0, m5)
  3323 |     |             mstore(0xc0, m6)
  3324 |     |         }
  3325 |     |     }
  3326 |     | 
  3327 |     |     function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  3328 |     |         bytes32 m0;
  3329 |     |         bytes32 m1;
  3330 |     |         bytes32 m2;
  3331 |     |         bytes32 m3;
  3332 |     |         bytes32 m4;
  3333 |     |         bytes32 m5;
  3334 |     |         bytes32 m6;
  3335 |     |         bytes32 m7;
  3336 |     |         bytes32 m8;
  3337 |     |         assembly {
  3338 |     |             function writeString(pos, w) {
  3339 |     |                 let length := 0
  3340 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3341 |     |                 mstore(pos, length)
  3342 |     |                 let shift := sub(256, shl(3, length))
  3343 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3344 |     |             }
  3345 |     |             m0 := mload(0x00)
  3346 |     |             m1 := mload(0x20)
  3347 |     |             m2 := mload(0x40)
  3348 |     |             m3 := mload(0x60)
  3349 |     |             m4 := mload(0x80)
  3350 |     |             m5 := mload(0xa0)
  3351 |     |             m6 := mload(0xc0)
  3352 |     |             m7 := mload(0xe0)
  3353 |     |             m8 := mload(0x100)
  3354 |     |             // Selector of `log(address,address,string,string)`.
  3355 |     |             mstore(0x00, 0x21bdaf25)
  3356 |     |             mstore(0x20, p0)
  3357 |     |             mstore(0x40, p1)
  3358 |     |             mstore(0x60, 0x80)
  3359 |     |             mstore(0x80, 0xc0)
  3360 |     |             writeString(0xa0, p2)
  3361 |     |             writeString(0xe0, p3)
  3362 |     |         }
  3363 |     |         _sendLogPayload(0x1c, 0x104);
  3364 |     |         assembly {
  3365 |     |             mstore(0x00, m0)
  3366 |     |             mstore(0x20, m1)
  3367 |     |             mstore(0x40, m2)
  3368 |     |             mstore(0x60, m3)
  3369 |     |             mstore(0x80, m4)
  3370 |     |             mstore(0xa0, m5)
  3371 |     |             mstore(0xc0, m6)
  3372 |     |             mstore(0xe0, m7)
  3373 |     |             mstore(0x100, m8)
  3374 |     |         }
  3375 |     |     }
  3376 |     | 
  3377 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
  3378 |     |         bytes32 m0;
  3379 |     |         bytes32 m1;
  3380 |     |         bytes32 m2;
  3381 |     |         bytes32 m3;
  3382 |     |         bytes32 m4;
  3383 |     |         assembly {
  3384 |     |             m0 := mload(0x00)
  3385 |     |             m1 := mload(0x20)
  3386 |     |             m2 := mload(0x40)
  3387 |     |             m3 := mload(0x60)
  3388 |     |             m4 := mload(0x80)
  3389 |     |             // Selector of `log(address,bool,address,address)`.
  3390 |     |             mstore(0x00, 0x660375dd)
  3391 |     |             mstore(0x20, p0)
  3392 |     |             mstore(0x40, p1)
  3393 |     |             mstore(0x60, p2)
  3394 |     |             mstore(0x80, p3)
  3395 |     |         }
  3396 |     |         _sendLogPayload(0x1c, 0x84);
  3397 |     |         assembly {
  3398 |     |             mstore(0x00, m0)
  3399 |     |             mstore(0x20, m1)
  3400 |     |             mstore(0x40, m2)
  3401 |     |             mstore(0x60, m3)
  3402 |     |             mstore(0x80, m4)
  3403 |     |         }
  3404 |     |     }
  3405 |     | 
  3406 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
  3407 |     |         bytes32 m0;
  3408 |     |         bytes32 m1;
  3409 |     |         bytes32 m2;
  3410 |     |         bytes32 m3;
  3411 |     |         bytes32 m4;
  3412 |     |         assembly {
  3413 |     |             m0 := mload(0x00)
  3414 |     |             m1 := mload(0x20)
  3415 |     |             m2 := mload(0x40)
  3416 |     |             m3 := mload(0x60)
  3417 |     |             m4 := mload(0x80)
  3418 |     |             // Selector of `log(address,bool,address,bool)`.
  3419 |     |             mstore(0x00, 0xa6f50b0f)
  3420 |     |             mstore(0x20, p0)
  3421 |     |             mstore(0x40, p1)
  3422 |     |             mstore(0x60, p2)
  3423 |     |             mstore(0x80, p3)
  3424 |     |         }
  3425 |     |         _sendLogPayload(0x1c, 0x84);
  3426 |     |         assembly {
  3427 |     |             mstore(0x00, m0)
  3428 |     |             mstore(0x20, m1)
  3429 |     |             mstore(0x40, m2)
  3430 |     |             mstore(0x60, m3)
  3431 |     |             mstore(0x80, m4)
  3432 |     |         }
  3433 |     |     }
  3434 |     | 
  3435 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
  3436 |     |         bytes32 m0;
  3437 |     |         bytes32 m1;
  3438 |     |         bytes32 m2;
  3439 |     |         bytes32 m3;
  3440 |     |         bytes32 m4;
  3441 |     |         assembly {
  3442 |     |             m0 := mload(0x00)
  3443 |     |             m1 := mload(0x20)
  3444 |     |             m2 := mload(0x40)
  3445 |     |             m3 := mload(0x60)
  3446 |     |             m4 := mload(0x80)
  3447 |     |             // Selector of `log(address,bool,address,uint256)`.
  3448 |     |             mstore(0x00, 0xa75c59de)
  3449 |     |             mstore(0x20, p0)
  3450 |     |             mstore(0x40, p1)
  3451 |     |             mstore(0x60, p2)
  3452 |     |             mstore(0x80, p3)
  3453 |     |         }
  3454 |     |         _sendLogPayload(0x1c, 0x84);
  3455 |     |         assembly {
  3456 |     |             mstore(0x00, m0)
  3457 |     |             mstore(0x20, m1)
  3458 |     |             mstore(0x40, m2)
  3459 |     |             mstore(0x60, m3)
  3460 |     |             mstore(0x80, m4)
  3461 |     |         }
  3462 |     |     }
  3463 |     | 
  3464 |     |     function log(address p0, bool p1, address p2, bytes32 p3) internal pure {
  3465 |     |         bytes32 m0;
  3466 |     |         bytes32 m1;
  3467 |     |         bytes32 m2;
  3468 |     |         bytes32 m3;
  3469 |     |         bytes32 m4;
  3470 |     |         bytes32 m5;
  3471 |     |         bytes32 m6;
  3472 |     |         assembly {
  3473 |     |             function writeString(pos, w) {
  3474 |     |                 let length := 0
  3475 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3476 |     |                 mstore(pos, length)
  3477 |     |                 let shift := sub(256, shl(3, length))
  3478 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3479 |     |             }
  3480 |     |             m0 := mload(0x00)
  3481 |     |             m1 := mload(0x20)
  3482 |     |             m2 := mload(0x40)
  3483 |     |             m3 := mload(0x60)
  3484 |     |             m4 := mload(0x80)
  3485 |     |             m5 := mload(0xa0)
  3486 |     |             m6 := mload(0xc0)
  3487 |     |             // Selector of `log(address,bool,address,string)`.
  3488 |     |             mstore(0x00, 0x2dd778e6)
  3489 |     |             mstore(0x20, p0)
  3490 |     |             mstore(0x40, p1)
  3491 |     |             mstore(0x60, p2)
  3492 |     |             mstore(0x80, 0x80)
  3493 |     |             writeString(0xa0, p3)
  3494 |     |         }
  3495 |     |         _sendLogPayload(0x1c, 0xc4);
  3496 |     |         assembly {
  3497 |     |             mstore(0x00, m0)
  3498 |     |             mstore(0x20, m1)
  3499 |     |             mstore(0x40, m2)
  3500 |     |             mstore(0x60, m3)
  3501 |     |             mstore(0x80, m4)
  3502 |     |             mstore(0xa0, m5)
  3503 |     |             mstore(0xc0, m6)
  3504 |     |         }
  3505 |     |     }
  3506 |     | 
  3507 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
  3508 |     |         bytes32 m0;
  3509 |     |         bytes32 m1;
  3510 |     |         bytes32 m2;
  3511 |     |         bytes32 m3;
  3512 |     |         bytes32 m4;
  3513 |     |         assembly {
  3514 |     |             m0 := mload(0x00)
  3515 |     |             m1 := mload(0x20)
  3516 |     |             m2 := mload(0x40)
  3517 |     |             m3 := mload(0x60)
  3518 |     |             m4 := mload(0x80)
  3519 |     |             // Selector of `log(address,bool,bool,address)`.
  3520 |     |             mstore(0x00, 0xcf394485)
  3521 |     |             mstore(0x20, p0)
  3522 |     |             mstore(0x40, p1)
  3523 |     |             mstore(0x60, p2)
  3524 |     |             mstore(0x80, p3)
  3525 |     |         }
  3526 |     |         _sendLogPayload(0x1c, 0x84);
  3527 |     |         assembly {
  3528 |     |             mstore(0x00, m0)
  3529 |     |             mstore(0x20, m1)
  3530 |     |             mstore(0x40, m2)
  3531 |     |             mstore(0x60, m3)
  3532 |     |             mstore(0x80, m4)
  3533 |     |         }
  3534 |     |     }
  3535 |     | 
  3536 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
  3537 |     |         bytes32 m0;
  3538 |     |         bytes32 m1;
  3539 |     |         bytes32 m2;
  3540 |     |         bytes32 m3;
  3541 |     |         bytes32 m4;
  3542 |     |         assembly {
  3543 |     |             m0 := mload(0x00)
  3544 |     |             m1 := mload(0x20)
  3545 |     |             m2 := mload(0x40)
  3546 |     |             m3 := mload(0x60)
  3547 |     |             m4 := mload(0x80)
  3548 |     |             // Selector of `log(address,bool,bool,bool)`.
  3549 |     |             mstore(0x00, 0xcac43479)
  3550 |     |             mstore(0x20, p0)
  3551 |     |             mstore(0x40, p1)
  3552 |     |             mstore(0x60, p2)
  3553 |     |             mstore(0x80, p3)
  3554 |     |         }
  3555 |     |         _sendLogPayload(0x1c, 0x84);
  3556 |     |         assembly {
  3557 |     |             mstore(0x00, m0)
  3558 |     |             mstore(0x20, m1)
  3559 |     |             mstore(0x40, m2)
  3560 |     |             mstore(0x60, m3)
  3561 |     |             mstore(0x80, m4)
  3562 |     |         }
  3563 |     |     }
  3564 |     | 
  3565 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
  3566 |     |         bytes32 m0;
  3567 |     |         bytes32 m1;
  3568 |     |         bytes32 m2;
  3569 |     |         bytes32 m3;
  3570 |     |         bytes32 m4;
  3571 |     |         assembly {
  3572 |     |             m0 := mload(0x00)
  3573 |     |             m1 := mload(0x20)
  3574 |     |             m2 := mload(0x40)
  3575 |     |             m3 := mload(0x60)
  3576 |     |             m4 := mload(0x80)
  3577 |     |             // Selector of `log(address,bool,bool,uint256)`.
  3578 |     |             mstore(0x00, 0x8c4e5de6)
  3579 |     |             mstore(0x20, p0)
  3580 |     |             mstore(0x40, p1)
  3581 |     |             mstore(0x60, p2)
  3582 |     |             mstore(0x80, p3)
  3583 |     |         }
  3584 |     |         _sendLogPayload(0x1c, 0x84);
  3585 |     |         assembly {
  3586 |     |             mstore(0x00, m0)
  3587 |     |             mstore(0x20, m1)
  3588 |     |             mstore(0x40, m2)
  3589 |     |             mstore(0x60, m3)
  3590 |     |             mstore(0x80, m4)
  3591 |     |         }
  3592 |     |     }
  3593 |     | 
  3594 |     |     function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {
  3595 |     |         bytes32 m0;
  3596 |     |         bytes32 m1;
  3597 |     |         bytes32 m2;
  3598 |     |         bytes32 m3;
  3599 |     |         bytes32 m4;
  3600 |     |         bytes32 m5;
  3601 |     |         bytes32 m6;
  3602 |     |         assembly {
  3603 |     |             function writeString(pos, w) {
  3604 |     |                 let length := 0
  3605 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3606 |     |                 mstore(pos, length)
  3607 |     |                 let shift := sub(256, shl(3, length))
  3608 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3609 |     |             }
  3610 |     |             m0 := mload(0x00)
  3611 |     |             m1 := mload(0x20)
  3612 |     |             m2 := mload(0x40)
  3613 |     |             m3 := mload(0x60)
  3614 |     |             m4 := mload(0x80)
  3615 |     |             m5 := mload(0xa0)
  3616 |     |             m6 := mload(0xc0)
  3617 |     |             // Selector of `log(address,bool,bool,string)`.
  3618 |     |             mstore(0x00, 0xdfc4a2e8)
  3619 |     |             mstore(0x20, p0)
  3620 |     |             mstore(0x40, p1)
  3621 |     |             mstore(0x60, p2)
  3622 |     |             mstore(0x80, 0x80)
  3623 |     |             writeString(0xa0, p3)
  3624 |     |         }
  3625 |     |         _sendLogPayload(0x1c, 0xc4);
  3626 |     |         assembly {
  3627 |     |             mstore(0x00, m0)
  3628 |     |             mstore(0x20, m1)
  3629 |     |             mstore(0x40, m2)
  3630 |     |             mstore(0x60, m3)
  3631 |     |             mstore(0x80, m4)
  3632 |     |             mstore(0xa0, m5)
  3633 |     |             mstore(0xc0, m6)
  3634 |     |         }
  3635 |     |     }
  3636 |     | 
  3637 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
  3638 |     |         bytes32 m0;
  3639 |     |         bytes32 m1;
  3640 |     |         bytes32 m2;
  3641 |     |         bytes32 m3;
  3642 |     |         bytes32 m4;
  3643 |     |         assembly {
  3644 |     |             m0 := mload(0x00)
  3645 |     |             m1 := mload(0x20)
  3646 |     |             m2 := mload(0x40)
  3647 |     |             m3 := mload(0x60)
  3648 |     |             m4 := mload(0x80)
  3649 |     |             // Selector of `log(address,bool,uint256,address)`.
  3650 |     |             mstore(0x00, 0xccf790a1)
  3651 |     |             mstore(0x20, p0)
  3652 |     |             mstore(0x40, p1)
  3653 |     |             mstore(0x60, p2)
  3654 |     |             mstore(0x80, p3)
  3655 |     |         }
  3656 |     |         _sendLogPayload(0x1c, 0x84);
  3657 |     |         assembly {
  3658 |     |             mstore(0x00, m0)
  3659 |     |             mstore(0x20, m1)
  3660 |     |             mstore(0x40, m2)
  3661 |     |             mstore(0x60, m3)
  3662 |     |             mstore(0x80, m4)
  3663 |     |         }
  3664 |     |     }
  3665 |     | 
  3666 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
  3667 |     |         bytes32 m0;
  3668 |     |         bytes32 m1;
  3669 |     |         bytes32 m2;
  3670 |     |         bytes32 m3;
  3671 |     |         bytes32 m4;
  3672 |     |         assembly {
  3673 |     |             m0 := mload(0x00)
  3674 |     |             m1 := mload(0x20)
  3675 |     |             m2 := mload(0x40)
  3676 |     |             m3 := mload(0x60)
  3677 |     |             m4 := mload(0x80)
  3678 |     |             // Selector of `log(address,bool,uint256,bool)`.
  3679 |     |             mstore(0x00, 0xc4643e20)
  3680 |     |             mstore(0x20, p0)
  3681 |     |             mstore(0x40, p1)
  3682 |     |             mstore(0x60, p2)
  3683 |     |             mstore(0x80, p3)
  3684 |     |         }
  3685 |     |         _sendLogPayload(0x1c, 0x84);
  3686 |     |         assembly {
  3687 |     |             mstore(0x00, m0)
  3688 |     |             mstore(0x20, m1)
  3689 |     |             mstore(0x40, m2)
  3690 |     |             mstore(0x60, m3)
  3691 |     |             mstore(0x80, m4)
  3692 |     |         }
  3693 |     |     }
  3694 |     | 
  3695 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
  3696 |     |         bytes32 m0;
  3697 |     |         bytes32 m1;
  3698 |     |         bytes32 m2;
  3699 |     |         bytes32 m3;
  3700 |     |         bytes32 m4;
  3701 |     |         assembly {
  3702 |     |             m0 := mload(0x00)
  3703 |     |             m1 := mload(0x20)
  3704 |     |             m2 := mload(0x40)
  3705 |     |             m3 := mload(0x60)
  3706 |     |             m4 := mload(0x80)
  3707 |     |             // Selector of `log(address,bool,uint256,uint256)`.
  3708 |     |             mstore(0x00, 0x386ff5f4)
  3709 |     |             mstore(0x20, p0)
  3710 |     |             mstore(0x40, p1)
  3711 |     |             mstore(0x60, p2)
  3712 |     |             mstore(0x80, p3)
  3713 |     |         }
  3714 |     |         _sendLogPayload(0x1c, 0x84);
  3715 |     |         assembly {
  3716 |     |             mstore(0x00, m0)
  3717 |     |             mstore(0x20, m1)
  3718 |     |             mstore(0x40, m2)
  3719 |     |             mstore(0x60, m3)
  3720 |     |             mstore(0x80, m4)
  3721 |     |         }
  3722 |     |     }
  3723 |     | 
  3724 |     |     function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  3725 |     |         bytes32 m0;
  3726 |     |         bytes32 m1;
  3727 |     |         bytes32 m2;
  3728 |     |         bytes32 m3;
  3729 |     |         bytes32 m4;
  3730 |     |         bytes32 m5;
  3731 |     |         bytes32 m6;
  3732 |     |         assembly {
  3733 |     |             function writeString(pos, w) {
  3734 |     |                 let length := 0
  3735 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3736 |     |                 mstore(pos, length)
  3737 |     |                 let shift := sub(256, shl(3, length))
  3738 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3739 |     |             }
  3740 |     |             m0 := mload(0x00)
  3741 |     |             m1 := mload(0x20)
  3742 |     |             m2 := mload(0x40)
  3743 |     |             m3 := mload(0x60)
  3744 |     |             m4 := mload(0x80)
  3745 |     |             m5 := mload(0xa0)
  3746 |     |             m6 := mload(0xc0)
  3747 |     |             // Selector of `log(address,bool,uint256,string)`.
  3748 |     |             mstore(0x00, 0x0aa6cfad)
  3749 |     |             mstore(0x20, p0)
  3750 |     |             mstore(0x40, p1)
  3751 |     |             mstore(0x60, p2)
  3752 |     |             mstore(0x80, 0x80)
  3753 |     |             writeString(0xa0, p3)
  3754 |     |         }
  3755 |     |         _sendLogPayload(0x1c, 0xc4);
  3756 |     |         assembly {
  3757 |     |             mstore(0x00, m0)
  3758 |     |             mstore(0x20, m1)
  3759 |     |             mstore(0x40, m2)
  3760 |     |             mstore(0x60, m3)
  3761 |     |             mstore(0x80, m4)
  3762 |     |             mstore(0xa0, m5)
  3763 |     |             mstore(0xc0, m6)
  3764 |     |         }
  3765 |     |     }
  3766 |     | 
  3767 |     |     function log(address p0, bool p1, bytes32 p2, address p3) internal pure {
  3768 |     |         bytes32 m0;
  3769 |     |         bytes32 m1;
  3770 |     |         bytes32 m2;
  3771 |     |         bytes32 m3;
  3772 |     |         bytes32 m4;
  3773 |     |         bytes32 m5;
  3774 |     |         bytes32 m6;
  3775 |     |         assembly {
  3776 |     |             function writeString(pos, w) {
  3777 |     |                 let length := 0
  3778 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3779 |     |                 mstore(pos, length)
  3780 |     |                 let shift := sub(256, shl(3, length))
  3781 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3782 |     |             }
  3783 |     |             m0 := mload(0x00)
  3784 |     |             m1 := mload(0x20)
  3785 |     |             m2 := mload(0x40)
  3786 |     |             m3 := mload(0x60)
  3787 |     |             m4 := mload(0x80)
  3788 |     |             m5 := mload(0xa0)
  3789 |     |             m6 := mload(0xc0)
  3790 |     |             // Selector of `log(address,bool,string,address)`.
  3791 |     |             mstore(0x00, 0x19fd4956)
  3792 |     |             mstore(0x20, p0)
  3793 |     |             mstore(0x40, p1)
  3794 |     |             mstore(0x60, 0x80)
  3795 |     |             mstore(0x80, p3)
  3796 |     |             writeString(0xa0, p2)
  3797 |     |         }
  3798 |     |         _sendLogPayload(0x1c, 0xc4);
  3799 |     |         assembly {
  3800 |     |             mstore(0x00, m0)
  3801 |     |             mstore(0x20, m1)
  3802 |     |             mstore(0x40, m2)
  3803 |     |             mstore(0x60, m3)
  3804 |     |             mstore(0x80, m4)
  3805 |     |             mstore(0xa0, m5)
  3806 |     |             mstore(0xc0, m6)
  3807 |     |         }
  3808 |     |     }
  3809 |     | 
  3810 |     |     function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {
  3811 |     |         bytes32 m0;
  3812 |     |         bytes32 m1;
  3813 |     |         bytes32 m2;
  3814 |     |         bytes32 m3;
  3815 |     |         bytes32 m4;
  3816 |     |         bytes32 m5;
  3817 |     |         bytes32 m6;
  3818 |     |         assembly {
  3819 |     |             function writeString(pos, w) {
  3820 |     |                 let length := 0
  3821 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3822 |     |                 mstore(pos, length)
  3823 |     |                 let shift := sub(256, shl(3, length))
  3824 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3825 |     |             }
  3826 |     |             m0 := mload(0x00)
  3827 |     |             m1 := mload(0x20)
  3828 |     |             m2 := mload(0x40)
  3829 |     |             m3 := mload(0x60)
  3830 |     |             m4 := mload(0x80)
  3831 |     |             m5 := mload(0xa0)
  3832 |     |             m6 := mload(0xc0)
  3833 |     |             // Selector of `log(address,bool,string,bool)`.
  3834 |     |             mstore(0x00, 0x50ad461d)
  3835 |     |             mstore(0x20, p0)
  3836 |     |             mstore(0x40, p1)
  3837 |     |             mstore(0x60, 0x80)
  3838 |     |             mstore(0x80, p3)
  3839 |     |             writeString(0xa0, p2)
  3840 |     |         }
  3841 |     |         _sendLogPayload(0x1c, 0xc4);
  3842 |     |         assembly {
  3843 |     |             mstore(0x00, m0)
  3844 |     |             mstore(0x20, m1)
  3845 |     |             mstore(0x40, m2)
  3846 |     |             mstore(0x60, m3)
  3847 |     |             mstore(0x80, m4)
  3848 |     |             mstore(0xa0, m5)
  3849 |     |             mstore(0xc0, m6)
  3850 |     |         }
  3851 |     |     }
  3852 |     | 
  3853 |     |     function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  3854 |     |         bytes32 m0;
  3855 |     |         bytes32 m1;
  3856 |     |         bytes32 m2;
  3857 |     |         bytes32 m3;
  3858 |     |         bytes32 m4;
  3859 |     |         bytes32 m5;
  3860 |     |         bytes32 m6;
  3861 |     |         assembly {
  3862 |     |             function writeString(pos, w) {
  3863 |     |                 let length := 0
  3864 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3865 |     |                 mstore(pos, length)
  3866 |     |                 let shift := sub(256, shl(3, length))
  3867 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3868 |     |             }
  3869 |     |             m0 := mload(0x00)
  3870 |     |             m1 := mload(0x20)
  3871 |     |             m2 := mload(0x40)
  3872 |     |             m3 := mload(0x60)
  3873 |     |             m4 := mload(0x80)
  3874 |     |             m5 := mload(0xa0)
  3875 |     |             m6 := mload(0xc0)
  3876 |     |             // Selector of `log(address,bool,string,uint256)`.
  3877 |     |             mstore(0x00, 0x80e6a20b)
  3878 |     |             mstore(0x20, p0)
  3879 |     |             mstore(0x40, p1)
  3880 |     |             mstore(0x60, 0x80)
  3881 |     |             mstore(0x80, p3)
  3882 |     |             writeString(0xa0, p2)
  3883 |     |         }
  3884 |     |         _sendLogPayload(0x1c, 0xc4);
  3885 |     |         assembly {
  3886 |     |             mstore(0x00, m0)
  3887 |     |             mstore(0x20, m1)
  3888 |     |             mstore(0x40, m2)
  3889 |     |             mstore(0x60, m3)
  3890 |     |             mstore(0x80, m4)
  3891 |     |             mstore(0xa0, m5)
  3892 |     |             mstore(0xc0, m6)
  3893 |     |         }
  3894 |     |     }
  3895 |     | 
  3896 |     |     function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  3897 |     |         bytes32 m0;
  3898 |     |         bytes32 m1;
  3899 |     |         bytes32 m2;
  3900 |     |         bytes32 m3;
  3901 |     |         bytes32 m4;
  3902 |     |         bytes32 m5;
  3903 |     |         bytes32 m6;
  3904 |     |         bytes32 m7;
  3905 |     |         bytes32 m8;
  3906 |     |         assembly {
  3907 |     |             function writeString(pos, w) {
  3908 |     |                 let length := 0
  3909 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3910 |     |                 mstore(pos, length)
  3911 |     |                 let shift := sub(256, shl(3, length))
  3912 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3913 |     |             }
  3914 |     |             m0 := mload(0x00)
  3915 |     |             m1 := mload(0x20)
  3916 |     |             m2 := mload(0x40)
  3917 |     |             m3 := mload(0x60)
  3918 |     |             m4 := mload(0x80)
  3919 |     |             m5 := mload(0xa0)
  3920 |     |             m6 := mload(0xc0)
  3921 |     |             m7 := mload(0xe0)
  3922 |     |             m8 := mload(0x100)
  3923 |     |             // Selector of `log(address,bool,string,string)`.
  3924 |     |             mstore(0x00, 0x475c5c33)
  3925 |     |             mstore(0x20, p0)
  3926 |     |             mstore(0x40, p1)
  3927 |     |             mstore(0x60, 0x80)
  3928 |     |             mstore(0x80, 0xc0)
  3929 |     |             writeString(0xa0, p2)
  3930 |     |             writeString(0xe0, p3)
  3931 |     |         }
  3932 |     |         _sendLogPayload(0x1c, 0x104);
  3933 |     |         assembly {
  3934 |     |             mstore(0x00, m0)
  3935 |     |             mstore(0x20, m1)
  3936 |     |             mstore(0x40, m2)
  3937 |     |             mstore(0x60, m3)
  3938 |     |             mstore(0x80, m4)
  3939 |     |             mstore(0xa0, m5)
  3940 |     |             mstore(0xc0, m6)
  3941 |     |             mstore(0xe0, m7)
  3942 |     |             mstore(0x100, m8)
  3943 |     |         }
  3944 |     |     }
  3945 |     | 
  3946 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
  3947 |     |         bytes32 m0;
  3948 |     |         bytes32 m1;
  3949 |     |         bytes32 m2;
  3950 |     |         bytes32 m3;
  3951 |     |         bytes32 m4;
  3952 |     |         assembly {
  3953 |     |             m0 := mload(0x00)
  3954 |     |             m1 := mload(0x20)
  3955 |     |             m2 := mload(0x40)
  3956 |     |             m3 := mload(0x60)
  3957 |     |             m4 := mload(0x80)
  3958 |     |             // Selector of `log(address,uint256,address,address)`.
  3959 |     |             mstore(0x00, 0x478d1c62)
  3960 |     |             mstore(0x20, p0)
  3961 |     |             mstore(0x40, p1)
  3962 |     |             mstore(0x60, p2)
  3963 |     |             mstore(0x80, p3)
  3964 |     |         }
  3965 |     |         _sendLogPayload(0x1c, 0x84);
  3966 |     |         assembly {
  3967 |     |             mstore(0x00, m0)
  3968 |     |             mstore(0x20, m1)
  3969 |     |             mstore(0x40, m2)
  3970 |     |             mstore(0x60, m3)
  3971 |     |             mstore(0x80, m4)
  3972 |     |         }
  3973 |     |     }
  3974 |     | 
  3975 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
  3976 |     |         bytes32 m0;
  3977 |     |         bytes32 m1;
  3978 |     |         bytes32 m2;
  3979 |     |         bytes32 m3;
  3980 |     |         bytes32 m4;
  3981 |     |         assembly {
  3982 |     |             m0 := mload(0x00)
  3983 |     |             m1 := mload(0x20)
  3984 |     |             m2 := mload(0x40)
  3985 |     |             m3 := mload(0x60)
  3986 |     |             m4 := mload(0x80)
  3987 |     |             // Selector of `log(address,uint256,address,bool)`.
  3988 |     |             mstore(0x00, 0xa1bcc9b3)
  3989 |     |             mstore(0x20, p0)
  3990 |     |             mstore(0x40, p1)
  3991 |     |             mstore(0x60, p2)
  3992 |     |             mstore(0x80, p3)
  3993 |     |         }
  3994 |     |         _sendLogPayload(0x1c, 0x84);
  3995 |     |         assembly {
  3996 |     |             mstore(0x00, m0)
  3997 |     |             mstore(0x20, m1)
  3998 |     |             mstore(0x40, m2)
  3999 |     |             mstore(0x60, m3)
  4000 |     |             mstore(0x80, m4)
  4001 |     |         }
  4002 |     |     }
  4003 |     | 
  4004 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
  4005 |     |         bytes32 m0;
  4006 |     |         bytes32 m1;
  4007 |     |         bytes32 m2;
  4008 |     |         bytes32 m3;
  4009 |     |         bytes32 m4;
  4010 |     |         assembly {
  4011 |     |             m0 := mload(0x00)
  4012 |     |             m1 := mload(0x20)
  4013 |     |             m2 := mload(0x40)
  4014 |     |             m3 := mload(0x60)
  4015 |     |             m4 := mload(0x80)
  4016 |     |             // Selector of `log(address,uint256,address,uint256)`.
  4017 |     |             mstore(0x00, 0x100f650e)
  4018 |     |             mstore(0x20, p0)
  4019 |     |             mstore(0x40, p1)
  4020 |     |             mstore(0x60, p2)
  4021 |     |             mstore(0x80, p3)
  4022 |     |         }
  4023 |     |         _sendLogPayload(0x1c, 0x84);
  4024 |     |         assembly {
  4025 |     |             mstore(0x00, m0)
  4026 |     |             mstore(0x20, m1)
  4027 |     |             mstore(0x40, m2)
  4028 |     |             mstore(0x60, m3)
  4029 |     |             mstore(0x80, m4)
  4030 |     |         }
  4031 |     |     }
  4032 |     | 
  4033 |     |     function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {
  4034 |     |         bytes32 m0;
  4035 |     |         bytes32 m1;
  4036 |     |         bytes32 m2;
  4037 |     |         bytes32 m3;
  4038 |     |         bytes32 m4;
  4039 |     |         bytes32 m5;
  4040 |     |         bytes32 m6;
  4041 |     |         assembly {
  4042 |     |             function writeString(pos, w) {
  4043 |     |                 let length := 0
  4044 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4045 |     |                 mstore(pos, length)
  4046 |     |                 let shift := sub(256, shl(3, length))
  4047 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4048 |     |             }
  4049 |     |             m0 := mload(0x00)
  4050 |     |             m1 := mload(0x20)
  4051 |     |             m2 := mload(0x40)
  4052 |     |             m3 := mload(0x60)
  4053 |     |             m4 := mload(0x80)
  4054 |     |             m5 := mload(0xa0)
  4055 |     |             m6 := mload(0xc0)
  4056 |     |             // Selector of `log(address,uint256,address,string)`.
  4057 |     |             mstore(0x00, 0x1da986ea)
  4058 |     |             mstore(0x20, p0)
  4059 |     |             mstore(0x40, p1)
  4060 |     |             mstore(0x60, p2)
  4061 |     |             mstore(0x80, 0x80)
  4062 |     |             writeString(0xa0, p3)
  4063 |     |         }
  4064 |     |         _sendLogPayload(0x1c, 0xc4);
  4065 |     |         assembly {
  4066 |     |             mstore(0x00, m0)
  4067 |     |             mstore(0x20, m1)
  4068 |     |             mstore(0x40, m2)
  4069 |     |             mstore(0x60, m3)
  4070 |     |             mstore(0x80, m4)
  4071 |     |             mstore(0xa0, m5)
  4072 |     |             mstore(0xc0, m6)
  4073 |     |         }
  4074 |     |     }
  4075 |     | 
  4076 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
  4077 |     |         bytes32 m0;
  4078 |     |         bytes32 m1;
  4079 |     |         bytes32 m2;
  4080 |     |         bytes32 m3;
  4081 |     |         bytes32 m4;
  4082 |     |         assembly {
  4083 |     |             m0 := mload(0x00)
  4084 |     |             m1 := mload(0x20)
  4085 |     |             m2 := mload(0x40)
  4086 |     |             m3 := mload(0x60)
  4087 |     |             m4 := mload(0x80)
  4088 |     |             // Selector of `log(address,uint256,bool,address)`.
  4089 |     |             mstore(0x00, 0xa31bfdcc)
  4090 |     |             mstore(0x20, p0)
  4091 |     |             mstore(0x40, p1)
  4092 |     |             mstore(0x60, p2)
  4093 |     |             mstore(0x80, p3)
  4094 |     |         }
  4095 |     |         _sendLogPayload(0x1c, 0x84);
  4096 |     |         assembly {
  4097 |     |             mstore(0x00, m0)
  4098 |     |             mstore(0x20, m1)
  4099 |     |             mstore(0x40, m2)
  4100 |     |             mstore(0x60, m3)
  4101 |     |             mstore(0x80, m4)
  4102 |     |         }
  4103 |     |     }
  4104 |     | 
  4105 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
  4106 |     |         bytes32 m0;
  4107 |     |         bytes32 m1;
  4108 |     |         bytes32 m2;
  4109 |     |         bytes32 m3;
  4110 |     |         bytes32 m4;
  4111 |     |         assembly {
  4112 |     |             m0 := mload(0x00)
  4113 |     |             m1 := mload(0x20)
  4114 |     |             m2 := mload(0x40)
  4115 |     |             m3 := mload(0x60)
  4116 |     |             m4 := mload(0x80)
  4117 |     |             // Selector of `log(address,uint256,bool,bool)`.
  4118 |     |             mstore(0x00, 0x3bf5e537)
  4119 |     |             mstore(0x20, p0)
  4120 |     |             mstore(0x40, p1)
  4121 |     |             mstore(0x60, p2)
  4122 |     |             mstore(0x80, p3)
  4123 |     |         }
  4124 |     |         _sendLogPayload(0x1c, 0x84);
  4125 |     |         assembly {
  4126 |     |             mstore(0x00, m0)
  4127 |     |             mstore(0x20, m1)
  4128 |     |             mstore(0x40, m2)
  4129 |     |             mstore(0x60, m3)
  4130 |     |             mstore(0x80, m4)
  4131 |     |         }
  4132 |     |     }
  4133 |     | 
  4134 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
  4135 |     |         bytes32 m0;
  4136 |     |         bytes32 m1;
  4137 |     |         bytes32 m2;
  4138 |     |         bytes32 m3;
  4139 |     |         bytes32 m4;
  4140 |     |         assembly {
  4141 |     |             m0 := mload(0x00)
  4142 |     |             m1 := mload(0x20)
  4143 |     |             m2 := mload(0x40)
  4144 |     |             m3 := mload(0x60)
  4145 |     |             m4 := mload(0x80)
  4146 |     |             // Selector of `log(address,uint256,bool,uint256)`.
  4147 |     |             mstore(0x00, 0x22f6b999)
  4148 |     |             mstore(0x20, p0)
  4149 |     |             mstore(0x40, p1)
  4150 |     |             mstore(0x60, p2)
  4151 |     |             mstore(0x80, p3)
  4152 |     |         }
  4153 |     |         _sendLogPayload(0x1c, 0x84);
  4154 |     |         assembly {
  4155 |     |             mstore(0x00, m0)
  4156 |     |             mstore(0x20, m1)
  4157 |     |             mstore(0x40, m2)
  4158 |     |             mstore(0x60, m3)
  4159 |     |             mstore(0x80, m4)
  4160 |     |         }
  4161 |     |     }
  4162 |     | 
  4163 |     |     function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  4164 |     |         bytes32 m0;
  4165 |     |         bytes32 m1;
  4166 |     |         bytes32 m2;
  4167 |     |         bytes32 m3;
  4168 |     |         bytes32 m4;
  4169 |     |         bytes32 m5;
  4170 |     |         bytes32 m6;
  4171 |     |         assembly {
  4172 |     |             function writeString(pos, w) {
  4173 |     |                 let length := 0
  4174 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4175 |     |                 mstore(pos, length)
  4176 |     |                 let shift := sub(256, shl(3, length))
  4177 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4178 |     |             }
  4179 |     |             m0 := mload(0x00)
  4180 |     |             m1 := mload(0x20)
  4181 |     |             m2 := mload(0x40)
  4182 |     |             m3 := mload(0x60)
  4183 |     |             m4 := mload(0x80)
  4184 |     |             m5 := mload(0xa0)
  4185 |     |             m6 := mload(0xc0)
  4186 |     |             // Selector of `log(address,uint256,bool,string)`.
  4187 |     |             mstore(0x00, 0xc5ad85f9)
  4188 |     |             mstore(0x20, p0)
  4189 |     |             mstore(0x40, p1)
  4190 |     |             mstore(0x60, p2)
  4191 |     |             mstore(0x80, 0x80)
  4192 |     |             writeString(0xa0, p3)
  4193 |     |         }
  4194 |     |         _sendLogPayload(0x1c, 0xc4);
  4195 |     |         assembly {
  4196 |     |             mstore(0x00, m0)
  4197 |     |             mstore(0x20, m1)
  4198 |     |             mstore(0x40, m2)
  4199 |     |             mstore(0x60, m3)
  4200 |     |             mstore(0x80, m4)
  4201 |     |             mstore(0xa0, m5)
  4202 |     |             mstore(0xc0, m6)
  4203 |     |         }
  4204 |     |     }
  4205 |     | 
  4206 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
  4207 |     |         bytes32 m0;
  4208 |     |         bytes32 m1;
  4209 |     |         bytes32 m2;
  4210 |     |         bytes32 m3;
  4211 |     |         bytes32 m4;
  4212 |     |         assembly {
  4213 |     |             m0 := mload(0x00)
  4214 |     |             m1 := mload(0x20)
  4215 |     |             m2 := mload(0x40)
  4216 |     |             m3 := mload(0x60)
  4217 |     |             m4 := mload(0x80)
  4218 |     |             // Selector of `log(address,uint256,uint256,address)`.
  4219 |     |             mstore(0x00, 0x20e3984d)
  4220 |     |             mstore(0x20, p0)
  4221 |     |             mstore(0x40, p1)
  4222 |     |             mstore(0x60, p2)
  4223 |     |             mstore(0x80, p3)
  4224 |     |         }
  4225 |     |         _sendLogPayload(0x1c, 0x84);
  4226 |     |         assembly {
  4227 |     |             mstore(0x00, m0)
  4228 |     |             mstore(0x20, m1)
  4229 |     |             mstore(0x40, m2)
  4230 |     |             mstore(0x60, m3)
  4231 |     |             mstore(0x80, m4)
  4232 |     |         }
  4233 |     |     }
  4234 |     | 
  4235 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
  4236 |     |         bytes32 m0;
  4237 |     |         bytes32 m1;
  4238 |     |         bytes32 m2;
  4239 |     |         bytes32 m3;
  4240 |     |         bytes32 m4;
  4241 |     |         assembly {
  4242 |     |             m0 := mload(0x00)
  4243 |     |             m1 := mload(0x20)
  4244 |     |             m2 := mload(0x40)
  4245 |     |             m3 := mload(0x60)
  4246 |     |             m4 := mload(0x80)
  4247 |     |             // Selector of `log(address,uint256,uint256,bool)`.
  4248 |     |             mstore(0x00, 0x66f1bc67)
  4249 |     |             mstore(0x20, p0)
  4250 |     |             mstore(0x40, p1)
  4251 |     |             mstore(0x60, p2)
  4252 |     |             mstore(0x80, p3)
  4253 |     |         }
  4254 |     |         _sendLogPayload(0x1c, 0x84);
  4255 |     |         assembly {
  4256 |     |             mstore(0x00, m0)
  4257 |     |             mstore(0x20, m1)
  4258 |     |             mstore(0x40, m2)
  4259 |     |             mstore(0x60, m3)
  4260 |     |             mstore(0x80, m4)
  4261 |     |         }
  4262 |     |     }
  4263 |     | 
  4264 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  4265 |     |         bytes32 m0;
  4266 |     |         bytes32 m1;
  4267 |     |         bytes32 m2;
  4268 |     |         bytes32 m3;
  4269 |     |         bytes32 m4;
  4270 |     |         assembly {
  4271 |     |             m0 := mload(0x00)
  4272 |     |             m1 := mload(0x20)
  4273 |     |             m2 := mload(0x40)
  4274 |     |             m3 := mload(0x60)
  4275 |     |             m4 := mload(0x80)
  4276 |     |             // Selector of `log(address,uint256,uint256,uint256)`.
  4277 |     |             mstore(0x00, 0x34f0e636)
  4278 |     |             mstore(0x20, p0)
  4279 |     |             mstore(0x40, p1)
  4280 |     |             mstore(0x60, p2)
  4281 |     |             mstore(0x80, p3)
  4282 |     |         }
  4283 |     |         _sendLogPayload(0x1c, 0x84);
  4284 |     |         assembly {
  4285 |     |             mstore(0x00, m0)
  4286 |     |             mstore(0x20, m1)
  4287 |     |             mstore(0x40, m2)
  4288 |     |             mstore(0x60, m3)
  4289 |     |             mstore(0x80, m4)
  4290 |     |         }
  4291 |     |     }
  4292 |     | 
  4293 |     |     function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  4294 |     |         bytes32 m0;
  4295 |     |         bytes32 m1;
  4296 |     |         bytes32 m2;
  4297 |     |         bytes32 m3;
  4298 |     |         bytes32 m4;
  4299 |     |         bytes32 m5;
  4300 |     |         bytes32 m6;
  4301 |     |         assembly {
  4302 |     |             function writeString(pos, w) {
  4303 |     |                 let length := 0
  4304 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4305 |     |                 mstore(pos, length)
  4306 |     |                 let shift := sub(256, shl(3, length))
  4307 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4308 |     |             }
  4309 |     |             m0 := mload(0x00)
  4310 |     |             m1 := mload(0x20)
  4311 |     |             m2 := mload(0x40)
  4312 |     |             m3 := mload(0x60)
  4313 |     |             m4 := mload(0x80)
  4314 |     |             m5 := mload(0xa0)
  4315 |     |             m6 := mload(0xc0)
  4316 |     |             // Selector of `log(address,uint256,uint256,string)`.
  4317 |     |             mstore(0x00, 0x4a28c017)
  4318 |     |             mstore(0x20, p0)
  4319 |     |             mstore(0x40, p1)
  4320 |     |             mstore(0x60, p2)
  4321 |     |             mstore(0x80, 0x80)
  4322 |     |             writeString(0xa0, p3)
  4323 |     |         }
  4324 |     |         _sendLogPayload(0x1c, 0xc4);
  4325 |     |         assembly {
  4326 |     |             mstore(0x00, m0)
  4327 |     |             mstore(0x20, m1)
  4328 |     |             mstore(0x40, m2)
  4329 |     |             mstore(0x60, m3)
  4330 |     |             mstore(0x80, m4)
  4331 |     |             mstore(0xa0, m5)
  4332 |     |             mstore(0xc0, m6)
  4333 |     |         }
  4334 |     |     }
  4335 |     | 
  4336 |     |     function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {
  4337 |     |         bytes32 m0;
  4338 |     |         bytes32 m1;
  4339 |     |         bytes32 m2;
  4340 |     |         bytes32 m3;
  4341 |     |         bytes32 m4;
  4342 |     |         bytes32 m5;
  4343 |     |         bytes32 m6;
  4344 |     |         assembly {
  4345 |     |             function writeString(pos, w) {
  4346 |     |                 let length := 0
  4347 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4348 |     |                 mstore(pos, length)
  4349 |     |                 let shift := sub(256, shl(3, length))
  4350 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4351 |     |             }
  4352 |     |             m0 := mload(0x00)
  4353 |     |             m1 := mload(0x20)
  4354 |     |             m2 := mload(0x40)
  4355 |     |             m3 := mload(0x60)
  4356 |     |             m4 := mload(0x80)
  4357 |     |             m5 := mload(0xa0)
  4358 |     |             m6 := mload(0xc0)
  4359 |     |             // Selector of `log(address,uint256,string,address)`.
  4360 |     |             mstore(0x00, 0x5c430d47)
  4361 |     |             mstore(0x20, p0)
  4362 |     |             mstore(0x40, p1)
  4363 |     |             mstore(0x60, 0x80)
  4364 |     |             mstore(0x80, p3)
  4365 |     |             writeString(0xa0, p2)
  4366 |     |         }
  4367 |     |         _sendLogPayload(0x1c, 0xc4);
  4368 |     |         assembly {
  4369 |     |             mstore(0x00, m0)
  4370 |     |             mstore(0x20, m1)
  4371 |     |             mstore(0x40, m2)
  4372 |     |             mstore(0x60, m3)
  4373 |     |             mstore(0x80, m4)
  4374 |     |             mstore(0xa0, m5)
  4375 |     |             mstore(0xc0, m6)
  4376 |     |         }
  4377 |     |     }
  4378 |     | 
  4379 |     |     function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  4380 |     |         bytes32 m0;
  4381 |     |         bytes32 m1;
  4382 |     |         bytes32 m2;
  4383 |     |         bytes32 m3;
  4384 |     |         bytes32 m4;
  4385 |     |         bytes32 m5;
  4386 |     |         bytes32 m6;
  4387 |     |         assembly {
  4388 |     |             function writeString(pos, w) {
  4389 |     |                 let length := 0
  4390 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4391 |     |                 mstore(pos, length)
  4392 |     |                 let shift := sub(256, shl(3, length))
  4393 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4394 |     |             }
  4395 |     |             m0 := mload(0x00)
  4396 |     |             m1 := mload(0x20)
  4397 |     |             m2 := mload(0x40)
  4398 |     |             m3 := mload(0x60)
  4399 |     |             m4 := mload(0x80)
  4400 |     |             m5 := mload(0xa0)
  4401 |     |             m6 := mload(0xc0)
  4402 |     |             // Selector of `log(address,uint256,string,bool)`.
  4403 |     |             mstore(0x00, 0xcf18105c)
  4404 |     |             mstore(0x20, p0)
  4405 |     |             mstore(0x40, p1)
  4406 |     |             mstore(0x60, 0x80)
  4407 |     |             mstore(0x80, p3)
  4408 |     |             writeString(0xa0, p2)
  4409 |     |         }
  4410 |     |         _sendLogPayload(0x1c, 0xc4);
  4411 |     |         assembly {
  4412 |     |             mstore(0x00, m0)
  4413 |     |             mstore(0x20, m1)
  4414 |     |             mstore(0x40, m2)
  4415 |     |             mstore(0x60, m3)
  4416 |     |             mstore(0x80, m4)
  4417 |     |             mstore(0xa0, m5)
  4418 |     |             mstore(0xc0, m6)
  4419 |     |         }
  4420 |     |     }
  4421 |     | 
  4422 |     |     function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  4423 |     |         bytes32 m0;
  4424 |     |         bytes32 m1;
  4425 |     |         bytes32 m2;
  4426 |     |         bytes32 m3;
  4427 |     |         bytes32 m4;
  4428 |     |         bytes32 m5;
  4429 |     |         bytes32 m6;
  4430 |     |         assembly {
  4431 |     |             function writeString(pos, w) {
  4432 |     |                 let length := 0
  4433 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4434 |     |                 mstore(pos, length)
  4435 |     |                 let shift := sub(256, shl(3, length))
  4436 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4437 |     |             }
  4438 |     |             m0 := mload(0x00)
  4439 |     |             m1 := mload(0x20)
  4440 |     |             m2 := mload(0x40)
  4441 |     |             m3 := mload(0x60)
  4442 |     |             m4 := mload(0x80)
  4443 |     |             m5 := mload(0xa0)
  4444 |     |             m6 := mload(0xc0)
  4445 |     |             // Selector of `log(address,uint256,string,uint256)`.
  4446 |     |             mstore(0x00, 0xbf01f891)
  4447 |     |             mstore(0x20, p0)
  4448 |     |             mstore(0x40, p1)
  4449 |     |             mstore(0x60, 0x80)
  4450 |     |             mstore(0x80, p3)
  4451 |     |             writeString(0xa0, p2)
  4452 |     |         }
  4453 |     |         _sendLogPayload(0x1c, 0xc4);
  4454 |     |         assembly {
  4455 |     |             mstore(0x00, m0)
  4456 |     |             mstore(0x20, m1)
  4457 |     |             mstore(0x40, m2)
  4458 |     |             mstore(0x60, m3)
  4459 |     |             mstore(0x80, m4)
  4460 |     |             mstore(0xa0, m5)
  4461 |     |             mstore(0xc0, m6)
  4462 |     |         }
  4463 |     |     }
  4464 |     | 
  4465 |     |     function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  4466 |     |         bytes32 m0;
  4467 |     |         bytes32 m1;
  4468 |     |         bytes32 m2;
  4469 |     |         bytes32 m3;
  4470 |     |         bytes32 m4;
  4471 |     |         bytes32 m5;
  4472 |     |         bytes32 m6;
  4473 |     |         bytes32 m7;
  4474 |     |         bytes32 m8;
  4475 |     |         assembly {
  4476 |     |             function writeString(pos, w) {
  4477 |     |                 let length := 0
  4478 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4479 |     |                 mstore(pos, length)
  4480 |     |                 let shift := sub(256, shl(3, length))
  4481 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4482 |     |             }
  4483 |     |             m0 := mload(0x00)
  4484 |     |             m1 := mload(0x20)
  4485 |     |             m2 := mload(0x40)
  4486 |     |             m3 := mload(0x60)
  4487 |     |             m4 := mload(0x80)
  4488 |     |             m5 := mload(0xa0)
  4489 |     |             m6 := mload(0xc0)
  4490 |     |             m7 := mload(0xe0)
  4491 |     |             m8 := mload(0x100)
  4492 |     |             // Selector of `log(address,uint256,string,string)`.
  4493 |     |             mstore(0x00, 0x88a8c406)
  4494 |     |             mstore(0x20, p0)
  4495 |     |             mstore(0x40, p1)
  4496 |     |             mstore(0x60, 0x80)
  4497 |     |             mstore(0x80, 0xc0)
  4498 |     |             writeString(0xa0, p2)
  4499 |     |             writeString(0xe0, p3)
  4500 |     |         }
  4501 |     |         _sendLogPayload(0x1c, 0x104);
  4502 |     |         assembly {
  4503 |     |             mstore(0x00, m0)
  4504 |     |             mstore(0x20, m1)
  4505 |     |             mstore(0x40, m2)
  4506 |     |             mstore(0x60, m3)
  4507 |     |             mstore(0x80, m4)
  4508 |     |             mstore(0xa0, m5)
  4509 |     |             mstore(0xc0, m6)
  4510 |     |             mstore(0xe0, m7)
  4511 |     |             mstore(0x100, m8)
  4512 |     |         }
  4513 |     |     }
  4514 |     | 
  4515 |     |     function log(address p0, bytes32 p1, address p2, address p3) internal pure {
  4516 |     |         bytes32 m0;
  4517 |     |         bytes32 m1;
  4518 |     |         bytes32 m2;
  4519 |     |         bytes32 m3;
  4520 |     |         bytes32 m4;
  4521 |     |         bytes32 m5;
  4522 |     |         bytes32 m6;
  4523 |     |         assembly {
  4524 |     |             function writeString(pos, w) {
  4525 |     |                 let length := 0
  4526 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4527 |     |                 mstore(pos, length)
  4528 |     |                 let shift := sub(256, shl(3, length))
  4529 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4530 |     |             }
  4531 |     |             m0 := mload(0x00)
  4532 |     |             m1 := mload(0x20)
  4533 |     |             m2 := mload(0x40)
  4534 |     |             m3 := mload(0x60)
  4535 |     |             m4 := mload(0x80)
  4536 |     |             m5 := mload(0xa0)
  4537 |     |             m6 := mload(0xc0)
  4538 |     |             // Selector of `log(address,string,address,address)`.
  4539 |     |             mstore(0x00, 0x0d36fa20)
  4540 |     |             mstore(0x20, p0)
  4541 |     |             mstore(0x40, 0x80)
  4542 |     |             mstore(0x60, p2)
  4543 |     |             mstore(0x80, p3)
  4544 |     |             writeString(0xa0, p1)
  4545 |     |         }
  4546 |     |         _sendLogPayload(0x1c, 0xc4);
  4547 |     |         assembly {
  4548 |     |             mstore(0x00, m0)
  4549 |     |             mstore(0x20, m1)
  4550 |     |             mstore(0x40, m2)
  4551 |     |             mstore(0x60, m3)
  4552 |     |             mstore(0x80, m4)
  4553 |     |             mstore(0xa0, m5)
  4554 |     |             mstore(0xc0, m6)
  4555 |     |         }
  4556 |     |     }
  4557 |     | 
  4558 |     |     function log(address p0, bytes32 p1, address p2, bool p3) internal pure {
  4559 |     |         bytes32 m0;
  4560 |     |         bytes32 m1;
  4561 |     |         bytes32 m2;
  4562 |     |         bytes32 m3;
  4563 |     |         bytes32 m4;
  4564 |     |         bytes32 m5;
  4565 |     |         bytes32 m6;
  4566 |     |         assembly {
  4567 |     |             function writeString(pos, w) {
  4568 |     |                 let length := 0
  4569 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4570 |     |                 mstore(pos, length)
  4571 |     |                 let shift := sub(256, shl(3, length))
  4572 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4573 |     |             }
  4574 |     |             m0 := mload(0x00)
  4575 |     |             m1 := mload(0x20)
  4576 |     |             m2 := mload(0x40)
  4577 |     |             m3 := mload(0x60)
  4578 |     |             m4 := mload(0x80)
  4579 |     |             m5 := mload(0xa0)
  4580 |     |             m6 := mload(0xc0)
  4581 |     |             // Selector of `log(address,string,address,bool)`.
  4582 |     |             mstore(0x00, 0x0df12b76)
  4583 |     |             mstore(0x20, p0)
  4584 |     |             mstore(0x40, 0x80)
  4585 |     |             mstore(0x60, p2)
  4586 |     |             mstore(0x80, p3)
  4587 |     |             writeString(0xa0, p1)
  4588 |     |         }
  4589 |     |         _sendLogPayload(0x1c, 0xc4);
  4590 |     |         assembly {
  4591 |     |             mstore(0x00, m0)
  4592 |     |             mstore(0x20, m1)
  4593 |     |             mstore(0x40, m2)
  4594 |     |             mstore(0x60, m3)
  4595 |     |             mstore(0x80, m4)
  4596 |     |             mstore(0xa0, m5)
  4597 |     |             mstore(0xc0, m6)
  4598 |     |         }
  4599 |     |     }
  4600 |     | 
  4601 |     |     function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {
  4602 |     |         bytes32 m0;
  4603 |     |         bytes32 m1;
  4604 |     |         bytes32 m2;
  4605 |     |         bytes32 m3;
  4606 |     |         bytes32 m4;
  4607 |     |         bytes32 m5;
  4608 |     |         bytes32 m6;
  4609 |     |         assembly {
  4610 |     |             function writeString(pos, w) {
  4611 |     |                 let length := 0
  4612 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4613 |     |                 mstore(pos, length)
  4614 |     |                 let shift := sub(256, shl(3, length))
  4615 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4616 |     |             }
  4617 |     |             m0 := mload(0x00)
  4618 |     |             m1 := mload(0x20)
  4619 |     |             m2 := mload(0x40)
  4620 |     |             m3 := mload(0x60)
  4621 |     |             m4 := mload(0x80)
  4622 |     |             m5 := mload(0xa0)
  4623 |     |             m6 := mload(0xc0)
  4624 |     |             // Selector of `log(address,string,address,uint256)`.
  4625 |     |             mstore(0x00, 0x457fe3cf)
  4626 |     |             mstore(0x20, p0)
  4627 |     |             mstore(0x40, 0x80)
  4628 |     |             mstore(0x60, p2)
  4629 |     |             mstore(0x80, p3)
  4630 |     |             writeString(0xa0, p1)
  4631 |     |         }
  4632 |     |         _sendLogPayload(0x1c, 0xc4);
  4633 |     |         assembly {
  4634 |     |             mstore(0x00, m0)
  4635 |     |             mstore(0x20, m1)
  4636 |     |             mstore(0x40, m2)
  4637 |     |             mstore(0x60, m3)
  4638 |     |             mstore(0x80, m4)
  4639 |     |             mstore(0xa0, m5)
  4640 |     |             mstore(0xc0, m6)
  4641 |     |         }
  4642 |     |     }
  4643 |     | 
  4644 |     |     function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  4645 |     |         bytes32 m0;
  4646 |     |         bytes32 m1;
  4647 |     |         bytes32 m2;
  4648 |     |         bytes32 m3;
  4649 |     |         bytes32 m4;
  4650 |     |         bytes32 m5;
  4651 |     |         bytes32 m6;
  4652 |     |         bytes32 m7;
  4653 |     |         bytes32 m8;
  4654 |     |         assembly {
  4655 |     |             function writeString(pos, w) {
  4656 |     |                 let length := 0
  4657 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4658 |     |                 mstore(pos, length)
  4659 |     |                 let shift := sub(256, shl(3, length))
  4660 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4661 |     |             }
  4662 |     |             m0 := mload(0x00)
  4663 |     |             m1 := mload(0x20)
  4664 |     |             m2 := mload(0x40)
  4665 |     |             m3 := mload(0x60)
  4666 |     |             m4 := mload(0x80)
  4667 |     |             m5 := mload(0xa0)
  4668 |     |             m6 := mload(0xc0)
  4669 |     |             m7 := mload(0xe0)
  4670 |     |             m8 := mload(0x100)
  4671 |     |             // Selector of `log(address,string,address,string)`.
  4672 |     |             mstore(0x00, 0xf7e36245)
  4673 |     |             mstore(0x20, p0)
  4674 |     |             mstore(0x40, 0x80)
  4675 |     |             mstore(0x60, p2)
  4676 |     |             mstore(0x80, 0xc0)
  4677 |     |             writeString(0xa0, p1)
  4678 |     |             writeString(0xe0, p3)
  4679 |     |         }
  4680 |     |         _sendLogPayload(0x1c, 0x104);
  4681 |     |         assembly {
  4682 |     |             mstore(0x00, m0)
  4683 |     |             mstore(0x20, m1)
  4684 |     |             mstore(0x40, m2)
  4685 |     |             mstore(0x60, m3)
  4686 |     |             mstore(0x80, m4)
  4687 |     |             mstore(0xa0, m5)
  4688 |     |             mstore(0xc0, m6)
  4689 |     |             mstore(0xe0, m7)
  4690 |     |             mstore(0x100, m8)
  4691 |     |         }
  4692 |     |     }
  4693 |     | 
  4694 |     |     function log(address p0, bytes32 p1, bool p2, address p3) internal pure {
  4695 |     |         bytes32 m0;
  4696 |     |         bytes32 m1;
  4697 |     |         bytes32 m2;
  4698 |     |         bytes32 m3;
  4699 |     |         bytes32 m4;
  4700 |     |         bytes32 m5;
  4701 |     |         bytes32 m6;
  4702 |     |         assembly {
  4703 |     |             function writeString(pos, w) {
  4704 |     |                 let length := 0
  4705 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4706 |     |                 mstore(pos, length)
  4707 |     |                 let shift := sub(256, shl(3, length))
  4708 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4709 |     |             }
  4710 |     |             m0 := mload(0x00)
  4711 |     |             m1 := mload(0x20)
  4712 |     |             m2 := mload(0x40)
  4713 |     |             m3 := mload(0x60)
  4714 |     |             m4 := mload(0x80)
  4715 |     |             m5 := mload(0xa0)
  4716 |     |             m6 := mload(0xc0)
  4717 |     |             // Selector of `log(address,string,bool,address)`.
  4718 |     |             mstore(0x00, 0x205871c2)
  4719 |     |             mstore(0x20, p0)
  4720 |     |             mstore(0x40, 0x80)
  4721 |     |             mstore(0x60, p2)
  4722 |     |             mstore(0x80, p3)
  4723 |     |             writeString(0xa0, p1)
  4724 |     |         }
  4725 |     |         _sendLogPayload(0x1c, 0xc4);
  4726 |     |         assembly {
  4727 |     |             mstore(0x00, m0)
  4728 |     |             mstore(0x20, m1)
  4729 |     |             mstore(0x40, m2)
  4730 |     |             mstore(0x60, m3)
  4731 |     |             mstore(0x80, m4)
  4732 |     |             mstore(0xa0, m5)
  4733 |     |             mstore(0xc0, m6)
  4734 |     |         }
  4735 |     |     }
  4736 |     | 
  4737 |     |     function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {
  4738 |     |         bytes32 m0;
  4739 |     |         bytes32 m1;
  4740 |     |         bytes32 m2;
  4741 |     |         bytes32 m3;
  4742 |     |         bytes32 m4;
  4743 |     |         bytes32 m5;
  4744 |     |         bytes32 m6;
  4745 |     |         assembly {
  4746 |     |             function writeString(pos, w) {
  4747 |     |                 let length := 0
  4748 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4749 |     |                 mstore(pos, length)
  4750 |     |                 let shift := sub(256, shl(3, length))
  4751 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4752 |     |             }
  4753 |     |             m0 := mload(0x00)
  4754 |     |             m1 := mload(0x20)
  4755 |     |             m2 := mload(0x40)
  4756 |     |             m3 := mload(0x60)
  4757 |     |             m4 := mload(0x80)
  4758 |     |             m5 := mload(0xa0)
  4759 |     |             m6 := mload(0xc0)
  4760 |     |             // Selector of `log(address,string,bool,bool)`.
  4761 |     |             mstore(0x00, 0x5f1d5c9f)
  4762 |     |             mstore(0x20, p0)
  4763 |     |             mstore(0x40, 0x80)
  4764 |     |             mstore(0x60, p2)
  4765 |     |             mstore(0x80, p3)
  4766 |     |             writeString(0xa0, p1)
  4767 |     |         }
  4768 |     |         _sendLogPayload(0x1c, 0xc4);
  4769 |     |         assembly {
  4770 |     |             mstore(0x00, m0)
  4771 |     |             mstore(0x20, m1)
  4772 |     |             mstore(0x40, m2)
  4773 |     |             mstore(0x60, m3)
  4774 |     |             mstore(0x80, m4)
  4775 |     |             mstore(0xa0, m5)
  4776 |     |             mstore(0xc0, m6)
  4777 |     |         }
  4778 |     |     }
  4779 |     | 
  4780 |     |     function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  4781 |     |         bytes32 m0;
  4782 |     |         bytes32 m1;
  4783 |     |         bytes32 m2;
  4784 |     |         bytes32 m3;
  4785 |     |         bytes32 m4;
  4786 |     |         bytes32 m5;
  4787 |     |         bytes32 m6;
  4788 |     |         assembly {
  4789 |     |             function writeString(pos, w) {
  4790 |     |                 let length := 0
  4791 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4792 |     |                 mstore(pos, length)
  4793 |     |                 let shift := sub(256, shl(3, length))
  4794 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4795 |     |             }
  4796 |     |             m0 := mload(0x00)
  4797 |     |             m1 := mload(0x20)
  4798 |     |             m2 := mload(0x40)
  4799 |     |             m3 := mload(0x60)
  4800 |     |             m4 := mload(0x80)
  4801 |     |             m5 := mload(0xa0)
  4802 |     |             m6 := mload(0xc0)
  4803 |     |             // Selector of `log(address,string,bool,uint256)`.
  4804 |     |             mstore(0x00, 0x515e38b6)
  4805 |     |             mstore(0x20, p0)
  4806 |     |             mstore(0x40, 0x80)
  4807 |     |             mstore(0x60, p2)
  4808 |     |             mstore(0x80, p3)
  4809 |     |             writeString(0xa0, p1)
  4810 |     |         }
  4811 |     |         _sendLogPayload(0x1c, 0xc4);
  4812 |     |         assembly {
  4813 |     |             mstore(0x00, m0)
  4814 |     |             mstore(0x20, m1)
  4815 |     |             mstore(0x40, m2)
  4816 |     |             mstore(0x60, m3)
  4817 |     |             mstore(0x80, m4)
  4818 |     |             mstore(0xa0, m5)
  4819 |     |             mstore(0xc0, m6)
  4820 |     |         }
  4821 |     |     }
  4822 |     | 
  4823 |     |     function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  4824 |     |         bytes32 m0;
  4825 |     |         bytes32 m1;
  4826 |     |         bytes32 m2;
  4827 |     |         bytes32 m3;
  4828 |     |         bytes32 m4;
  4829 |     |         bytes32 m5;
  4830 |     |         bytes32 m6;
  4831 |     |         bytes32 m7;
  4832 |     |         bytes32 m8;
  4833 |     |         assembly {
  4834 |     |             function writeString(pos, w) {
  4835 |     |                 let length := 0
  4836 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4837 |     |                 mstore(pos, length)
  4838 |     |                 let shift := sub(256, shl(3, length))
  4839 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4840 |     |             }
  4841 |     |             m0 := mload(0x00)
  4842 |     |             m1 := mload(0x20)
  4843 |     |             m2 := mload(0x40)
  4844 |     |             m3 := mload(0x60)
  4845 |     |             m4 := mload(0x80)
  4846 |     |             m5 := mload(0xa0)
  4847 |     |             m6 := mload(0xc0)
  4848 |     |             m7 := mload(0xe0)
  4849 |     |             m8 := mload(0x100)
  4850 |     |             // Selector of `log(address,string,bool,string)`.
  4851 |     |             mstore(0x00, 0xbc0b61fe)
  4852 |     |             mstore(0x20, p0)
  4853 |     |             mstore(0x40, 0x80)
  4854 |     |             mstore(0x60, p2)
  4855 |     |             mstore(0x80, 0xc0)
  4856 |     |             writeString(0xa0, p1)
  4857 |     |             writeString(0xe0, p3)
  4858 |     |         }
  4859 |     |         _sendLogPayload(0x1c, 0x104);
  4860 |     |         assembly {
  4861 |     |             mstore(0x00, m0)
  4862 |     |             mstore(0x20, m1)
  4863 |     |             mstore(0x40, m2)
  4864 |     |             mstore(0x60, m3)
  4865 |     |             mstore(0x80, m4)
  4866 |     |             mstore(0xa0, m5)
  4867 |     |             mstore(0xc0, m6)
  4868 |     |             mstore(0xe0, m7)
  4869 |     |             mstore(0x100, m8)
  4870 |     |         }
  4871 |     |     }
  4872 |     | 
  4873 |     |     function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {
  4874 |     |         bytes32 m0;
  4875 |     |         bytes32 m1;
  4876 |     |         bytes32 m2;
  4877 |     |         bytes32 m3;
  4878 |     |         bytes32 m4;
  4879 |     |         bytes32 m5;
  4880 |     |         bytes32 m6;
  4881 |     |         assembly {
  4882 |     |             function writeString(pos, w) {
  4883 |     |                 let length := 0
  4884 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4885 |     |                 mstore(pos, length)
  4886 |     |                 let shift := sub(256, shl(3, length))
  4887 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4888 |     |             }
  4889 |     |             m0 := mload(0x00)
  4890 |     |             m1 := mload(0x20)
  4891 |     |             m2 := mload(0x40)
  4892 |     |             m3 := mload(0x60)
  4893 |     |             m4 := mload(0x80)
  4894 |     |             m5 := mload(0xa0)
  4895 |     |             m6 := mload(0xc0)
  4896 |     |             // Selector of `log(address,string,uint256,address)`.
  4897 |     |             mstore(0x00, 0x63183678)
  4898 |     |             mstore(0x20, p0)
  4899 |     |             mstore(0x40, 0x80)
  4900 |     |             mstore(0x60, p2)
  4901 |     |             mstore(0x80, p3)
  4902 |     |             writeString(0xa0, p1)
  4903 |     |         }
  4904 |     |         _sendLogPayload(0x1c, 0xc4);
  4905 |     |         assembly {
  4906 |     |             mstore(0x00, m0)
  4907 |     |             mstore(0x20, m1)
  4908 |     |             mstore(0x40, m2)
  4909 |     |             mstore(0x60, m3)
  4910 |     |             mstore(0x80, m4)
  4911 |     |             mstore(0xa0, m5)
  4912 |     |             mstore(0xc0, m6)
  4913 |     |         }
  4914 |     |     }
  4915 |     | 
  4916 |     |     function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  4917 |     |         bytes32 m0;
  4918 |     |         bytes32 m1;
  4919 |     |         bytes32 m2;
  4920 |     |         bytes32 m3;
  4921 |     |         bytes32 m4;
  4922 |     |         bytes32 m5;
  4923 |     |         bytes32 m6;
  4924 |     |         assembly {
  4925 |     |             function writeString(pos, w) {
  4926 |     |                 let length := 0
  4927 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4928 |     |                 mstore(pos, length)
  4929 |     |                 let shift := sub(256, shl(3, length))
  4930 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4931 |     |             }
  4932 |     |             m0 := mload(0x00)
  4933 |     |             m1 := mload(0x20)
  4934 |     |             m2 := mload(0x40)
  4935 |     |             m3 := mload(0x60)
  4936 |     |             m4 := mload(0x80)
  4937 |     |             m5 := mload(0xa0)
  4938 |     |             m6 := mload(0xc0)
  4939 |     |             // Selector of `log(address,string,uint256,bool)`.
  4940 |     |             mstore(0x00, 0x0ef7e050)
  4941 |     |             mstore(0x20, p0)
  4942 |     |             mstore(0x40, 0x80)
  4943 |     |             mstore(0x60, p2)
  4944 |     |             mstore(0x80, p3)
  4945 |     |             writeString(0xa0, p1)
  4946 |     |         }
  4947 |     |         _sendLogPayload(0x1c, 0xc4);
  4948 |     |         assembly {
  4949 |     |             mstore(0x00, m0)
  4950 |     |             mstore(0x20, m1)
  4951 |     |             mstore(0x40, m2)
  4952 |     |             mstore(0x60, m3)
  4953 |     |             mstore(0x80, m4)
  4954 |     |             mstore(0xa0, m5)
  4955 |     |             mstore(0xc0, m6)
  4956 |     |         }
  4957 |     |     }
  4958 |     | 
  4959 |     |     function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  4960 |     |         bytes32 m0;
  4961 |     |         bytes32 m1;
  4962 |     |         bytes32 m2;
  4963 |     |         bytes32 m3;
  4964 |     |         bytes32 m4;
  4965 |     |         bytes32 m5;
  4966 |     |         bytes32 m6;
  4967 |     |         assembly {
  4968 |     |             function writeString(pos, w) {
  4969 |     |                 let length := 0
  4970 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4971 |     |                 mstore(pos, length)
  4972 |     |                 let shift := sub(256, shl(3, length))
  4973 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4974 |     |             }
  4975 |     |             m0 := mload(0x00)
  4976 |     |             m1 := mload(0x20)
  4977 |     |             m2 := mload(0x40)
  4978 |     |             m3 := mload(0x60)
  4979 |     |             m4 := mload(0x80)
  4980 |     |             m5 := mload(0xa0)
  4981 |     |             m6 := mload(0xc0)
  4982 |     |             // Selector of `log(address,string,uint256,uint256)`.
  4983 |     |             mstore(0x00, 0x1dc8e1b8)
  4984 |     |             mstore(0x20, p0)
  4985 |     |             mstore(0x40, 0x80)
  4986 |     |             mstore(0x60, p2)
  4987 |     |             mstore(0x80, p3)
  4988 |     |             writeString(0xa0, p1)
  4989 |     |         }
  4990 |     |         _sendLogPayload(0x1c, 0xc4);
  4991 |     |         assembly {
  4992 |     |             mstore(0x00, m0)
  4993 |     |             mstore(0x20, m1)
  4994 |     |             mstore(0x40, m2)
  4995 |     |             mstore(0x60, m3)
  4996 |     |             mstore(0x80, m4)
  4997 |     |             mstore(0xa0, m5)
  4998 |     |             mstore(0xc0, m6)
  4999 |     |         }
  5000 |     |     }
  5001 |     | 
  5002 |     |     function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  5003 |     |         bytes32 m0;
  5004 |     |         bytes32 m1;
  5005 |     |         bytes32 m2;
  5006 |     |         bytes32 m3;
  5007 |     |         bytes32 m4;
  5008 |     |         bytes32 m5;
  5009 |     |         bytes32 m6;
  5010 |     |         bytes32 m7;
  5011 |     |         bytes32 m8;
  5012 |     |         assembly {
  5013 |     |             function writeString(pos, w) {
  5014 |     |                 let length := 0
  5015 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5016 |     |                 mstore(pos, length)
  5017 |     |                 let shift := sub(256, shl(3, length))
  5018 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5019 |     |             }
  5020 |     |             m0 := mload(0x00)
  5021 |     |             m1 := mload(0x20)
  5022 |     |             m2 := mload(0x40)
  5023 |     |             m3 := mload(0x60)
  5024 |     |             m4 := mload(0x80)
  5025 |     |             m5 := mload(0xa0)
  5026 |     |             m6 := mload(0xc0)
  5027 |     |             m7 := mload(0xe0)
  5028 |     |             m8 := mload(0x100)
  5029 |     |             // Selector of `log(address,string,uint256,string)`.
  5030 |     |             mstore(0x00, 0x448830a8)
  5031 |     |             mstore(0x20, p0)
  5032 |     |             mstore(0x40, 0x80)
  5033 |     |             mstore(0x60, p2)
  5034 |     |             mstore(0x80, 0xc0)
  5035 |     |             writeString(0xa0, p1)
  5036 |     |             writeString(0xe0, p3)
  5037 |     |         }
  5038 |     |         _sendLogPayload(0x1c, 0x104);
  5039 |     |         assembly {
  5040 |     |             mstore(0x00, m0)
  5041 |     |             mstore(0x20, m1)
  5042 |     |             mstore(0x40, m2)
  5043 |     |             mstore(0x60, m3)
  5044 |     |             mstore(0x80, m4)
  5045 |     |             mstore(0xa0, m5)
  5046 |     |             mstore(0xc0, m6)
  5047 |     |             mstore(0xe0, m7)
  5048 |     |             mstore(0x100, m8)
  5049 |     |         }
  5050 |     |     }
  5051 |     | 
  5052 |     |     function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  5053 |     |         bytes32 m0;
  5054 |     |         bytes32 m1;
  5055 |     |         bytes32 m2;
  5056 |     |         bytes32 m3;
  5057 |     |         bytes32 m4;
  5058 |     |         bytes32 m5;
  5059 |     |         bytes32 m6;
  5060 |     |         bytes32 m7;
  5061 |     |         bytes32 m8;
  5062 |     |         assembly {
  5063 |     |             function writeString(pos, w) {
  5064 |     |                 let length := 0
  5065 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5066 |     |                 mstore(pos, length)
  5067 |     |                 let shift := sub(256, shl(3, length))
  5068 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5069 |     |             }
  5070 |     |             m0 := mload(0x00)
  5071 |     |             m1 := mload(0x20)
  5072 |     |             m2 := mload(0x40)
  5073 |     |             m3 := mload(0x60)
  5074 |     |             m4 := mload(0x80)
  5075 |     |             m5 := mload(0xa0)
  5076 |     |             m6 := mload(0xc0)
  5077 |     |             m7 := mload(0xe0)
  5078 |     |             m8 := mload(0x100)
  5079 |     |             // Selector of `log(address,string,string,address)`.
  5080 |     |             mstore(0x00, 0xa04e2f87)
  5081 |     |             mstore(0x20, p0)
  5082 |     |             mstore(0x40, 0x80)
  5083 |     |             mstore(0x60, 0xc0)
  5084 |     |             mstore(0x80, p3)
  5085 |     |             writeString(0xa0, p1)
  5086 |     |             writeString(0xe0, p2)
  5087 |     |         }
  5088 |     |         _sendLogPayload(0x1c, 0x104);
  5089 |     |         assembly {
  5090 |     |             mstore(0x00, m0)
  5091 |     |             mstore(0x20, m1)
  5092 |     |             mstore(0x40, m2)
  5093 |     |             mstore(0x60, m3)
  5094 |     |             mstore(0x80, m4)
  5095 |     |             mstore(0xa0, m5)
  5096 |     |             mstore(0xc0, m6)
  5097 |     |             mstore(0xe0, m7)
  5098 |     |             mstore(0x100, m8)
  5099 |     |         }
  5100 |     |     }
  5101 |     | 
  5102 |     |     function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  5103 |     |         bytes32 m0;
  5104 |     |         bytes32 m1;
  5105 |     |         bytes32 m2;
  5106 |     |         bytes32 m3;
  5107 |     |         bytes32 m4;
  5108 |     |         bytes32 m5;
  5109 |     |         bytes32 m6;
  5110 |     |         bytes32 m7;
  5111 |     |         bytes32 m8;
  5112 |     |         assembly {
  5113 |     |             function writeString(pos, w) {
  5114 |     |                 let length := 0
  5115 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5116 |     |                 mstore(pos, length)
  5117 |     |                 let shift := sub(256, shl(3, length))
  5118 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5119 |     |             }
  5120 |     |             m0 := mload(0x00)
  5121 |     |             m1 := mload(0x20)
  5122 |     |             m2 := mload(0x40)
  5123 |     |             m3 := mload(0x60)
  5124 |     |             m4 := mload(0x80)
  5125 |     |             m5 := mload(0xa0)
  5126 |     |             m6 := mload(0xc0)
  5127 |     |             m7 := mload(0xe0)
  5128 |     |             m8 := mload(0x100)
  5129 |     |             // Selector of `log(address,string,string,bool)`.
  5130 |     |             mstore(0x00, 0x35a5071f)
  5131 |     |             mstore(0x20, p0)
  5132 |     |             mstore(0x40, 0x80)
  5133 |     |             mstore(0x60, 0xc0)
  5134 |     |             mstore(0x80, p3)
  5135 |     |             writeString(0xa0, p1)
  5136 |     |             writeString(0xe0, p2)
  5137 |     |         }
  5138 |     |         _sendLogPayload(0x1c, 0x104);
  5139 |     |         assembly {
  5140 |     |             mstore(0x00, m0)
  5141 |     |             mstore(0x20, m1)
  5142 |     |             mstore(0x40, m2)
  5143 |     |             mstore(0x60, m3)
  5144 |     |             mstore(0x80, m4)
  5145 |     |             mstore(0xa0, m5)
  5146 |     |             mstore(0xc0, m6)
  5147 |     |             mstore(0xe0, m7)
  5148 |     |             mstore(0x100, m8)
  5149 |     |         }
  5150 |     |     }
  5151 |     | 
  5152 |     |     function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  5153 |     |         bytes32 m0;
  5154 |     |         bytes32 m1;
  5155 |     |         bytes32 m2;
  5156 |     |         bytes32 m3;
  5157 |     |         bytes32 m4;
  5158 |     |         bytes32 m5;
  5159 |     |         bytes32 m6;
  5160 |     |         bytes32 m7;
  5161 |     |         bytes32 m8;
  5162 |     |         assembly {
  5163 |     |             function writeString(pos, w) {
  5164 |     |                 let length := 0
  5165 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5166 |     |                 mstore(pos, length)
  5167 |     |                 let shift := sub(256, shl(3, length))
  5168 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5169 |     |             }
  5170 |     |             m0 := mload(0x00)
  5171 |     |             m1 := mload(0x20)
  5172 |     |             m2 := mload(0x40)
  5173 |     |             m3 := mload(0x60)
  5174 |     |             m4 := mload(0x80)
  5175 |     |             m5 := mload(0xa0)
  5176 |     |             m6 := mload(0xc0)
  5177 |     |             m7 := mload(0xe0)
  5178 |     |             m8 := mload(0x100)
  5179 |     |             // Selector of `log(address,string,string,uint256)`.
  5180 |     |             mstore(0x00, 0x159f8927)
  5181 |     |             mstore(0x20, p0)
  5182 |     |             mstore(0x40, 0x80)
  5183 |     |             mstore(0x60, 0xc0)
  5184 |     |             mstore(0x80, p3)
  5185 |     |             writeString(0xa0, p1)
  5186 |     |             writeString(0xe0, p2)
  5187 |     |         }
  5188 |     |         _sendLogPayload(0x1c, 0x104);
  5189 |     |         assembly {
  5190 |     |             mstore(0x00, m0)
  5191 |     |             mstore(0x20, m1)
  5192 |     |             mstore(0x40, m2)
  5193 |     |             mstore(0x60, m3)
  5194 |     |             mstore(0x80, m4)
  5195 |     |             mstore(0xa0, m5)
  5196 |     |             mstore(0xc0, m6)
  5197 |     |             mstore(0xe0, m7)
  5198 |     |             mstore(0x100, m8)
  5199 |     |         }
  5200 |     |     }
  5201 |     | 
  5202 |     |     function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  5203 |     |         bytes32 m0;
  5204 |     |         bytes32 m1;
  5205 |     |         bytes32 m2;
  5206 |     |         bytes32 m3;
  5207 |     |         bytes32 m4;
  5208 |     |         bytes32 m5;
  5209 |     |         bytes32 m6;
  5210 |     |         bytes32 m7;
  5211 |     |         bytes32 m8;
  5212 |     |         bytes32 m9;
  5213 |     |         bytes32 m10;
  5214 |     |         assembly {
  5215 |     |             function writeString(pos, w) {
  5216 |     |                 let length := 0
  5217 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5218 |     |                 mstore(pos, length)
  5219 |     |                 let shift := sub(256, shl(3, length))
  5220 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5221 |     |             }
  5222 |     |             m0 := mload(0x00)
  5223 |     |             m1 := mload(0x20)
  5224 |     |             m2 := mload(0x40)
  5225 |     |             m3 := mload(0x60)
  5226 |     |             m4 := mload(0x80)
  5227 |     |             m5 := mload(0xa0)
  5228 |     |             m6 := mload(0xc0)
  5229 |     |             m7 := mload(0xe0)
  5230 |     |             m8 := mload(0x100)
  5231 |     |             m9 := mload(0x120)
  5232 |     |             m10 := mload(0x140)
  5233 |     |             // Selector of `log(address,string,string,string)`.
  5234 |     |             mstore(0x00, 0x5d02c50b)
  5235 |     |             mstore(0x20, p0)
  5236 |     |             mstore(0x40, 0x80)
  5237 |     |             mstore(0x60, 0xc0)
  5238 |     |             mstore(0x80, 0x100)
  5239 |     |             writeString(0xa0, p1)
  5240 |     |             writeString(0xe0, p2)
  5241 |     |             writeString(0x120, p3)
  5242 |     |         }
  5243 |     |         _sendLogPayload(0x1c, 0x144);
  5244 |     |         assembly {
  5245 |     |             mstore(0x00, m0)
  5246 |     |             mstore(0x20, m1)
  5247 |     |             mstore(0x40, m2)
  5248 |     |             mstore(0x60, m3)
  5249 |     |             mstore(0x80, m4)
  5250 |     |             mstore(0xa0, m5)
  5251 |     |             mstore(0xc0, m6)
  5252 |     |             mstore(0xe0, m7)
  5253 |     |             mstore(0x100, m8)
  5254 |     |             mstore(0x120, m9)
  5255 |     |             mstore(0x140, m10)
  5256 |     |         }
  5257 |     |     }
  5258 |     | 
  5259 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
  5260 |     |         bytes32 m0;
  5261 |     |         bytes32 m1;
  5262 |     |         bytes32 m2;
  5263 |     |         bytes32 m3;
  5264 |     |         bytes32 m4;
  5265 |     |         assembly {
  5266 |     |             m0 := mload(0x00)
  5267 |     |             m1 := mload(0x20)
  5268 |     |             m2 := mload(0x40)
  5269 |     |             m3 := mload(0x60)
  5270 |     |             m4 := mload(0x80)
  5271 |     |             // Selector of `log(bool,address,address,address)`.
  5272 |     |             mstore(0x00, 0x1d14d001)
  5273 |     |             mstore(0x20, p0)
  5274 |     |             mstore(0x40, p1)
  5275 |     |             mstore(0x60, p2)
  5276 |     |             mstore(0x80, p3)
  5277 |     |         }
  5278 |     |         _sendLogPayload(0x1c, 0x84);
  5279 |     |         assembly {
  5280 |     |             mstore(0x00, m0)
  5281 |     |             mstore(0x20, m1)
  5282 |     |             mstore(0x40, m2)
  5283 |     |             mstore(0x60, m3)
  5284 |     |             mstore(0x80, m4)
  5285 |     |         }
  5286 |     |     }
  5287 |     | 
  5288 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
  5289 |     |         bytes32 m0;
  5290 |     |         bytes32 m1;
  5291 |     |         bytes32 m2;
  5292 |     |         bytes32 m3;
  5293 |     |         bytes32 m4;
  5294 |     |         assembly {
  5295 |     |             m0 := mload(0x00)
  5296 |     |             m1 := mload(0x20)
  5297 |     |             m2 := mload(0x40)
  5298 |     |             m3 := mload(0x60)
  5299 |     |             m4 := mload(0x80)
  5300 |     |             // Selector of `log(bool,address,address,bool)`.
  5301 |     |             mstore(0x00, 0x46600be0)
  5302 |     |             mstore(0x20, p0)
  5303 |     |             mstore(0x40, p1)
  5304 |     |             mstore(0x60, p2)
  5305 |     |             mstore(0x80, p3)
  5306 |     |         }
  5307 |     |         _sendLogPayload(0x1c, 0x84);
  5308 |     |         assembly {
  5309 |     |             mstore(0x00, m0)
  5310 |     |             mstore(0x20, m1)
  5311 |     |             mstore(0x40, m2)
  5312 |     |             mstore(0x60, m3)
  5313 |     |             mstore(0x80, m4)
  5314 |     |         }
  5315 |     |     }
  5316 |     | 
  5317 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
  5318 |     |         bytes32 m0;
  5319 |     |         bytes32 m1;
  5320 |     |         bytes32 m2;
  5321 |     |         bytes32 m3;
  5322 |     |         bytes32 m4;
  5323 |     |         assembly {
  5324 |     |             m0 := mload(0x00)
  5325 |     |             m1 := mload(0x20)
  5326 |     |             m2 := mload(0x40)
  5327 |     |             m3 := mload(0x60)
  5328 |     |             m4 := mload(0x80)
  5329 |     |             // Selector of `log(bool,address,address,uint256)`.
  5330 |     |             mstore(0x00, 0x0c66d1be)
  5331 |     |             mstore(0x20, p0)
  5332 |     |             mstore(0x40, p1)
  5333 |     |             mstore(0x60, p2)
  5334 |     |             mstore(0x80, p3)
  5335 |     |         }
  5336 |     |         _sendLogPayload(0x1c, 0x84);
  5337 |     |         assembly {
  5338 |     |             mstore(0x00, m0)
  5339 |     |             mstore(0x20, m1)
  5340 |     |             mstore(0x40, m2)
  5341 |     |             mstore(0x60, m3)
  5342 |     |             mstore(0x80, m4)
  5343 |     |         }
  5344 |     |     }
  5345 |     | 
  5346 |     |     function log(bool p0, address p1, address p2, bytes32 p3) internal pure {
  5347 |     |         bytes32 m0;
  5348 |     |         bytes32 m1;
  5349 |     |         bytes32 m2;
  5350 |     |         bytes32 m3;
  5351 |     |         bytes32 m4;
  5352 |     |         bytes32 m5;
  5353 |     |         bytes32 m6;
  5354 |     |         assembly {
  5355 |     |             function writeString(pos, w) {
  5356 |     |                 let length := 0
  5357 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5358 |     |                 mstore(pos, length)
  5359 |     |                 let shift := sub(256, shl(3, length))
  5360 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5361 |     |             }
  5362 |     |             m0 := mload(0x00)
  5363 |     |             m1 := mload(0x20)
  5364 |     |             m2 := mload(0x40)
  5365 |     |             m3 := mload(0x60)
  5366 |     |             m4 := mload(0x80)
  5367 |     |             m5 := mload(0xa0)
  5368 |     |             m6 := mload(0xc0)
  5369 |     |             // Selector of `log(bool,address,address,string)`.
  5370 |     |             mstore(0x00, 0xd812a167)
  5371 |     |             mstore(0x20, p0)
  5372 |     |             mstore(0x40, p1)
  5373 |     |             mstore(0x60, p2)
  5374 |     |             mstore(0x80, 0x80)
  5375 |     |             writeString(0xa0, p3)
  5376 |     |         }
  5377 |     |         _sendLogPayload(0x1c, 0xc4);
  5378 |     |         assembly {
  5379 |     |             mstore(0x00, m0)
  5380 |     |             mstore(0x20, m1)
  5381 |     |             mstore(0x40, m2)
  5382 |     |             mstore(0x60, m3)
  5383 |     |             mstore(0x80, m4)
  5384 |     |             mstore(0xa0, m5)
  5385 |     |             mstore(0xc0, m6)
  5386 |     |         }
  5387 |     |     }
  5388 |     | 
  5389 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
  5390 |     |         bytes32 m0;
  5391 |     |         bytes32 m1;
  5392 |     |         bytes32 m2;
  5393 |     |         bytes32 m3;
  5394 |     |         bytes32 m4;
  5395 |     |         assembly {
  5396 |     |             m0 := mload(0x00)
  5397 |     |             m1 := mload(0x20)
  5398 |     |             m2 := mload(0x40)
  5399 |     |             m3 := mload(0x60)
  5400 |     |             m4 := mload(0x80)
  5401 |     |             // Selector of `log(bool,address,bool,address)`.
  5402 |     |             mstore(0x00, 0x1c41a336)
  5403 |     |             mstore(0x20, p0)
  5404 |     |             mstore(0x40, p1)
  5405 |     |             mstore(0x60, p2)
  5406 |     |             mstore(0x80, p3)
  5407 |     |         }
  5408 |     |         _sendLogPayload(0x1c, 0x84);
  5409 |     |         assembly {
  5410 |     |             mstore(0x00, m0)
  5411 |     |             mstore(0x20, m1)
  5412 |     |             mstore(0x40, m2)
  5413 |     |             mstore(0x60, m3)
  5414 |     |             mstore(0x80, m4)
  5415 |     |         }
  5416 |     |     }
  5417 |     | 
  5418 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
  5419 |     |         bytes32 m0;
  5420 |     |         bytes32 m1;
  5421 |     |         bytes32 m2;
  5422 |     |         bytes32 m3;
  5423 |     |         bytes32 m4;
  5424 |     |         assembly {
  5425 |     |             m0 := mload(0x00)
  5426 |     |             m1 := mload(0x20)
  5427 |     |             m2 := mload(0x40)
  5428 |     |             m3 := mload(0x60)
  5429 |     |             m4 := mload(0x80)
  5430 |     |             // Selector of `log(bool,address,bool,bool)`.
  5431 |     |             mstore(0x00, 0x6a9c478b)
  5432 |     |             mstore(0x20, p0)
  5433 |     |             mstore(0x40, p1)
  5434 |     |             mstore(0x60, p2)
  5435 |     |             mstore(0x80, p3)
  5436 |     |         }
  5437 |     |         _sendLogPayload(0x1c, 0x84);
  5438 |     |         assembly {
  5439 |     |             mstore(0x00, m0)
  5440 |     |             mstore(0x20, m1)
  5441 |     |             mstore(0x40, m2)
  5442 |     |             mstore(0x60, m3)
  5443 |     |             mstore(0x80, m4)
  5444 |     |         }
  5445 |     |     }
  5446 |     | 
  5447 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
  5448 |     |         bytes32 m0;
  5449 |     |         bytes32 m1;
  5450 |     |         bytes32 m2;
  5451 |     |         bytes32 m3;
  5452 |     |         bytes32 m4;
  5453 |     |         assembly {
  5454 |     |             m0 := mload(0x00)
  5455 |     |             m1 := mload(0x20)
  5456 |     |             m2 := mload(0x40)
  5457 |     |             m3 := mload(0x60)
  5458 |     |             m4 := mload(0x80)
  5459 |     |             // Selector of `log(bool,address,bool,uint256)`.
  5460 |     |             mstore(0x00, 0x07831502)
  5461 |     |             mstore(0x20, p0)
  5462 |     |             mstore(0x40, p1)
  5463 |     |             mstore(0x60, p2)
  5464 |     |             mstore(0x80, p3)
  5465 |     |         }
  5466 |     |         _sendLogPayload(0x1c, 0x84);
  5467 |     |         assembly {
  5468 |     |             mstore(0x00, m0)
  5469 |     |             mstore(0x20, m1)
  5470 |     |             mstore(0x40, m2)
  5471 |     |             mstore(0x60, m3)
  5472 |     |             mstore(0x80, m4)
  5473 |     |         }
  5474 |     |     }
  5475 |     | 
  5476 |     |     function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {
  5477 |     |         bytes32 m0;
  5478 |     |         bytes32 m1;
  5479 |     |         bytes32 m2;
  5480 |     |         bytes32 m3;
  5481 |     |         bytes32 m4;
  5482 |     |         bytes32 m5;
  5483 |     |         bytes32 m6;
  5484 |     |         assembly {
  5485 |     |             function writeString(pos, w) {
  5486 |     |                 let length := 0
  5487 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5488 |     |                 mstore(pos, length)
  5489 |     |                 let shift := sub(256, shl(3, length))
  5490 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5491 |     |             }
  5492 |     |             m0 := mload(0x00)
  5493 |     |             m1 := mload(0x20)
  5494 |     |             m2 := mload(0x40)
  5495 |     |             m3 := mload(0x60)
  5496 |     |             m4 := mload(0x80)
  5497 |     |             m5 := mload(0xa0)
  5498 |     |             m6 := mload(0xc0)
  5499 |     |             // Selector of `log(bool,address,bool,string)`.
  5500 |     |             mstore(0x00, 0x4a66cb34)
  5501 |     |             mstore(0x20, p0)
  5502 |     |             mstore(0x40, p1)
  5503 |     |             mstore(0x60, p2)
  5504 |     |             mstore(0x80, 0x80)
  5505 |     |             writeString(0xa0, p3)
  5506 |     |         }
  5507 |     |         _sendLogPayload(0x1c, 0xc4);
  5508 |     |         assembly {
  5509 |     |             mstore(0x00, m0)
  5510 |     |             mstore(0x20, m1)
  5511 |     |             mstore(0x40, m2)
  5512 |     |             mstore(0x60, m3)
  5513 |     |             mstore(0x80, m4)
  5514 |     |             mstore(0xa0, m5)
  5515 |     |             mstore(0xc0, m6)
  5516 |     |         }
  5517 |     |     }
  5518 |     | 
  5519 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
  5520 |     |         bytes32 m0;
  5521 |     |         bytes32 m1;
  5522 |     |         bytes32 m2;
  5523 |     |         bytes32 m3;
  5524 |     |         bytes32 m4;
  5525 |     |         assembly {
  5526 |     |             m0 := mload(0x00)
  5527 |     |             m1 := mload(0x20)
  5528 |     |             m2 := mload(0x40)
  5529 |     |             m3 := mload(0x60)
  5530 |     |             m4 := mload(0x80)
  5531 |     |             // Selector of `log(bool,address,uint256,address)`.
  5532 |     |             mstore(0x00, 0x136b05dd)
  5533 |     |             mstore(0x20, p0)
  5534 |     |             mstore(0x40, p1)
  5535 |     |             mstore(0x60, p2)
  5536 |     |             mstore(0x80, p3)
  5537 |     |         }
  5538 |     |         _sendLogPayload(0x1c, 0x84);
  5539 |     |         assembly {
  5540 |     |             mstore(0x00, m0)
  5541 |     |             mstore(0x20, m1)
  5542 |     |             mstore(0x40, m2)
  5543 |     |             mstore(0x60, m3)
  5544 |     |             mstore(0x80, m4)
  5545 |     |         }
  5546 |     |     }
  5547 |     | 
  5548 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
  5549 |     |         bytes32 m0;
  5550 |     |         bytes32 m1;
  5551 |     |         bytes32 m2;
  5552 |     |         bytes32 m3;
  5553 |     |         bytes32 m4;
  5554 |     |         assembly {
  5555 |     |             m0 := mload(0x00)
  5556 |     |             m1 := mload(0x20)
  5557 |     |             m2 := mload(0x40)
  5558 |     |             m3 := mload(0x60)
  5559 |     |             m4 := mload(0x80)
  5560 |     |             // Selector of `log(bool,address,uint256,bool)`.
  5561 |     |             mstore(0x00, 0xd6019f1c)
  5562 |     |             mstore(0x20, p0)
  5563 |     |             mstore(0x40, p1)
  5564 |     |             mstore(0x60, p2)
  5565 |     |             mstore(0x80, p3)
  5566 |     |         }
  5567 |     |         _sendLogPayload(0x1c, 0x84);
  5568 |     |         assembly {
  5569 |     |             mstore(0x00, m0)
  5570 |     |             mstore(0x20, m1)
  5571 |     |             mstore(0x40, m2)
  5572 |     |             mstore(0x60, m3)
  5573 |     |             mstore(0x80, m4)
  5574 |     |         }
  5575 |     |     }
  5576 |     | 
  5577 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
  5578 |     |         bytes32 m0;
  5579 |     |         bytes32 m1;
  5580 |     |         bytes32 m2;
  5581 |     |         bytes32 m3;
  5582 |     |         bytes32 m4;
  5583 |     |         assembly {
  5584 |     |             m0 := mload(0x00)
  5585 |     |             m1 := mload(0x20)
  5586 |     |             m2 := mload(0x40)
  5587 |     |             m3 := mload(0x60)
  5588 |     |             m4 := mload(0x80)
  5589 |     |             // Selector of `log(bool,address,uint256,uint256)`.
  5590 |     |             mstore(0x00, 0x7bf181a1)
  5591 |     |             mstore(0x20, p0)
  5592 |     |             mstore(0x40, p1)
  5593 |     |             mstore(0x60, p2)
  5594 |     |             mstore(0x80, p3)
  5595 |     |         }
  5596 |     |         _sendLogPayload(0x1c, 0x84);
  5597 |     |         assembly {
  5598 |     |             mstore(0x00, m0)
  5599 |     |             mstore(0x20, m1)
  5600 |     |             mstore(0x40, m2)
  5601 |     |             mstore(0x60, m3)
  5602 |     |             mstore(0x80, m4)
  5603 |     |         }
  5604 |     |     }
  5605 |     | 
  5606 |     |     function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {
  5607 |     |         bytes32 m0;
  5608 |     |         bytes32 m1;
  5609 |     |         bytes32 m2;
  5610 |     |         bytes32 m3;
  5611 |     |         bytes32 m4;
  5612 |     |         bytes32 m5;
  5613 |     |         bytes32 m6;
  5614 |     |         assembly {
  5615 |     |             function writeString(pos, w) {
  5616 |     |                 let length := 0
  5617 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5618 |     |                 mstore(pos, length)
  5619 |     |                 let shift := sub(256, shl(3, length))
  5620 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5621 |     |             }
  5622 |     |             m0 := mload(0x00)
  5623 |     |             m1 := mload(0x20)
  5624 |     |             m2 := mload(0x40)
  5625 |     |             m3 := mload(0x60)
  5626 |     |             m4 := mload(0x80)
  5627 |     |             m5 := mload(0xa0)
  5628 |     |             m6 := mload(0xc0)
  5629 |     |             // Selector of `log(bool,address,uint256,string)`.
  5630 |     |             mstore(0x00, 0x51f09ff8)
  5631 |     |             mstore(0x20, p0)
  5632 |     |             mstore(0x40, p1)
  5633 |     |             mstore(0x60, p2)
  5634 |     |             mstore(0x80, 0x80)
  5635 |     |             writeString(0xa0, p3)
  5636 |     |         }
  5637 |     |         _sendLogPayload(0x1c, 0xc4);
  5638 |     |         assembly {
  5639 |     |             mstore(0x00, m0)
  5640 |     |             mstore(0x20, m1)
  5641 |     |             mstore(0x40, m2)
  5642 |     |             mstore(0x60, m3)
  5643 |     |             mstore(0x80, m4)
  5644 |     |             mstore(0xa0, m5)
  5645 |     |             mstore(0xc0, m6)
  5646 |     |         }
  5647 |     |     }
  5648 |     | 
  5649 |     |     function log(bool p0, address p1, bytes32 p2, address p3) internal pure {
  5650 |     |         bytes32 m0;
  5651 |     |         bytes32 m1;
  5652 |     |         bytes32 m2;
  5653 |     |         bytes32 m3;
  5654 |     |         bytes32 m4;
  5655 |     |         bytes32 m5;
  5656 |     |         bytes32 m6;
  5657 |     |         assembly {
  5658 |     |             function writeString(pos, w) {
  5659 |     |                 let length := 0
  5660 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5661 |     |                 mstore(pos, length)
  5662 |     |                 let shift := sub(256, shl(3, length))
  5663 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5664 |     |             }
  5665 |     |             m0 := mload(0x00)
  5666 |     |             m1 := mload(0x20)
  5667 |     |             m2 := mload(0x40)
  5668 |     |             m3 := mload(0x60)
  5669 |     |             m4 := mload(0x80)
  5670 |     |             m5 := mload(0xa0)
  5671 |     |             m6 := mload(0xc0)
  5672 |     |             // Selector of `log(bool,address,string,address)`.
  5673 |     |             mstore(0x00, 0x6f7c603e)
  5674 |     |             mstore(0x20, p0)
  5675 |     |             mstore(0x40, p1)
  5676 |     |             mstore(0x60, 0x80)
  5677 |     |             mstore(0x80, p3)
  5678 |     |             writeString(0xa0, p2)
  5679 |     |         }
  5680 |     |         _sendLogPayload(0x1c, 0xc4);
  5681 |     |         assembly {
  5682 |     |             mstore(0x00, m0)
  5683 |     |             mstore(0x20, m1)
  5684 |     |             mstore(0x40, m2)
  5685 |     |             mstore(0x60, m3)
  5686 |     |             mstore(0x80, m4)
  5687 |     |             mstore(0xa0, m5)
  5688 |     |             mstore(0xc0, m6)
  5689 |     |         }
  5690 |     |     }
  5691 |     | 
  5692 |     |     function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {
  5693 |     |         bytes32 m0;
  5694 |     |         bytes32 m1;
  5695 |     |         bytes32 m2;
  5696 |     |         bytes32 m3;
  5697 |     |         bytes32 m4;
  5698 |     |         bytes32 m5;
  5699 |     |         bytes32 m6;
  5700 |     |         assembly {
  5701 |     |             function writeString(pos, w) {
  5702 |     |                 let length := 0
  5703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5704 |     |                 mstore(pos, length)
  5705 |     |                 let shift := sub(256, shl(3, length))
  5706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5707 |     |             }
  5708 |     |             m0 := mload(0x00)
  5709 |     |             m1 := mload(0x20)
  5710 |     |             m2 := mload(0x40)
  5711 |     |             m3 := mload(0x60)
  5712 |     |             m4 := mload(0x80)
  5713 |     |             m5 := mload(0xa0)
  5714 |     |             m6 := mload(0xc0)
  5715 |     |             // Selector of `log(bool,address,string,bool)`.
  5716 |     |             mstore(0x00, 0xe2bfd60b)
  5717 |     |             mstore(0x20, p0)
  5718 |     |             mstore(0x40, p1)
  5719 |     |             mstore(0x60, 0x80)
  5720 |     |             mstore(0x80, p3)
  5721 |     |             writeString(0xa0, p2)
  5722 |     |         }
  5723 |     |         _sendLogPayload(0x1c, 0xc4);
  5724 |     |         assembly {
  5725 |     |             mstore(0x00, m0)
  5726 |     |             mstore(0x20, m1)
  5727 |     |             mstore(0x40, m2)
  5728 |     |             mstore(0x60, m3)
  5729 |     |             mstore(0x80, m4)
  5730 |     |             mstore(0xa0, m5)
  5731 |     |             mstore(0xc0, m6)
  5732 |     |         }
  5733 |     |     }
  5734 |     | 
  5735 |     |     function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {
  5736 |     |         bytes32 m0;
  5737 |     |         bytes32 m1;
  5738 |     |         bytes32 m2;
  5739 |     |         bytes32 m3;
  5740 |     |         bytes32 m4;
  5741 |     |         bytes32 m5;
  5742 |     |         bytes32 m6;
  5743 |     |         assembly {
  5744 |     |             function writeString(pos, w) {
  5745 |     |                 let length := 0
  5746 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5747 |     |                 mstore(pos, length)
  5748 |     |                 let shift := sub(256, shl(3, length))
  5749 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5750 |     |             }
  5751 |     |             m0 := mload(0x00)
  5752 |     |             m1 := mload(0x20)
  5753 |     |             m2 := mload(0x40)
  5754 |     |             m3 := mload(0x60)
  5755 |     |             m4 := mload(0x80)
  5756 |     |             m5 := mload(0xa0)
  5757 |     |             m6 := mload(0xc0)
  5758 |     |             // Selector of `log(bool,address,string,uint256)`.
  5759 |     |             mstore(0x00, 0xc21f64c7)
  5760 |     |             mstore(0x20, p0)
  5761 |     |             mstore(0x40, p1)
  5762 |     |             mstore(0x60, 0x80)
  5763 |     |             mstore(0x80, p3)
  5764 |     |             writeString(0xa0, p2)
  5765 |     |         }
  5766 |     |         _sendLogPayload(0x1c, 0xc4);
  5767 |     |         assembly {
  5768 |     |             mstore(0x00, m0)
  5769 |     |             mstore(0x20, m1)
  5770 |     |             mstore(0x40, m2)
  5771 |     |             mstore(0x60, m3)
  5772 |     |             mstore(0x80, m4)
  5773 |     |             mstore(0xa0, m5)
  5774 |     |             mstore(0xc0, m6)
  5775 |     |         }
  5776 |     |     }
  5777 |     | 
  5778 |     |     function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  5779 |     |         bytes32 m0;
  5780 |     |         bytes32 m1;
  5781 |     |         bytes32 m2;
  5782 |     |         bytes32 m3;
  5783 |     |         bytes32 m4;
  5784 |     |         bytes32 m5;
  5785 |     |         bytes32 m6;
  5786 |     |         bytes32 m7;
  5787 |     |         bytes32 m8;
  5788 |     |         assembly {
  5789 |     |             function writeString(pos, w) {
  5790 |     |                 let length := 0
  5791 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5792 |     |                 mstore(pos, length)
  5793 |     |                 let shift := sub(256, shl(3, length))
  5794 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5795 |     |             }
  5796 |     |             m0 := mload(0x00)
  5797 |     |             m1 := mload(0x20)
  5798 |     |             m2 := mload(0x40)
  5799 |     |             m3 := mload(0x60)
  5800 |     |             m4 := mload(0x80)
  5801 |     |             m5 := mload(0xa0)
  5802 |     |             m6 := mload(0xc0)
  5803 |     |             m7 := mload(0xe0)
  5804 |     |             m8 := mload(0x100)
  5805 |     |             // Selector of `log(bool,address,string,string)`.
  5806 |     |             mstore(0x00, 0xa73c1db6)
  5807 |     |             mstore(0x20, p0)
  5808 |     |             mstore(0x40, p1)
  5809 |     |             mstore(0x60, 0x80)
  5810 |     |             mstore(0x80, 0xc0)
  5811 |     |             writeString(0xa0, p2)
  5812 |     |             writeString(0xe0, p3)
  5813 |     |         }
  5814 |     |         _sendLogPayload(0x1c, 0x104);
  5815 |     |         assembly {
  5816 |     |             mstore(0x00, m0)
  5817 |     |             mstore(0x20, m1)
  5818 |     |             mstore(0x40, m2)
  5819 |     |             mstore(0x60, m3)
  5820 |     |             mstore(0x80, m4)
  5821 |     |             mstore(0xa0, m5)
  5822 |     |             mstore(0xc0, m6)
  5823 |     |             mstore(0xe0, m7)
  5824 |     |             mstore(0x100, m8)
  5825 |     |         }
  5826 |     |     }
  5827 |     | 
  5828 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
  5829 |     |         bytes32 m0;
  5830 |     |         bytes32 m1;
  5831 |     |         bytes32 m2;
  5832 |     |         bytes32 m3;
  5833 |     |         bytes32 m4;
  5834 |     |         assembly {
  5835 |     |             m0 := mload(0x00)
  5836 |     |             m1 := mload(0x20)
  5837 |     |             m2 := mload(0x40)
  5838 |     |             m3 := mload(0x60)
  5839 |     |             m4 := mload(0x80)
  5840 |     |             // Selector of `log(bool,bool,address,address)`.
  5841 |     |             mstore(0x00, 0xf4880ea4)
  5842 |     |             mstore(0x20, p0)
  5843 |     |             mstore(0x40, p1)
  5844 |     |             mstore(0x60, p2)
  5845 |     |             mstore(0x80, p3)
  5846 |     |         }
  5847 |     |         _sendLogPayload(0x1c, 0x84);
  5848 |     |         assembly {
  5849 |     |             mstore(0x00, m0)
  5850 |     |             mstore(0x20, m1)
  5851 |     |             mstore(0x40, m2)
  5852 |     |             mstore(0x60, m3)
  5853 |     |             mstore(0x80, m4)
  5854 |     |         }
  5855 |     |     }
  5856 |     | 
  5857 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
  5858 |     |         bytes32 m0;
  5859 |     |         bytes32 m1;
  5860 |     |         bytes32 m2;
  5861 |     |         bytes32 m3;
  5862 |     |         bytes32 m4;
  5863 |     |         assembly {
  5864 |     |             m0 := mload(0x00)
  5865 |     |             m1 := mload(0x20)
  5866 |     |             m2 := mload(0x40)
  5867 |     |             m3 := mload(0x60)
  5868 |     |             m4 := mload(0x80)
  5869 |     |             // Selector of `log(bool,bool,address,bool)`.
  5870 |     |             mstore(0x00, 0xc0a302d8)
  5871 |     |             mstore(0x20, p0)
  5872 |     |             mstore(0x40, p1)
  5873 |     |             mstore(0x60, p2)
  5874 |     |             mstore(0x80, p3)
  5875 |     |         }
  5876 |     |         _sendLogPayload(0x1c, 0x84);
  5877 |     |         assembly {
  5878 |     |             mstore(0x00, m0)
  5879 |     |             mstore(0x20, m1)
  5880 |     |             mstore(0x40, m2)
  5881 |     |             mstore(0x60, m3)
  5882 |     |             mstore(0x80, m4)
  5883 |     |         }
  5884 |     |     }
  5885 |     | 
  5886 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
  5887 |     |         bytes32 m0;
  5888 |     |         bytes32 m1;
  5889 |     |         bytes32 m2;
  5890 |     |         bytes32 m3;
  5891 |     |         bytes32 m4;
  5892 |     |         assembly {
  5893 |     |             m0 := mload(0x00)
  5894 |     |             m1 := mload(0x20)
  5895 |     |             m2 := mload(0x40)
  5896 |     |             m3 := mload(0x60)
  5897 |     |             m4 := mload(0x80)
  5898 |     |             // Selector of `log(bool,bool,address,uint256)`.
  5899 |     |             mstore(0x00, 0x4c123d57)
  5900 |     |             mstore(0x20, p0)
  5901 |     |             mstore(0x40, p1)
  5902 |     |             mstore(0x60, p2)
  5903 |     |             mstore(0x80, p3)
  5904 |     |         }
  5905 |     |         _sendLogPayload(0x1c, 0x84);
  5906 |     |         assembly {
  5907 |     |             mstore(0x00, m0)
  5908 |     |             mstore(0x20, m1)
  5909 |     |             mstore(0x40, m2)
  5910 |     |             mstore(0x60, m3)
  5911 |     |             mstore(0x80, m4)
  5912 |     |         }
  5913 |     |     }
  5914 |     | 
  5915 |     |     function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {
  5916 |     |         bytes32 m0;
  5917 |     |         bytes32 m1;
  5918 |     |         bytes32 m2;
  5919 |     |         bytes32 m3;
  5920 |     |         bytes32 m4;
  5921 |     |         bytes32 m5;
  5922 |     |         bytes32 m6;
  5923 |     |         assembly {
  5924 |     |             function writeString(pos, w) {
  5925 |     |                 let length := 0
  5926 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5927 |     |                 mstore(pos, length)
  5928 |     |                 let shift := sub(256, shl(3, length))
  5929 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5930 |     |             }
  5931 |     |             m0 := mload(0x00)
  5932 |     |             m1 := mload(0x20)
  5933 |     |             m2 := mload(0x40)
  5934 |     |             m3 := mload(0x60)
  5935 |     |             m4 := mload(0x80)
  5936 |     |             m5 := mload(0xa0)
  5937 |     |             m6 := mload(0xc0)
  5938 |     |             // Selector of `log(bool,bool,address,string)`.
  5939 |     |             mstore(0x00, 0xa0a47963)
  5940 |     |             mstore(0x20, p0)
  5941 |     |             mstore(0x40, p1)
  5942 |     |             mstore(0x60, p2)
  5943 |     |             mstore(0x80, 0x80)
  5944 |     |             writeString(0xa0, p3)
  5945 |     |         }
  5946 |     |         _sendLogPayload(0x1c, 0xc4);
  5947 |     |         assembly {
  5948 |     |             mstore(0x00, m0)
  5949 |     |             mstore(0x20, m1)
  5950 |     |             mstore(0x40, m2)
  5951 |     |             mstore(0x60, m3)
  5952 |     |             mstore(0x80, m4)
  5953 |     |             mstore(0xa0, m5)
  5954 |     |             mstore(0xc0, m6)
  5955 |     |         }
  5956 |     |     }
  5957 |     | 
  5958 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
  5959 |     |         bytes32 m0;
  5960 |     |         bytes32 m1;
  5961 |     |         bytes32 m2;
  5962 |     |         bytes32 m3;
  5963 |     |         bytes32 m4;
  5964 |     |         assembly {
  5965 |     |             m0 := mload(0x00)
  5966 |     |             m1 := mload(0x20)
  5967 |     |             m2 := mload(0x40)
  5968 |     |             m3 := mload(0x60)
  5969 |     |             m4 := mload(0x80)
  5970 |     |             // Selector of `log(bool,bool,bool,address)`.
  5971 |     |             mstore(0x00, 0x8c329b1a)
  5972 |     |             mstore(0x20, p0)
  5973 |     |             mstore(0x40, p1)
  5974 |     |             mstore(0x60, p2)
  5975 |     |             mstore(0x80, p3)
  5976 |     |         }
  5977 |     |         _sendLogPayload(0x1c, 0x84);
  5978 |     |         assembly {
  5979 |     |             mstore(0x00, m0)
  5980 |     |             mstore(0x20, m1)
  5981 |     |             mstore(0x40, m2)
  5982 |     |             mstore(0x60, m3)
  5983 |     |             mstore(0x80, m4)
  5984 |     |         }
  5985 |     |     }
  5986 |     | 
  5987 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
  5988 |     |         bytes32 m0;
  5989 |     |         bytes32 m1;
  5990 |     |         bytes32 m2;
  5991 |     |         bytes32 m3;
  5992 |     |         bytes32 m4;
  5993 |     |         assembly {
  5994 |     |             m0 := mload(0x00)
  5995 |     |             m1 := mload(0x20)
  5996 |     |             m2 := mload(0x40)
  5997 |     |             m3 := mload(0x60)
  5998 |     |             m4 := mload(0x80)
  5999 |     |             // Selector of `log(bool,bool,bool,bool)`.
  6000 |     |             mstore(0x00, 0x3b2a5ce0)
  6001 |     |             mstore(0x20, p0)
  6002 |     |             mstore(0x40, p1)
  6003 |     |             mstore(0x60, p2)
  6004 |     |             mstore(0x80, p3)
  6005 |     |         }
  6006 |     |         _sendLogPayload(0x1c, 0x84);
  6007 |     |         assembly {
  6008 |     |             mstore(0x00, m0)
  6009 |     |             mstore(0x20, m1)
  6010 |     |             mstore(0x40, m2)
  6011 |     |             mstore(0x60, m3)
  6012 |     |             mstore(0x80, m4)
  6013 |     |         }
  6014 |     |     }
  6015 |     | 
  6016 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
  6017 |     |         bytes32 m0;
  6018 |     |         bytes32 m1;
  6019 |     |         bytes32 m2;
  6020 |     |         bytes32 m3;
  6021 |     |         bytes32 m4;
  6022 |     |         assembly {
  6023 |     |             m0 := mload(0x00)
  6024 |     |             m1 := mload(0x20)
  6025 |     |             m2 := mload(0x40)
  6026 |     |             m3 := mload(0x60)
  6027 |     |             m4 := mload(0x80)
  6028 |     |             // Selector of `log(bool,bool,bool,uint256)`.
  6029 |     |             mstore(0x00, 0x6d7045c1)
  6030 |     |             mstore(0x20, p0)
  6031 |     |             mstore(0x40, p1)
  6032 |     |             mstore(0x60, p2)
  6033 |     |             mstore(0x80, p3)
  6034 |     |         }
  6035 |     |         _sendLogPayload(0x1c, 0x84);
  6036 |     |         assembly {
  6037 |     |             mstore(0x00, m0)
  6038 |     |             mstore(0x20, m1)
  6039 |     |             mstore(0x40, m2)
  6040 |     |             mstore(0x60, m3)
  6041 |     |             mstore(0x80, m4)
  6042 |     |         }
  6043 |     |     }
  6044 |     | 
  6045 |     |     function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {
  6046 |     |         bytes32 m0;
  6047 |     |         bytes32 m1;
  6048 |     |         bytes32 m2;
  6049 |     |         bytes32 m3;
  6050 |     |         bytes32 m4;
  6051 |     |         bytes32 m5;
  6052 |     |         bytes32 m6;
  6053 |     |         assembly {
  6054 |     |             function writeString(pos, w) {
  6055 |     |                 let length := 0
  6056 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6057 |     |                 mstore(pos, length)
  6058 |     |                 let shift := sub(256, shl(3, length))
  6059 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6060 |     |             }
  6061 |     |             m0 := mload(0x00)
  6062 |     |             m1 := mload(0x20)
  6063 |     |             m2 := mload(0x40)
  6064 |     |             m3 := mload(0x60)
  6065 |     |             m4 := mload(0x80)
  6066 |     |             m5 := mload(0xa0)
  6067 |     |             m6 := mload(0xc0)
  6068 |     |             // Selector of `log(bool,bool,bool,string)`.
  6069 |     |             mstore(0x00, 0x2ae408d4)
  6070 |     |             mstore(0x20, p0)
  6071 |     |             mstore(0x40, p1)
  6072 |     |             mstore(0x60, p2)
  6073 |     |             mstore(0x80, 0x80)
  6074 |     |             writeString(0xa0, p3)
  6075 |     |         }
  6076 |     |         _sendLogPayload(0x1c, 0xc4);
  6077 |     |         assembly {
  6078 |     |             mstore(0x00, m0)
  6079 |     |             mstore(0x20, m1)
  6080 |     |             mstore(0x40, m2)
  6081 |     |             mstore(0x60, m3)
  6082 |     |             mstore(0x80, m4)
  6083 |     |             mstore(0xa0, m5)
  6084 |     |             mstore(0xc0, m6)
  6085 |     |         }
  6086 |     |     }
  6087 |     | 
  6088 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
  6089 |     |         bytes32 m0;
  6090 |     |         bytes32 m1;
  6091 |     |         bytes32 m2;
  6092 |     |         bytes32 m3;
  6093 |     |         bytes32 m4;
  6094 |     |         assembly {
  6095 |     |             m0 := mload(0x00)
  6096 |     |             m1 := mload(0x20)
  6097 |     |             m2 := mload(0x40)
  6098 |     |             m3 := mload(0x60)
  6099 |     |             m4 := mload(0x80)
  6100 |     |             // Selector of `log(bool,bool,uint256,address)`.
  6101 |     |             mstore(0x00, 0x54a7a9a0)
  6102 |     |             mstore(0x20, p0)
  6103 |     |             mstore(0x40, p1)
  6104 |     |             mstore(0x60, p2)
  6105 |     |             mstore(0x80, p3)
  6106 |     |         }
  6107 |     |         _sendLogPayload(0x1c, 0x84);
  6108 |     |         assembly {
  6109 |     |             mstore(0x00, m0)
  6110 |     |             mstore(0x20, m1)
  6111 |     |             mstore(0x40, m2)
  6112 |     |             mstore(0x60, m3)
  6113 |     |             mstore(0x80, m4)
  6114 |     |         }
  6115 |     |     }
  6116 |     | 
  6117 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
  6118 |     |         bytes32 m0;
  6119 |     |         bytes32 m1;
  6120 |     |         bytes32 m2;
  6121 |     |         bytes32 m3;
  6122 |     |         bytes32 m4;
  6123 |     |         assembly {
  6124 |     |             m0 := mload(0x00)
  6125 |     |             m1 := mload(0x20)
  6126 |     |             m2 := mload(0x40)
  6127 |     |             m3 := mload(0x60)
  6128 |     |             m4 := mload(0x80)
  6129 |     |             // Selector of `log(bool,bool,uint256,bool)`.
  6130 |     |             mstore(0x00, 0x619e4d0e)
  6131 |     |             mstore(0x20, p0)
  6132 |     |             mstore(0x40, p1)
  6133 |     |             mstore(0x60, p2)
  6134 |     |             mstore(0x80, p3)
  6135 |     |         }
  6136 |     |         _sendLogPayload(0x1c, 0x84);
  6137 |     |         assembly {
  6138 |     |             mstore(0x00, m0)
  6139 |     |             mstore(0x20, m1)
  6140 |     |             mstore(0x40, m2)
  6141 |     |             mstore(0x60, m3)
  6142 |     |             mstore(0x80, m4)
  6143 |     |         }
  6144 |     |     }
  6145 |     | 
  6146 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
  6147 |     |         bytes32 m0;
  6148 |     |         bytes32 m1;
  6149 |     |         bytes32 m2;
  6150 |     |         bytes32 m3;
  6151 |     |         bytes32 m4;
  6152 |     |         assembly {
  6153 |     |             m0 := mload(0x00)
  6154 |     |             m1 := mload(0x20)
  6155 |     |             m2 := mload(0x40)
  6156 |     |             m3 := mload(0x60)
  6157 |     |             m4 := mload(0x80)
  6158 |     |             // Selector of `log(bool,bool,uint256,uint256)`.
  6159 |     |             mstore(0x00, 0x0bb00eab)
  6160 |     |             mstore(0x20, p0)
  6161 |     |             mstore(0x40, p1)
  6162 |     |             mstore(0x60, p2)
  6163 |     |             mstore(0x80, p3)
  6164 |     |         }
  6165 |     |         _sendLogPayload(0x1c, 0x84);
  6166 |     |         assembly {
  6167 |     |             mstore(0x00, m0)
  6168 |     |             mstore(0x20, m1)
  6169 |     |             mstore(0x40, m2)
  6170 |     |             mstore(0x60, m3)
  6171 |     |             mstore(0x80, m4)
  6172 |     |         }
  6173 |     |     }
  6174 |     | 
  6175 |     |     function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  6176 |     |         bytes32 m0;
  6177 |     |         bytes32 m1;
  6178 |     |         bytes32 m2;
  6179 |     |         bytes32 m3;
  6180 |     |         bytes32 m4;
  6181 |     |         bytes32 m5;
  6182 |     |         bytes32 m6;
  6183 |     |         assembly {
  6184 |     |             function writeString(pos, w) {
  6185 |     |                 let length := 0
  6186 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6187 |     |                 mstore(pos, length)
  6188 |     |                 let shift := sub(256, shl(3, length))
  6189 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6190 |     |             }
  6191 |     |             m0 := mload(0x00)
  6192 |     |             m1 := mload(0x20)
  6193 |     |             m2 := mload(0x40)
  6194 |     |             m3 := mload(0x60)
  6195 |     |             m4 := mload(0x80)
  6196 |     |             m5 := mload(0xa0)
  6197 |     |             m6 := mload(0xc0)
  6198 |     |             // Selector of `log(bool,bool,uint256,string)`.
  6199 |     |             mstore(0x00, 0x7dd4d0e0)
  6200 |     |             mstore(0x20, p0)
  6201 |     |             mstore(0x40, p1)
  6202 |     |             mstore(0x60, p2)
  6203 |     |             mstore(0x80, 0x80)
  6204 |     |             writeString(0xa0, p3)
  6205 |     |         }
  6206 |     |         _sendLogPayload(0x1c, 0xc4);
  6207 |     |         assembly {
  6208 |     |             mstore(0x00, m0)
  6209 |     |             mstore(0x20, m1)
  6210 |     |             mstore(0x40, m2)
  6211 |     |             mstore(0x60, m3)
  6212 |     |             mstore(0x80, m4)
  6213 |     |             mstore(0xa0, m5)
  6214 |     |             mstore(0xc0, m6)
  6215 |     |         }
  6216 |     |     }
  6217 |     | 
  6218 |     |     function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {
  6219 |     |         bytes32 m0;
  6220 |     |         bytes32 m1;
  6221 |     |         bytes32 m2;
  6222 |     |         bytes32 m3;
  6223 |     |         bytes32 m4;
  6224 |     |         bytes32 m5;
  6225 |     |         bytes32 m6;
  6226 |     |         assembly {
  6227 |     |             function writeString(pos, w) {
  6228 |     |                 let length := 0
  6229 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6230 |     |                 mstore(pos, length)
  6231 |     |                 let shift := sub(256, shl(3, length))
  6232 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6233 |     |             }
  6234 |     |             m0 := mload(0x00)
  6235 |     |             m1 := mload(0x20)
  6236 |     |             m2 := mload(0x40)
  6237 |     |             m3 := mload(0x60)
  6238 |     |             m4 := mload(0x80)
  6239 |     |             m5 := mload(0xa0)
  6240 |     |             m6 := mload(0xc0)
  6241 |     |             // Selector of `log(bool,bool,string,address)`.
  6242 |     |             mstore(0x00, 0xf9ad2b89)
  6243 |     |             mstore(0x20, p0)
  6244 |     |             mstore(0x40, p1)
  6245 |     |             mstore(0x60, 0x80)
  6246 |     |             mstore(0x80, p3)
  6247 |     |             writeString(0xa0, p2)
  6248 |     |         }
  6249 |     |         _sendLogPayload(0x1c, 0xc4);
  6250 |     |         assembly {
  6251 |     |             mstore(0x00, m0)
  6252 |     |             mstore(0x20, m1)
  6253 |     |             mstore(0x40, m2)
  6254 |     |             mstore(0x60, m3)
  6255 |     |             mstore(0x80, m4)
  6256 |     |             mstore(0xa0, m5)
  6257 |     |             mstore(0xc0, m6)
  6258 |     |         }
  6259 |     |     }
  6260 |     | 
  6261 |     |     function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {
  6262 |     |         bytes32 m0;
  6263 |     |         bytes32 m1;
  6264 |     |         bytes32 m2;
  6265 |     |         bytes32 m3;
  6266 |     |         bytes32 m4;
  6267 |     |         bytes32 m5;
  6268 |     |         bytes32 m6;
  6269 |     |         assembly {
  6270 |     |             function writeString(pos, w) {
  6271 |     |                 let length := 0
  6272 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6273 |     |                 mstore(pos, length)
  6274 |     |                 let shift := sub(256, shl(3, length))
  6275 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6276 |     |             }
  6277 |     |             m0 := mload(0x00)
  6278 |     |             m1 := mload(0x20)
  6279 |     |             m2 := mload(0x40)
  6280 |     |             m3 := mload(0x60)
  6281 |     |             m4 := mload(0x80)
  6282 |     |             m5 := mload(0xa0)
  6283 |     |             m6 := mload(0xc0)
  6284 |     |             // Selector of `log(bool,bool,string,bool)`.
  6285 |     |             mstore(0x00, 0xb857163a)
  6286 |     |             mstore(0x20, p0)
  6287 |     |             mstore(0x40, p1)
  6288 |     |             mstore(0x60, 0x80)
  6289 |     |             mstore(0x80, p3)
  6290 |     |             writeString(0xa0, p2)
  6291 |     |         }
  6292 |     |         _sendLogPayload(0x1c, 0xc4);
  6293 |     |         assembly {
  6294 |     |             mstore(0x00, m0)
  6295 |     |             mstore(0x20, m1)
  6296 |     |             mstore(0x40, m2)
  6297 |     |             mstore(0x60, m3)
  6298 |     |             mstore(0x80, m4)
  6299 |     |             mstore(0xa0, m5)
  6300 |     |             mstore(0xc0, m6)
  6301 |     |         }
  6302 |     |     }
  6303 |     | 
  6304 |     |     function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  6305 |     |         bytes32 m0;
  6306 |     |         bytes32 m1;
  6307 |     |         bytes32 m2;
  6308 |     |         bytes32 m3;
  6309 |     |         bytes32 m4;
  6310 |     |         bytes32 m5;
  6311 |     |         bytes32 m6;
  6312 |     |         assembly {
  6313 |     |             function writeString(pos, w) {
  6314 |     |                 let length := 0
  6315 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6316 |     |                 mstore(pos, length)
  6317 |     |                 let shift := sub(256, shl(3, length))
  6318 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6319 |     |             }
  6320 |     |             m0 := mload(0x00)
  6321 |     |             m1 := mload(0x20)
  6322 |     |             m2 := mload(0x40)
  6323 |     |             m3 := mload(0x60)
  6324 |     |             m4 := mload(0x80)
  6325 |     |             m5 := mload(0xa0)
  6326 |     |             m6 := mload(0xc0)
  6327 |     |             // Selector of `log(bool,bool,string,uint256)`.
  6328 |     |             mstore(0x00, 0xe3a9ca2f)
  6329 |     |             mstore(0x20, p0)
  6330 |     |             mstore(0x40, p1)
  6331 |     |             mstore(0x60, 0x80)
  6332 |     |             mstore(0x80, p3)
  6333 |     |             writeString(0xa0, p2)
  6334 |     |         }
  6335 |     |         _sendLogPayload(0x1c, 0xc4);
  6336 |     |         assembly {
  6337 |     |             mstore(0x00, m0)
  6338 |     |             mstore(0x20, m1)
  6339 |     |             mstore(0x40, m2)
  6340 |     |             mstore(0x60, m3)
  6341 |     |             mstore(0x80, m4)
  6342 |     |             mstore(0xa0, m5)
  6343 |     |             mstore(0xc0, m6)
  6344 |     |         }
  6345 |     |     }
  6346 |     | 
  6347 |     |     function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  6348 |     |         bytes32 m0;
  6349 |     |         bytes32 m1;
  6350 |     |         bytes32 m2;
  6351 |     |         bytes32 m3;
  6352 |     |         bytes32 m4;
  6353 |     |         bytes32 m5;
  6354 |     |         bytes32 m6;
  6355 |     |         bytes32 m7;
  6356 |     |         bytes32 m8;
  6357 |     |         assembly {
  6358 |     |             function writeString(pos, w) {
  6359 |     |                 let length := 0
  6360 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6361 |     |                 mstore(pos, length)
  6362 |     |                 let shift := sub(256, shl(3, length))
  6363 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6364 |     |             }
  6365 |     |             m0 := mload(0x00)
  6366 |     |             m1 := mload(0x20)
  6367 |     |             m2 := mload(0x40)
  6368 |     |             m3 := mload(0x60)
  6369 |     |             m4 := mload(0x80)
  6370 |     |             m5 := mload(0xa0)
  6371 |     |             m6 := mload(0xc0)
  6372 |     |             m7 := mload(0xe0)
  6373 |     |             m8 := mload(0x100)
  6374 |     |             // Selector of `log(bool,bool,string,string)`.
  6375 |     |             mstore(0x00, 0x6d1e8751)
  6376 |     |             mstore(0x20, p0)
  6377 |     |             mstore(0x40, p1)
  6378 |     |             mstore(0x60, 0x80)
  6379 |     |             mstore(0x80, 0xc0)
  6380 |     |             writeString(0xa0, p2)
  6381 |     |             writeString(0xe0, p3)
  6382 |     |         }
  6383 |     |         _sendLogPayload(0x1c, 0x104);
  6384 |     |         assembly {
  6385 |     |             mstore(0x00, m0)
  6386 |     |             mstore(0x20, m1)
  6387 |     |             mstore(0x40, m2)
  6388 |     |             mstore(0x60, m3)
  6389 |     |             mstore(0x80, m4)
  6390 |     |             mstore(0xa0, m5)
  6391 |     |             mstore(0xc0, m6)
  6392 |     |             mstore(0xe0, m7)
  6393 |     |             mstore(0x100, m8)
  6394 |     |         }
  6395 |     |     }
  6396 |     | 
  6397 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
  6398 |     |         bytes32 m0;
  6399 |     |         bytes32 m1;
  6400 |     |         bytes32 m2;
  6401 |     |         bytes32 m3;
  6402 |     |         bytes32 m4;
  6403 |     |         assembly {
  6404 |     |             m0 := mload(0x00)
  6405 |     |             m1 := mload(0x20)
  6406 |     |             m2 := mload(0x40)
  6407 |     |             m3 := mload(0x60)
  6408 |     |             m4 := mload(0x80)
  6409 |     |             // Selector of `log(bool,uint256,address,address)`.
  6410 |     |             mstore(0x00, 0x26f560a8)
  6411 |     |             mstore(0x20, p0)
  6412 |     |             mstore(0x40, p1)
  6413 |     |             mstore(0x60, p2)
  6414 |     |             mstore(0x80, p3)
  6415 |     |         }
  6416 |     |         _sendLogPayload(0x1c, 0x84);
  6417 |     |         assembly {
  6418 |     |             mstore(0x00, m0)
  6419 |     |             mstore(0x20, m1)
  6420 |     |             mstore(0x40, m2)
  6421 |     |             mstore(0x60, m3)
  6422 |     |             mstore(0x80, m4)
  6423 |     |         }
  6424 |     |     }
  6425 |     | 
  6426 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
  6427 |     |         bytes32 m0;
  6428 |     |         bytes32 m1;
  6429 |     |         bytes32 m2;
  6430 |     |         bytes32 m3;
  6431 |     |         bytes32 m4;
  6432 |     |         assembly {
  6433 |     |             m0 := mload(0x00)
  6434 |     |             m1 := mload(0x20)
  6435 |     |             m2 := mload(0x40)
  6436 |     |             m3 := mload(0x60)
  6437 |     |             m4 := mload(0x80)
  6438 |     |             // Selector of `log(bool,uint256,address,bool)`.
  6439 |     |             mstore(0x00, 0xb4c314ff)
  6440 |     |             mstore(0x20, p0)
  6441 |     |             mstore(0x40, p1)
  6442 |     |             mstore(0x60, p2)
  6443 |     |             mstore(0x80, p3)
  6444 |     |         }
  6445 |     |         _sendLogPayload(0x1c, 0x84);
  6446 |     |         assembly {
  6447 |     |             mstore(0x00, m0)
  6448 |     |             mstore(0x20, m1)
  6449 |     |             mstore(0x40, m2)
  6450 |     |             mstore(0x60, m3)
  6451 |     |             mstore(0x80, m4)
  6452 |     |         }
  6453 |     |     }
  6454 |     | 
  6455 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
  6456 |     |         bytes32 m0;
  6457 |     |         bytes32 m1;
  6458 |     |         bytes32 m2;
  6459 |     |         bytes32 m3;
  6460 |     |         bytes32 m4;
  6461 |     |         assembly {
  6462 |     |             m0 := mload(0x00)
  6463 |     |             m1 := mload(0x20)
  6464 |     |             m2 := mload(0x40)
  6465 |     |             m3 := mload(0x60)
  6466 |     |             m4 := mload(0x80)
  6467 |     |             // Selector of `log(bool,uint256,address,uint256)`.
  6468 |     |             mstore(0x00, 0x1537dc87)
  6469 |     |             mstore(0x20, p0)
  6470 |     |             mstore(0x40, p1)
  6471 |     |             mstore(0x60, p2)
  6472 |     |             mstore(0x80, p3)
  6473 |     |         }
  6474 |     |         _sendLogPayload(0x1c, 0x84);
  6475 |     |         assembly {
  6476 |     |             mstore(0x00, m0)
  6477 |     |             mstore(0x20, m1)
  6478 |     |             mstore(0x40, m2)
  6479 |     |             mstore(0x60, m3)
  6480 |     |             mstore(0x80, m4)
  6481 |     |         }
  6482 |     |     }
  6483 |     | 
  6484 |     |     function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {
  6485 |     |         bytes32 m0;
  6486 |     |         bytes32 m1;
  6487 |     |         bytes32 m2;
  6488 |     |         bytes32 m3;
  6489 |     |         bytes32 m4;
  6490 |     |         bytes32 m5;
  6491 |     |         bytes32 m6;
  6492 |     |         assembly {
  6493 |     |             function writeString(pos, w) {
  6494 |     |                 let length := 0
  6495 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6496 |     |                 mstore(pos, length)
  6497 |     |                 let shift := sub(256, shl(3, length))
  6498 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6499 |     |             }
  6500 |     |             m0 := mload(0x00)
  6501 |     |             m1 := mload(0x20)
  6502 |     |             m2 := mload(0x40)
  6503 |     |             m3 := mload(0x60)
  6504 |     |             m4 := mload(0x80)
  6505 |     |             m5 := mload(0xa0)
  6506 |     |             m6 := mload(0xc0)
  6507 |     |             // Selector of `log(bool,uint256,address,string)`.
  6508 |     |             mstore(0x00, 0x1bb3b09a)
  6509 |     |             mstore(0x20, p0)
  6510 |     |             mstore(0x40, p1)
  6511 |     |             mstore(0x60, p2)
  6512 |     |             mstore(0x80, 0x80)
  6513 |     |             writeString(0xa0, p3)
  6514 |     |         }
  6515 |     |         _sendLogPayload(0x1c, 0xc4);
  6516 |     |         assembly {
  6517 |     |             mstore(0x00, m0)
  6518 |     |             mstore(0x20, m1)
  6519 |     |             mstore(0x40, m2)
  6520 |     |             mstore(0x60, m3)
  6521 |     |             mstore(0x80, m4)
  6522 |     |             mstore(0xa0, m5)
  6523 |     |             mstore(0xc0, m6)
  6524 |     |         }
  6525 |     |     }
  6526 |     | 
  6527 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
  6528 |     |         bytes32 m0;
  6529 |     |         bytes32 m1;
  6530 |     |         bytes32 m2;
  6531 |     |         bytes32 m3;
  6532 |     |         bytes32 m4;
  6533 |     |         assembly {
  6534 |     |             m0 := mload(0x00)
  6535 |     |             m1 := mload(0x20)
  6536 |     |             m2 := mload(0x40)
  6537 |     |             m3 := mload(0x60)
  6538 |     |             m4 := mload(0x80)
  6539 |     |             // Selector of `log(bool,uint256,bool,address)`.
  6540 |     |             mstore(0x00, 0x9acd3616)
  6541 |     |             mstore(0x20, p0)
  6542 |     |             mstore(0x40, p1)
  6543 |     |             mstore(0x60, p2)
  6544 |     |             mstore(0x80, p3)
  6545 |     |         }
  6546 |     |         _sendLogPayload(0x1c, 0x84);
  6547 |     |         assembly {
  6548 |     |             mstore(0x00, m0)
  6549 |     |             mstore(0x20, m1)
  6550 |     |             mstore(0x40, m2)
  6551 |     |             mstore(0x60, m3)
  6552 |     |             mstore(0x80, m4)
  6553 |     |         }
  6554 |     |     }
  6555 |     | 
  6556 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
  6557 |     |         bytes32 m0;
  6558 |     |         bytes32 m1;
  6559 |     |         bytes32 m2;
  6560 |     |         bytes32 m3;
  6561 |     |         bytes32 m4;
  6562 |     |         assembly {
  6563 |     |             m0 := mload(0x00)
  6564 |     |             m1 := mload(0x20)
  6565 |     |             m2 := mload(0x40)
  6566 |     |             m3 := mload(0x60)
  6567 |     |             m4 := mload(0x80)
  6568 |     |             // Selector of `log(bool,uint256,bool,bool)`.
  6569 |     |             mstore(0x00, 0xceb5f4d7)
  6570 |     |             mstore(0x20, p0)
  6571 |     |             mstore(0x40, p1)
  6572 |     |             mstore(0x60, p2)
  6573 |     |             mstore(0x80, p3)
  6574 |     |         }
  6575 |     |         _sendLogPayload(0x1c, 0x84);
  6576 |     |         assembly {
  6577 |     |             mstore(0x00, m0)
  6578 |     |             mstore(0x20, m1)
  6579 |     |             mstore(0x40, m2)
  6580 |     |             mstore(0x60, m3)
  6581 |     |             mstore(0x80, m4)
  6582 |     |         }
  6583 |     |     }
  6584 |     | 
  6585 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
  6586 |     |         bytes32 m0;
  6587 |     |         bytes32 m1;
  6588 |     |         bytes32 m2;
  6589 |     |         bytes32 m3;
  6590 |     |         bytes32 m4;
  6591 |     |         assembly {
  6592 |     |             m0 := mload(0x00)
  6593 |     |             m1 := mload(0x20)
  6594 |     |             m2 := mload(0x40)
  6595 |     |             m3 := mload(0x60)
  6596 |     |             m4 := mload(0x80)
  6597 |     |             // Selector of `log(bool,uint256,bool,uint256)`.
  6598 |     |             mstore(0x00, 0x7f9bbca2)
  6599 |     |             mstore(0x20, p0)
  6600 |     |             mstore(0x40, p1)
  6601 |     |             mstore(0x60, p2)
  6602 |     |             mstore(0x80, p3)
  6603 |     |         }
  6604 |     |         _sendLogPayload(0x1c, 0x84);
  6605 |     |         assembly {
  6606 |     |             mstore(0x00, m0)
  6607 |     |             mstore(0x20, m1)
  6608 |     |             mstore(0x40, m2)
  6609 |     |             mstore(0x60, m3)
  6610 |     |             mstore(0x80, m4)
  6611 |     |         }
  6612 |     |     }
  6613 |     | 
  6614 |     |     function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  6615 |     |         bytes32 m0;
  6616 |     |         bytes32 m1;
  6617 |     |         bytes32 m2;
  6618 |     |         bytes32 m3;
  6619 |     |         bytes32 m4;
  6620 |     |         bytes32 m5;
  6621 |     |         bytes32 m6;
  6622 |     |         assembly {
  6623 |     |             function writeString(pos, w) {
  6624 |     |                 let length := 0
  6625 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6626 |     |                 mstore(pos, length)
  6627 |     |                 let shift := sub(256, shl(3, length))
  6628 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6629 |     |             }
  6630 |     |             m0 := mload(0x00)
  6631 |     |             m1 := mload(0x20)
  6632 |     |             m2 := mload(0x40)
  6633 |     |             m3 := mload(0x60)
  6634 |     |             m4 := mload(0x80)
  6635 |     |             m5 := mload(0xa0)
  6636 |     |             m6 := mload(0xc0)
  6637 |     |             // Selector of `log(bool,uint256,bool,string)`.
  6638 |     |             mstore(0x00, 0x9143dbb1)
  6639 |     |             mstore(0x20, p0)
  6640 |     |             mstore(0x40, p1)
  6641 |     |             mstore(0x60, p2)
  6642 |     |             mstore(0x80, 0x80)
  6643 |     |             writeString(0xa0, p3)
  6644 |     |         }
  6645 |     |         _sendLogPayload(0x1c, 0xc4);
  6646 |     |         assembly {
  6647 |     |             mstore(0x00, m0)
  6648 |     |             mstore(0x20, m1)
  6649 |     |             mstore(0x40, m2)
  6650 |     |             mstore(0x60, m3)
  6651 |     |             mstore(0x80, m4)
  6652 |     |             mstore(0xa0, m5)
  6653 |     |             mstore(0xc0, m6)
  6654 |     |         }
  6655 |     |     }
  6656 |     | 
  6657 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
  6658 |     |         bytes32 m0;
  6659 |     |         bytes32 m1;
  6660 |     |         bytes32 m2;
  6661 |     |         bytes32 m3;
  6662 |     |         bytes32 m4;
  6663 |     |         assembly {
  6664 |     |             m0 := mload(0x00)
  6665 |     |             m1 := mload(0x20)
  6666 |     |             m2 := mload(0x40)
  6667 |     |             m3 := mload(0x60)
  6668 |     |             m4 := mload(0x80)
  6669 |     |             // Selector of `log(bool,uint256,uint256,address)`.
  6670 |     |             mstore(0x00, 0x00dd87b9)
  6671 |     |             mstore(0x20, p0)
  6672 |     |             mstore(0x40, p1)
  6673 |     |             mstore(0x60, p2)
  6674 |     |             mstore(0x80, p3)
  6675 |     |         }
  6676 |     |         _sendLogPayload(0x1c, 0x84);
  6677 |     |         assembly {
  6678 |     |             mstore(0x00, m0)
  6679 |     |             mstore(0x20, m1)
  6680 |     |             mstore(0x40, m2)
  6681 |     |             mstore(0x60, m3)
  6682 |     |             mstore(0x80, m4)
  6683 |     |         }
  6684 |     |     }
  6685 |     | 
  6686 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
  6687 |     |         bytes32 m0;
  6688 |     |         bytes32 m1;
  6689 |     |         bytes32 m2;
  6690 |     |         bytes32 m3;
  6691 |     |         bytes32 m4;
  6692 |     |         assembly {
  6693 |     |             m0 := mload(0x00)
  6694 |     |             m1 := mload(0x20)
  6695 |     |             m2 := mload(0x40)
  6696 |     |             m3 := mload(0x60)
  6697 |     |             m4 := mload(0x80)
  6698 |     |             // Selector of `log(bool,uint256,uint256,bool)`.
  6699 |     |             mstore(0x00, 0xbe984353)
  6700 |     |             mstore(0x20, p0)
  6701 |     |             mstore(0x40, p1)
  6702 |     |             mstore(0x60, p2)
  6703 |     |             mstore(0x80, p3)
  6704 |     |         }
  6705 |     |         _sendLogPayload(0x1c, 0x84);
  6706 |     |         assembly {
  6707 |     |             mstore(0x00, m0)
  6708 |     |             mstore(0x20, m1)
  6709 |     |             mstore(0x40, m2)
  6710 |     |             mstore(0x60, m3)
  6711 |     |             mstore(0x80, m4)
  6712 |     |         }
  6713 |     |     }
  6714 |     | 
  6715 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  6716 |     |         bytes32 m0;
  6717 |     |         bytes32 m1;
  6718 |     |         bytes32 m2;
  6719 |     |         bytes32 m3;
  6720 |     |         bytes32 m4;
  6721 |     |         assembly {
  6722 |     |             m0 := mload(0x00)
  6723 |     |             m1 := mload(0x20)
  6724 |     |             m2 := mload(0x40)
  6725 |     |             m3 := mload(0x60)
  6726 |     |             m4 := mload(0x80)
  6727 |     |             // Selector of `log(bool,uint256,uint256,uint256)`.
  6728 |     |             mstore(0x00, 0x374bb4b2)
  6729 |     |             mstore(0x20, p0)
  6730 |     |             mstore(0x40, p1)
  6731 |     |             mstore(0x60, p2)
  6732 |     |             mstore(0x80, p3)
  6733 |     |         }
  6734 |     |         _sendLogPayload(0x1c, 0x84);
  6735 |     |         assembly {
  6736 |     |             mstore(0x00, m0)
  6737 |     |             mstore(0x20, m1)
  6738 |     |             mstore(0x40, m2)
  6739 |     |             mstore(0x60, m3)
  6740 |     |             mstore(0x80, m4)
  6741 |     |         }
  6742 |     |     }
  6743 |     | 
  6744 |     |     function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  6745 |     |         bytes32 m0;
  6746 |     |         bytes32 m1;
  6747 |     |         bytes32 m2;
  6748 |     |         bytes32 m3;
  6749 |     |         bytes32 m4;
  6750 |     |         bytes32 m5;
  6751 |     |         bytes32 m6;
  6752 |     |         assembly {
  6753 |     |             function writeString(pos, w) {
  6754 |     |                 let length := 0
  6755 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6756 |     |                 mstore(pos, length)
  6757 |     |                 let shift := sub(256, shl(3, length))
  6758 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6759 |     |             }
  6760 |     |             m0 := mload(0x00)
  6761 |     |             m1 := mload(0x20)
  6762 |     |             m2 := mload(0x40)
  6763 |     |             m3 := mload(0x60)
  6764 |     |             m4 := mload(0x80)
  6765 |     |             m5 := mload(0xa0)
  6766 |     |             m6 := mload(0xc0)
  6767 |     |             // Selector of `log(bool,uint256,uint256,string)`.
  6768 |     |             mstore(0x00, 0x8e69fb5d)
  6769 |     |             mstore(0x20, p0)
  6770 |     |             mstore(0x40, p1)
  6771 |     |             mstore(0x60, p2)
  6772 |     |             mstore(0x80, 0x80)
  6773 |     |             writeString(0xa0, p3)
  6774 |     |         }
  6775 |     |         _sendLogPayload(0x1c, 0xc4);
  6776 |     |         assembly {
  6777 |     |             mstore(0x00, m0)
  6778 |     |             mstore(0x20, m1)
  6779 |     |             mstore(0x40, m2)
  6780 |     |             mstore(0x60, m3)
  6781 |     |             mstore(0x80, m4)
  6782 |     |             mstore(0xa0, m5)
  6783 |     |             mstore(0xc0, m6)
  6784 |     |         }
  6785 |     |     }
  6786 |     | 
  6787 |     |     function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {
  6788 |     |         bytes32 m0;
  6789 |     |         bytes32 m1;
  6790 |     |         bytes32 m2;
  6791 |     |         bytes32 m3;
  6792 |     |         bytes32 m4;
  6793 |     |         bytes32 m5;
  6794 |     |         bytes32 m6;
  6795 |     |         assembly {
  6796 |     |             function writeString(pos, w) {
  6797 |     |                 let length := 0
  6798 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6799 |     |                 mstore(pos, length)
  6800 |     |                 let shift := sub(256, shl(3, length))
  6801 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6802 |     |             }
  6803 |     |             m0 := mload(0x00)
  6804 |     |             m1 := mload(0x20)
  6805 |     |             m2 := mload(0x40)
  6806 |     |             m3 := mload(0x60)
  6807 |     |             m4 := mload(0x80)
  6808 |     |             m5 := mload(0xa0)
  6809 |     |             m6 := mload(0xc0)
  6810 |     |             // Selector of `log(bool,uint256,string,address)`.
  6811 |     |             mstore(0x00, 0xfedd1fff)
  6812 |     |             mstore(0x20, p0)
  6813 |     |             mstore(0x40, p1)
  6814 |     |             mstore(0x60, 0x80)
  6815 |     |             mstore(0x80, p3)
  6816 |     |             writeString(0xa0, p2)
  6817 |     |         }
  6818 |     |         _sendLogPayload(0x1c, 0xc4);
  6819 |     |         assembly {
  6820 |     |             mstore(0x00, m0)
  6821 |     |             mstore(0x20, m1)
  6822 |     |             mstore(0x40, m2)
  6823 |     |             mstore(0x60, m3)
  6824 |     |             mstore(0x80, m4)
  6825 |     |             mstore(0xa0, m5)
  6826 |     |             mstore(0xc0, m6)
  6827 |     |         }
  6828 |     |     }
  6829 |     | 
  6830 |     |     function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  6831 |     |         bytes32 m0;
  6832 |     |         bytes32 m1;
  6833 |     |         bytes32 m2;
  6834 |     |         bytes32 m3;
  6835 |     |         bytes32 m4;
  6836 |     |         bytes32 m5;
  6837 |     |         bytes32 m6;
  6838 |     |         assembly {
  6839 |     |             function writeString(pos, w) {
  6840 |     |                 let length := 0
  6841 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6842 |     |                 mstore(pos, length)
  6843 |     |                 let shift := sub(256, shl(3, length))
  6844 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6845 |     |             }
  6846 |     |             m0 := mload(0x00)
  6847 |     |             m1 := mload(0x20)
  6848 |     |             m2 := mload(0x40)
  6849 |     |             m3 := mload(0x60)
  6850 |     |             m4 := mload(0x80)
  6851 |     |             m5 := mload(0xa0)
  6852 |     |             m6 := mload(0xc0)
  6853 |     |             // Selector of `log(bool,uint256,string,bool)`.
  6854 |     |             mstore(0x00, 0xe5e70b2b)
  6855 |     |             mstore(0x20, p0)
  6856 |     |             mstore(0x40, p1)
  6857 |     |             mstore(0x60, 0x80)
  6858 |     |             mstore(0x80, p3)
  6859 |     |             writeString(0xa0, p2)
  6860 |     |         }
  6861 |     |         _sendLogPayload(0x1c, 0xc4);
  6862 |     |         assembly {
  6863 |     |             mstore(0x00, m0)
  6864 |     |             mstore(0x20, m1)
  6865 |     |             mstore(0x40, m2)
  6866 |     |             mstore(0x60, m3)
  6867 |     |             mstore(0x80, m4)
  6868 |     |             mstore(0xa0, m5)
  6869 |     |             mstore(0xc0, m6)
  6870 |     |         }
  6871 |     |     }
  6872 |     | 
  6873 |     |     function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  6874 |     |         bytes32 m0;
  6875 |     |         bytes32 m1;
  6876 |     |         bytes32 m2;
  6877 |     |         bytes32 m3;
  6878 |     |         bytes32 m4;
  6879 |     |         bytes32 m5;
  6880 |     |         bytes32 m6;
  6881 |     |         assembly {
  6882 |     |             function writeString(pos, w) {
  6883 |     |                 let length := 0
  6884 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6885 |     |                 mstore(pos, length)
  6886 |     |                 let shift := sub(256, shl(3, length))
  6887 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6888 |     |             }
  6889 |     |             m0 := mload(0x00)
  6890 |     |             m1 := mload(0x20)
  6891 |     |             m2 := mload(0x40)
  6892 |     |             m3 := mload(0x60)
  6893 |     |             m4 := mload(0x80)
  6894 |     |             m5 := mload(0xa0)
  6895 |     |             m6 := mload(0xc0)
  6896 |     |             // Selector of `log(bool,uint256,string,uint256)`.
  6897 |     |             mstore(0x00, 0x6a1199e2)
  6898 |     |             mstore(0x20, p0)
  6899 |     |             mstore(0x40, p1)
  6900 |     |             mstore(0x60, 0x80)
  6901 |     |             mstore(0x80, p3)
  6902 |     |             writeString(0xa0, p2)
  6903 |     |         }
  6904 |     |         _sendLogPayload(0x1c, 0xc4);
  6905 |     |         assembly {
  6906 |     |             mstore(0x00, m0)
  6907 |     |             mstore(0x20, m1)
  6908 |     |             mstore(0x40, m2)
  6909 |     |             mstore(0x60, m3)
  6910 |     |             mstore(0x80, m4)
  6911 |     |             mstore(0xa0, m5)
  6912 |     |             mstore(0xc0, m6)
  6913 |     |         }
  6914 |     |     }
  6915 |     | 
  6916 |     |     function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  6917 |     |         bytes32 m0;
  6918 |     |         bytes32 m1;
  6919 |     |         bytes32 m2;
  6920 |     |         bytes32 m3;
  6921 |     |         bytes32 m4;
  6922 |     |         bytes32 m5;
  6923 |     |         bytes32 m6;
  6924 |     |         bytes32 m7;
  6925 |     |         bytes32 m8;
  6926 |     |         assembly {
  6927 |     |             function writeString(pos, w) {
  6928 |     |                 let length := 0
  6929 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6930 |     |                 mstore(pos, length)
  6931 |     |                 let shift := sub(256, shl(3, length))
  6932 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6933 |     |             }
  6934 |     |             m0 := mload(0x00)
  6935 |     |             m1 := mload(0x20)
  6936 |     |             m2 := mload(0x40)
  6937 |     |             m3 := mload(0x60)
  6938 |     |             m4 := mload(0x80)
  6939 |     |             m5 := mload(0xa0)
  6940 |     |             m6 := mload(0xc0)
  6941 |     |             m7 := mload(0xe0)
  6942 |     |             m8 := mload(0x100)
  6943 |     |             // Selector of `log(bool,uint256,string,string)`.
  6944 |     |             mstore(0x00, 0xf5bc2249)
  6945 |     |             mstore(0x20, p0)
  6946 |     |             mstore(0x40, p1)
  6947 |     |             mstore(0x60, 0x80)
  6948 |     |             mstore(0x80, 0xc0)
  6949 |     |             writeString(0xa0, p2)
  6950 |     |             writeString(0xe0, p3)
  6951 |     |         }
  6952 |     |         _sendLogPayload(0x1c, 0x104);
  6953 |     |         assembly {
  6954 |     |             mstore(0x00, m0)
  6955 |     |             mstore(0x20, m1)
  6956 |     |             mstore(0x40, m2)
  6957 |     |             mstore(0x60, m3)
  6958 |     |             mstore(0x80, m4)
  6959 |     |             mstore(0xa0, m5)
  6960 |     |             mstore(0xc0, m6)
  6961 |     |             mstore(0xe0, m7)
  6962 |     |             mstore(0x100, m8)
  6963 |     |         }
  6964 |     |     }
  6965 |     | 
  6966 |     |     function log(bool p0, bytes32 p1, address p2, address p3) internal pure {
  6967 |     |         bytes32 m0;
  6968 |     |         bytes32 m1;
  6969 |     |         bytes32 m2;
  6970 |     |         bytes32 m3;
  6971 |     |         bytes32 m4;
  6972 |     |         bytes32 m5;
  6973 |     |         bytes32 m6;
  6974 |     |         assembly {
  6975 |     |             function writeString(pos, w) {
  6976 |     |                 let length := 0
  6977 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6978 |     |                 mstore(pos, length)
  6979 |     |                 let shift := sub(256, shl(3, length))
  6980 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6981 |     |             }
  6982 |     |             m0 := mload(0x00)
  6983 |     |             m1 := mload(0x20)
  6984 |     |             m2 := mload(0x40)
  6985 |     |             m3 := mload(0x60)
  6986 |     |             m4 := mload(0x80)
  6987 |     |             m5 := mload(0xa0)
  6988 |     |             m6 := mload(0xc0)
  6989 |     |             // Selector of `log(bool,string,address,address)`.
  6990 |     |             mstore(0x00, 0x2b2b18dc)
  6991 |     |             mstore(0x20, p0)
  6992 |     |             mstore(0x40, 0x80)
  6993 |     |             mstore(0x60, p2)
  6994 |     |             mstore(0x80, p3)
  6995 |     |             writeString(0xa0, p1)
  6996 |     |         }
  6997 |     |         _sendLogPayload(0x1c, 0xc4);
  6998 |     |         assembly {
  6999 |     |             mstore(0x00, m0)
  7000 |     |             mstore(0x20, m1)
  7001 |     |             mstore(0x40, m2)
  7002 |     |             mstore(0x60, m3)
  7003 |     |             mstore(0x80, m4)
  7004 |     |             mstore(0xa0, m5)
  7005 |     |             mstore(0xc0, m6)
  7006 |     |         }
  7007 |     |     }
  7008 |     | 
  7009 |     |     function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {
  7010 |     |         bytes32 m0;
  7011 |     |         bytes32 m1;
  7012 |     |         bytes32 m2;
  7013 |     |         bytes32 m3;
  7014 |     |         bytes32 m4;
  7015 |     |         bytes32 m5;
  7016 |     |         bytes32 m6;
  7017 |     |         assembly {
  7018 |     |             function writeString(pos, w) {
  7019 |     |                 let length := 0
  7020 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7021 |     |                 mstore(pos, length)
  7022 |     |                 let shift := sub(256, shl(3, length))
  7023 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7024 |     |             }
  7025 |     |             m0 := mload(0x00)
  7026 |     |             m1 := mload(0x20)
  7027 |     |             m2 := mload(0x40)
  7028 |     |             m3 := mload(0x60)
  7029 |     |             m4 := mload(0x80)
  7030 |     |             m5 := mload(0xa0)
  7031 |     |             m6 := mload(0xc0)
  7032 |     |             // Selector of `log(bool,string,address,bool)`.
  7033 |     |             mstore(0x00, 0x6dd434ca)
  7034 |     |             mstore(0x20, p0)
  7035 |     |             mstore(0x40, 0x80)
  7036 |     |             mstore(0x60, p2)
  7037 |     |             mstore(0x80, p3)
  7038 |     |             writeString(0xa0, p1)
  7039 |     |         }
  7040 |     |         _sendLogPayload(0x1c, 0xc4);
  7041 |     |         assembly {
  7042 |     |             mstore(0x00, m0)
  7043 |     |             mstore(0x20, m1)
  7044 |     |             mstore(0x40, m2)
  7045 |     |             mstore(0x60, m3)
  7046 |     |             mstore(0x80, m4)
  7047 |     |             mstore(0xa0, m5)
  7048 |     |             mstore(0xc0, m6)
  7049 |     |         }
  7050 |     |     }
  7051 |     | 
  7052 |     |     function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {
  7053 |     |         bytes32 m0;
  7054 |     |         bytes32 m1;
  7055 |     |         bytes32 m2;
  7056 |     |         bytes32 m3;
  7057 |     |         bytes32 m4;
  7058 |     |         bytes32 m5;
  7059 |     |         bytes32 m6;
  7060 |     |         assembly {
  7061 |     |             function writeString(pos, w) {
  7062 |     |                 let length := 0
  7063 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7064 |     |                 mstore(pos, length)
  7065 |     |                 let shift := sub(256, shl(3, length))
  7066 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7067 |     |             }
  7068 |     |             m0 := mload(0x00)
  7069 |     |             m1 := mload(0x20)
  7070 |     |             m2 := mload(0x40)
  7071 |     |             m3 := mload(0x60)
  7072 |     |             m4 := mload(0x80)
  7073 |     |             m5 := mload(0xa0)
  7074 |     |             m6 := mload(0xc0)
  7075 |     |             // Selector of `log(bool,string,address,uint256)`.
  7076 |     |             mstore(0x00, 0xa5cada94)
  7077 |     |             mstore(0x20, p0)
  7078 |     |             mstore(0x40, 0x80)
  7079 |     |             mstore(0x60, p2)
  7080 |     |             mstore(0x80, p3)
  7081 |     |             writeString(0xa0, p1)
  7082 |     |         }
  7083 |     |         _sendLogPayload(0x1c, 0xc4);
  7084 |     |         assembly {
  7085 |     |             mstore(0x00, m0)
  7086 |     |             mstore(0x20, m1)
  7087 |     |             mstore(0x40, m2)
  7088 |     |             mstore(0x60, m3)
  7089 |     |             mstore(0x80, m4)
  7090 |     |             mstore(0xa0, m5)
  7091 |     |             mstore(0xc0, m6)
  7092 |     |         }
  7093 |     |     }
  7094 |     | 
  7095 |     |     function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  7096 |     |         bytes32 m0;
  7097 |     |         bytes32 m1;
  7098 |     |         bytes32 m2;
  7099 |     |         bytes32 m3;
  7100 |     |         bytes32 m4;
  7101 |     |         bytes32 m5;
  7102 |     |         bytes32 m6;
  7103 |     |         bytes32 m7;
  7104 |     |         bytes32 m8;
  7105 |     |         assembly {
  7106 |     |             function writeString(pos, w) {
  7107 |     |                 let length := 0
  7108 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7109 |     |                 mstore(pos, length)
  7110 |     |                 let shift := sub(256, shl(3, length))
  7111 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7112 |     |             }
  7113 |     |             m0 := mload(0x00)
  7114 |     |             m1 := mload(0x20)
  7115 |     |             m2 := mload(0x40)
  7116 |     |             m3 := mload(0x60)
  7117 |     |             m4 := mload(0x80)
  7118 |     |             m5 := mload(0xa0)
  7119 |     |             m6 := mload(0xc0)
  7120 |     |             m7 := mload(0xe0)
  7121 |     |             m8 := mload(0x100)
  7122 |     |             // Selector of `log(bool,string,address,string)`.
  7123 |     |             mstore(0x00, 0x12d6c788)
  7124 |     |             mstore(0x20, p0)
  7125 |     |             mstore(0x40, 0x80)
  7126 |     |             mstore(0x60, p2)
  7127 |     |             mstore(0x80, 0xc0)
  7128 |     |             writeString(0xa0, p1)
  7129 |     |             writeString(0xe0, p3)
  7130 |     |         }
  7131 |     |         _sendLogPayload(0x1c, 0x104);
  7132 |     |         assembly {
  7133 |     |             mstore(0x00, m0)
  7134 |     |             mstore(0x20, m1)
  7135 |     |             mstore(0x40, m2)
  7136 |     |             mstore(0x60, m3)
  7137 |     |             mstore(0x80, m4)
  7138 |     |             mstore(0xa0, m5)
  7139 |     |             mstore(0xc0, m6)
  7140 |     |             mstore(0xe0, m7)
  7141 |     |             mstore(0x100, m8)
  7142 |     |         }
  7143 |     |     }
  7144 |     | 
  7145 |     |     function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {
  7146 |     |         bytes32 m0;
  7147 |     |         bytes32 m1;
  7148 |     |         bytes32 m2;
  7149 |     |         bytes32 m3;
  7150 |     |         bytes32 m4;
  7151 |     |         bytes32 m5;
  7152 |     |         bytes32 m6;
  7153 |     |         assembly {
  7154 |     |             function writeString(pos, w) {
  7155 |     |                 let length := 0
  7156 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7157 |     |                 mstore(pos, length)
  7158 |     |                 let shift := sub(256, shl(3, length))
  7159 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7160 |     |             }
  7161 |     |             m0 := mload(0x00)
  7162 |     |             m1 := mload(0x20)
  7163 |     |             m2 := mload(0x40)
  7164 |     |             m3 := mload(0x60)
  7165 |     |             m4 := mload(0x80)
  7166 |     |             m5 := mload(0xa0)
  7167 |     |             m6 := mload(0xc0)
  7168 |     |             // Selector of `log(bool,string,bool,address)`.
  7169 |     |             mstore(0x00, 0x538e06ab)
  7170 |     |             mstore(0x20, p0)
  7171 |     |             mstore(0x40, 0x80)
  7172 |     |             mstore(0x60, p2)
  7173 |     |             mstore(0x80, p3)
  7174 |     |             writeString(0xa0, p1)
  7175 |     |         }
  7176 |     |         _sendLogPayload(0x1c, 0xc4);
  7177 |     |         assembly {
  7178 |     |             mstore(0x00, m0)
  7179 |     |             mstore(0x20, m1)
  7180 |     |             mstore(0x40, m2)
  7181 |     |             mstore(0x60, m3)
  7182 |     |             mstore(0x80, m4)
  7183 |     |             mstore(0xa0, m5)
  7184 |     |             mstore(0xc0, m6)
  7185 |     |         }
  7186 |     |     }
  7187 |     | 
  7188 |     |     function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {
  7189 |     |         bytes32 m0;
  7190 |     |         bytes32 m1;
  7191 |     |         bytes32 m2;
  7192 |     |         bytes32 m3;
  7193 |     |         bytes32 m4;
  7194 |     |         bytes32 m5;
  7195 |     |         bytes32 m6;
  7196 |     |         assembly {
  7197 |     |             function writeString(pos, w) {
  7198 |     |                 let length := 0
  7199 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7200 |     |                 mstore(pos, length)
  7201 |     |                 let shift := sub(256, shl(3, length))
  7202 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7203 |     |             }
  7204 |     |             m0 := mload(0x00)
  7205 |     |             m1 := mload(0x20)
  7206 |     |             m2 := mload(0x40)
  7207 |     |             m3 := mload(0x60)
  7208 |     |             m4 := mload(0x80)
  7209 |     |             m5 := mload(0xa0)
  7210 |     |             m6 := mload(0xc0)
  7211 |     |             // Selector of `log(bool,string,bool,bool)`.
  7212 |     |             mstore(0x00, 0xdc5e935b)
  7213 |     |             mstore(0x20, p0)
  7214 |     |             mstore(0x40, 0x80)
  7215 |     |             mstore(0x60, p2)
  7216 |     |             mstore(0x80, p3)
  7217 |     |             writeString(0xa0, p1)
  7218 |     |         }
  7219 |     |         _sendLogPayload(0x1c, 0xc4);
  7220 |     |         assembly {
  7221 |     |             mstore(0x00, m0)
  7222 |     |             mstore(0x20, m1)
  7223 |     |             mstore(0x40, m2)
  7224 |     |             mstore(0x60, m3)
  7225 |     |             mstore(0x80, m4)
  7226 |     |             mstore(0xa0, m5)
  7227 |     |             mstore(0xc0, m6)
  7228 |     |         }
  7229 |     |     }
  7230 |     | 
  7231 |     |     function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  7232 |     |         bytes32 m0;
  7233 |     |         bytes32 m1;
  7234 |     |         bytes32 m2;
  7235 |     |         bytes32 m3;
  7236 |     |         bytes32 m4;
  7237 |     |         bytes32 m5;
  7238 |     |         bytes32 m6;
  7239 |     |         assembly {
  7240 |     |             function writeString(pos, w) {
  7241 |     |                 let length := 0
  7242 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7243 |     |                 mstore(pos, length)
  7244 |     |                 let shift := sub(256, shl(3, length))
  7245 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7246 |     |             }
  7247 |     |             m0 := mload(0x00)
  7248 |     |             m1 := mload(0x20)
  7249 |     |             m2 := mload(0x40)
  7250 |     |             m3 := mload(0x60)
  7251 |     |             m4 := mload(0x80)
  7252 |     |             m5 := mload(0xa0)
  7253 |     |             m6 := mload(0xc0)
  7254 |     |             // Selector of `log(bool,string,bool,uint256)`.
  7255 |     |             mstore(0x00, 0x1606a393)
  7256 |     |             mstore(0x20, p0)
  7257 |     |             mstore(0x40, 0x80)
  7258 |     |             mstore(0x60, p2)
  7259 |     |             mstore(0x80, p3)
  7260 |     |             writeString(0xa0, p1)
  7261 |     |         }
  7262 |     |         _sendLogPayload(0x1c, 0xc4);
  7263 |     |         assembly {
  7264 |     |             mstore(0x00, m0)
  7265 |     |             mstore(0x20, m1)
  7266 |     |             mstore(0x40, m2)
  7267 |     |             mstore(0x60, m3)
  7268 |     |             mstore(0x80, m4)
  7269 |     |             mstore(0xa0, m5)
  7270 |     |             mstore(0xc0, m6)
  7271 |     |         }
  7272 |     |     }
  7273 |     | 
  7274 |     |     function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  7275 |     |         bytes32 m0;
  7276 |     |         bytes32 m1;
  7277 |     |         bytes32 m2;
  7278 |     |         bytes32 m3;
  7279 |     |         bytes32 m4;
  7280 |     |         bytes32 m5;
  7281 |     |         bytes32 m6;
  7282 |     |         bytes32 m7;
  7283 |     |         bytes32 m8;
  7284 |     |         assembly {
  7285 |     |             function writeString(pos, w) {
  7286 |     |                 let length := 0
  7287 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7288 |     |                 mstore(pos, length)
  7289 |     |                 let shift := sub(256, shl(3, length))
  7290 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7291 |     |             }
  7292 |     |             m0 := mload(0x00)
  7293 |     |             m1 := mload(0x20)
  7294 |     |             m2 := mload(0x40)
  7295 |     |             m3 := mload(0x60)
  7296 |     |             m4 := mload(0x80)
  7297 |     |             m5 := mload(0xa0)
  7298 |     |             m6 := mload(0xc0)
  7299 |     |             m7 := mload(0xe0)
  7300 |     |             m8 := mload(0x100)
  7301 |     |             // Selector of `log(bool,string,bool,string)`.
  7302 |     |             mstore(0x00, 0x483d0416)
  7303 |     |             mstore(0x20, p0)
  7304 |     |             mstore(0x40, 0x80)
  7305 |     |             mstore(0x60, p2)
  7306 |     |             mstore(0x80, 0xc0)
  7307 |     |             writeString(0xa0, p1)
  7308 |     |             writeString(0xe0, p3)
  7309 |     |         }
  7310 |     |         _sendLogPayload(0x1c, 0x104);
  7311 |     |         assembly {
  7312 |     |             mstore(0x00, m0)
  7313 |     |             mstore(0x20, m1)
  7314 |     |             mstore(0x40, m2)
  7315 |     |             mstore(0x60, m3)
  7316 |     |             mstore(0x80, m4)
  7317 |     |             mstore(0xa0, m5)
  7318 |     |             mstore(0xc0, m6)
  7319 |     |             mstore(0xe0, m7)
  7320 |     |             mstore(0x100, m8)
  7321 |     |         }
  7322 |     |     }
  7323 |     | 
  7324 |     |     function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {
  7325 |     |         bytes32 m0;
  7326 |     |         bytes32 m1;
  7327 |     |         bytes32 m2;
  7328 |     |         bytes32 m3;
  7329 |     |         bytes32 m4;
  7330 |     |         bytes32 m5;
  7331 |     |         bytes32 m6;
  7332 |     |         assembly {
  7333 |     |             function writeString(pos, w) {
  7334 |     |                 let length := 0
  7335 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7336 |     |                 mstore(pos, length)
  7337 |     |                 let shift := sub(256, shl(3, length))
  7338 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7339 |     |             }
  7340 |     |             m0 := mload(0x00)
  7341 |     |             m1 := mload(0x20)
  7342 |     |             m2 := mload(0x40)
  7343 |     |             m3 := mload(0x60)
  7344 |     |             m4 := mload(0x80)
  7345 |     |             m5 := mload(0xa0)
  7346 |     |             m6 := mload(0xc0)
  7347 |     |             // Selector of `log(bool,string,uint256,address)`.
  7348 |     |             mstore(0x00, 0x1596a1ce)
  7349 |     |             mstore(0x20, p0)
  7350 |     |             mstore(0x40, 0x80)
  7351 |     |             mstore(0x60, p2)
  7352 |     |             mstore(0x80, p3)
  7353 |     |             writeString(0xa0, p1)
  7354 |     |         }
  7355 |     |         _sendLogPayload(0x1c, 0xc4);
  7356 |     |         assembly {
  7357 |     |             mstore(0x00, m0)
  7358 |     |             mstore(0x20, m1)
  7359 |     |             mstore(0x40, m2)
  7360 |     |             mstore(0x60, m3)
  7361 |     |             mstore(0x80, m4)
  7362 |     |             mstore(0xa0, m5)
  7363 |     |             mstore(0xc0, m6)
  7364 |     |         }
  7365 |     |     }
  7366 |     | 
  7367 |     |     function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  7368 |     |         bytes32 m0;
  7369 |     |         bytes32 m1;
  7370 |     |         bytes32 m2;
  7371 |     |         bytes32 m3;
  7372 |     |         bytes32 m4;
  7373 |     |         bytes32 m5;
  7374 |     |         bytes32 m6;
  7375 |     |         assembly {
  7376 |     |             function writeString(pos, w) {
  7377 |     |                 let length := 0
  7378 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7379 |     |                 mstore(pos, length)
  7380 |     |                 let shift := sub(256, shl(3, length))
  7381 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7382 |     |             }
  7383 |     |             m0 := mload(0x00)
  7384 |     |             m1 := mload(0x20)
  7385 |     |             m2 := mload(0x40)
  7386 |     |             m3 := mload(0x60)
  7387 |     |             m4 := mload(0x80)
  7388 |     |             m5 := mload(0xa0)
  7389 |     |             m6 := mload(0xc0)
  7390 |     |             // Selector of `log(bool,string,uint256,bool)`.
  7391 |     |             mstore(0x00, 0x6b0e5d53)
  7392 |     |             mstore(0x20, p0)
  7393 |     |             mstore(0x40, 0x80)
  7394 |     |             mstore(0x60, p2)
  7395 |     |             mstore(0x80, p3)
  7396 |     |             writeString(0xa0, p1)
  7397 |     |         }
  7398 |     |         _sendLogPayload(0x1c, 0xc4);
  7399 |     |         assembly {
  7400 |     |             mstore(0x00, m0)
  7401 |     |             mstore(0x20, m1)
  7402 |     |             mstore(0x40, m2)
  7403 |     |             mstore(0x60, m3)
  7404 |     |             mstore(0x80, m4)
  7405 |     |             mstore(0xa0, m5)
  7406 |     |             mstore(0xc0, m6)
  7407 |     |         }
  7408 |     |     }
  7409 |     | 
  7410 |     |     function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  7411 |     |         bytes32 m0;
  7412 |     |         bytes32 m1;
  7413 |     |         bytes32 m2;
  7414 |     |         bytes32 m3;
  7415 |     |         bytes32 m4;
  7416 |     |         bytes32 m5;
  7417 |     |         bytes32 m6;
  7418 |     |         assembly {
  7419 |     |             function writeString(pos, w) {
  7420 |     |                 let length := 0
  7421 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7422 |     |                 mstore(pos, length)
  7423 |     |                 let shift := sub(256, shl(3, length))
  7424 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7425 |     |             }
  7426 |     |             m0 := mload(0x00)
  7427 |     |             m1 := mload(0x20)
  7428 |     |             m2 := mload(0x40)
  7429 |     |             m3 := mload(0x60)
  7430 |     |             m4 := mload(0x80)
  7431 |     |             m5 := mload(0xa0)
  7432 |     |             m6 := mload(0xc0)
  7433 |     |             // Selector of `log(bool,string,uint256,uint256)`.
  7434 |     |             mstore(0x00, 0x28863fcb)
  7435 |     |             mstore(0x20, p0)
  7436 |     |             mstore(0x40, 0x80)
  7437 |     |             mstore(0x60, p2)
  7438 |     |             mstore(0x80, p3)
  7439 |     |             writeString(0xa0, p1)
  7440 |     |         }
  7441 |     |         _sendLogPayload(0x1c, 0xc4);
  7442 |     |         assembly {
  7443 |     |             mstore(0x00, m0)
  7444 |     |             mstore(0x20, m1)
  7445 |     |             mstore(0x40, m2)
  7446 |     |             mstore(0x60, m3)
  7447 |     |             mstore(0x80, m4)
  7448 |     |             mstore(0xa0, m5)
  7449 |     |             mstore(0xc0, m6)
  7450 |     |         }
  7451 |     |     }
  7452 |     | 
  7453 |     |     function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  7454 |     |         bytes32 m0;
  7455 |     |         bytes32 m1;
  7456 |     |         bytes32 m2;
  7457 |     |         bytes32 m3;
  7458 |     |         bytes32 m4;
  7459 |     |         bytes32 m5;
  7460 |     |         bytes32 m6;
  7461 |     |         bytes32 m7;
  7462 |     |         bytes32 m8;
  7463 |     |         assembly {
  7464 |     |             function writeString(pos, w) {
  7465 |     |                 let length := 0
  7466 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7467 |     |                 mstore(pos, length)
  7468 |     |                 let shift := sub(256, shl(3, length))
  7469 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7470 |     |             }
  7471 |     |             m0 := mload(0x00)
  7472 |     |             m1 := mload(0x20)
  7473 |     |             m2 := mload(0x40)
  7474 |     |             m3 := mload(0x60)
  7475 |     |             m4 := mload(0x80)
  7476 |     |             m5 := mload(0xa0)
  7477 |     |             m6 := mload(0xc0)
  7478 |     |             m7 := mload(0xe0)
  7479 |     |             m8 := mload(0x100)
  7480 |     |             // Selector of `log(bool,string,uint256,string)`.
  7481 |     |             mstore(0x00, 0x1ad96de6)
  7482 |     |             mstore(0x20, p0)
  7483 |     |             mstore(0x40, 0x80)
  7484 |     |             mstore(0x60, p2)
  7485 |     |             mstore(0x80, 0xc0)
  7486 |     |             writeString(0xa0, p1)
  7487 |     |             writeString(0xe0, p3)
  7488 |     |         }
  7489 |     |         _sendLogPayload(0x1c, 0x104);
  7490 |     |         assembly {
  7491 |     |             mstore(0x00, m0)
  7492 |     |             mstore(0x20, m1)
  7493 |     |             mstore(0x40, m2)
  7494 |     |             mstore(0x60, m3)
  7495 |     |             mstore(0x80, m4)
  7496 |     |             mstore(0xa0, m5)
  7497 |     |             mstore(0xc0, m6)
  7498 |     |             mstore(0xe0, m7)
  7499 |     |             mstore(0x100, m8)
  7500 |     |         }
  7501 |     |     }
  7502 |     | 
  7503 |     |     function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  7504 |     |         bytes32 m0;
  7505 |     |         bytes32 m1;
  7506 |     |         bytes32 m2;
  7507 |     |         bytes32 m3;
  7508 |     |         bytes32 m4;
  7509 |     |         bytes32 m5;
  7510 |     |         bytes32 m6;
  7511 |     |         bytes32 m7;
  7512 |     |         bytes32 m8;
  7513 |     |         assembly {
  7514 |     |             function writeString(pos, w) {
  7515 |     |                 let length := 0
  7516 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7517 |     |                 mstore(pos, length)
  7518 |     |                 let shift := sub(256, shl(3, length))
  7519 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7520 |     |             }
  7521 |     |             m0 := mload(0x00)
  7522 |     |             m1 := mload(0x20)
  7523 |     |             m2 := mload(0x40)
  7524 |     |             m3 := mload(0x60)
  7525 |     |             m4 := mload(0x80)
  7526 |     |             m5 := mload(0xa0)
  7527 |     |             m6 := mload(0xc0)
  7528 |     |             m7 := mload(0xe0)
  7529 |     |             m8 := mload(0x100)
  7530 |     |             // Selector of `log(bool,string,string,address)`.
  7531 |     |             mstore(0x00, 0x97d394d8)
  7532 |     |             mstore(0x20, p0)
  7533 |     |             mstore(0x40, 0x80)
  7534 |     |             mstore(0x60, 0xc0)
  7535 |     |             mstore(0x80, p3)
  7536 |     |             writeString(0xa0, p1)
  7537 |     |             writeString(0xe0, p2)
  7538 |     |         }
  7539 |     |         _sendLogPayload(0x1c, 0x104);
  7540 |     |         assembly {
  7541 |     |             mstore(0x00, m0)
  7542 |     |             mstore(0x20, m1)
  7543 |     |             mstore(0x40, m2)
  7544 |     |             mstore(0x60, m3)
  7545 |     |             mstore(0x80, m4)
  7546 |     |             mstore(0xa0, m5)
  7547 |     |             mstore(0xc0, m6)
  7548 |     |             mstore(0xe0, m7)
  7549 |     |             mstore(0x100, m8)
  7550 |     |         }
  7551 |     |     }
  7552 |     | 
  7553 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  7554 |     |         bytes32 m0;
  7555 |     |         bytes32 m1;
  7556 |     |         bytes32 m2;
  7557 |     |         bytes32 m3;
  7558 |     |         bytes32 m4;
  7559 |     |         bytes32 m5;
  7560 |     |         bytes32 m6;
  7561 |     |         bytes32 m7;
  7562 |     |         bytes32 m8;
  7563 |     |         assembly {
  7564 |     |             function writeString(pos, w) {
  7565 |     |                 let length := 0
  7566 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7567 |     |                 mstore(pos, length)
  7568 |     |                 let shift := sub(256, shl(3, length))
  7569 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7570 |     |             }
  7571 |     |             m0 := mload(0x00)
  7572 |     |             m1 := mload(0x20)
  7573 |     |             m2 := mload(0x40)
  7574 |     |             m3 := mload(0x60)
  7575 |     |             m4 := mload(0x80)
  7576 |     |             m5 := mload(0xa0)
  7577 |     |             m6 := mload(0xc0)
  7578 |     |             m7 := mload(0xe0)
  7579 |     |             m8 := mload(0x100)
  7580 |     |             // Selector of `log(bool,string,string,bool)`.
  7581 |     |             mstore(0x00, 0x1e4b87e5)
  7582 |     |             mstore(0x20, p0)
  7583 |     |             mstore(0x40, 0x80)
  7584 |     |             mstore(0x60, 0xc0)
  7585 |     |             mstore(0x80, p3)
  7586 |     |             writeString(0xa0, p1)
  7587 |     |             writeString(0xe0, p2)
  7588 |     |         }
  7589 |     |         _sendLogPayload(0x1c, 0x104);
  7590 |     |         assembly {
  7591 |     |             mstore(0x00, m0)
  7592 |     |             mstore(0x20, m1)
  7593 |     |             mstore(0x40, m2)
  7594 |     |             mstore(0x60, m3)
  7595 |     |             mstore(0x80, m4)
  7596 |     |             mstore(0xa0, m5)
  7597 |     |             mstore(0xc0, m6)
  7598 |     |             mstore(0xe0, m7)
  7599 |     |             mstore(0x100, m8)
  7600 |     |         }
  7601 |     |     }
  7602 |     | 
  7603 |     |     function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  7604 |     |         bytes32 m0;
  7605 |     |         bytes32 m1;
  7606 |     |         bytes32 m2;
  7607 |     |         bytes32 m3;
  7608 |     |         bytes32 m4;
  7609 |     |         bytes32 m5;
  7610 |     |         bytes32 m6;
  7611 |     |         bytes32 m7;
  7612 |     |         bytes32 m8;
  7613 |     |         assembly {
  7614 |     |             function writeString(pos, w) {
  7615 |     |                 let length := 0
  7616 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7617 |     |                 mstore(pos, length)
  7618 |     |                 let shift := sub(256, shl(3, length))
  7619 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7620 |     |             }
  7621 |     |             m0 := mload(0x00)
  7622 |     |             m1 := mload(0x20)
  7623 |     |             m2 := mload(0x40)
  7624 |     |             m3 := mload(0x60)
  7625 |     |             m4 := mload(0x80)
  7626 |     |             m5 := mload(0xa0)
  7627 |     |             m6 := mload(0xc0)
  7628 |     |             m7 := mload(0xe0)
  7629 |     |             m8 := mload(0x100)
  7630 |     |             // Selector of `log(bool,string,string,uint256)`.
  7631 |     |             mstore(0x00, 0x7be0c3eb)
  7632 |     |             mstore(0x20, p0)
  7633 |     |             mstore(0x40, 0x80)
  7634 |     |             mstore(0x60, 0xc0)
  7635 |     |             mstore(0x80, p3)
  7636 |     |             writeString(0xa0, p1)
  7637 |     |             writeString(0xe0, p2)
  7638 |     |         }
  7639 |     |         _sendLogPayload(0x1c, 0x104);
  7640 |     |         assembly {
  7641 |     |             mstore(0x00, m0)
  7642 |     |             mstore(0x20, m1)
  7643 |     |             mstore(0x40, m2)
  7644 |     |             mstore(0x60, m3)
  7645 |     |             mstore(0x80, m4)
  7646 |     |             mstore(0xa0, m5)
  7647 |     |             mstore(0xc0, m6)
  7648 |     |             mstore(0xe0, m7)
  7649 |     |             mstore(0x100, m8)
  7650 |     |         }
  7651 |     |     }
  7652 |     | 
  7653 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  7654 |     |         bytes32 m0;
  7655 |     |         bytes32 m1;
  7656 |     |         bytes32 m2;
  7657 |     |         bytes32 m3;
  7658 |     |         bytes32 m4;
  7659 |     |         bytes32 m5;
  7660 |     |         bytes32 m6;
  7661 |     |         bytes32 m7;
  7662 |     |         bytes32 m8;
  7663 |     |         bytes32 m9;
  7664 |     |         bytes32 m10;
  7665 |     |         assembly {
  7666 |     |             function writeString(pos, w) {
  7667 |     |                 let length := 0
  7668 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7669 |     |                 mstore(pos, length)
  7670 |     |                 let shift := sub(256, shl(3, length))
  7671 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7672 |     |             }
  7673 |     |             m0 := mload(0x00)
  7674 |     |             m1 := mload(0x20)
  7675 |     |             m2 := mload(0x40)
  7676 |     |             m3 := mload(0x60)
  7677 |     |             m4 := mload(0x80)
  7678 |     |             m5 := mload(0xa0)
  7679 |     |             m6 := mload(0xc0)
  7680 |     |             m7 := mload(0xe0)
  7681 |     |             m8 := mload(0x100)
  7682 |     |             m9 := mload(0x120)
  7683 |     |             m10 := mload(0x140)
  7684 |     |             // Selector of `log(bool,string,string,string)`.
  7685 |     |             mstore(0x00, 0x1762e32a)
  7686 |     |             mstore(0x20, p0)
  7687 |     |             mstore(0x40, 0x80)
  7688 |     |             mstore(0x60, 0xc0)
  7689 |     |             mstore(0x80, 0x100)
  7690 |     |             writeString(0xa0, p1)
  7691 |     |             writeString(0xe0, p2)
  7692 |     |             writeString(0x120, p3)
  7693 |     |         }
  7694 |     |         _sendLogPayload(0x1c, 0x144);
  7695 |     |         assembly {
  7696 |     |             mstore(0x00, m0)
  7697 |     |             mstore(0x20, m1)
  7698 |     |             mstore(0x40, m2)
  7699 |     |             mstore(0x60, m3)
  7700 |     |             mstore(0x80, m4)
  7701 |     |             mstore(0xa0, m5)
  7702 |     |             mstore(0xc0, m6)
  7703 |     |             mstore(0xe0, m7)
  7704 |     |             mstore(0x100, m8)
  7705 |     |             mstore(0x120, m9)
  7706 |     |             mstore(0x140, m10)
  7707 |     |         }
  7708 |     |     }
  7709 |     | 
  7710 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  7711 |     |         bytes32 m0;
  7712 |     |         bytes32 m1;
  7713 |     |         bytes32 m2;
  7714 |     |         bytes32 m3;
  7715 |     |         bytes32 m4;
  7716 |     |         assembly {
  7717 |     |             m0 := mload(0x00)
  7718 |     |             m1 := mload(0x20)
  7719 |     |             m2 := mload(0x40)
  7720 |     |             m3 := mload(0x60)
  7721 |     |             m4 := mload(0x80)
  7722 |     |             // Selector of `log(uint256,address,address,address)`.
  7723 |     |             mstore(0x00, 0x2488b414)
  7724 |     |             mstore(0x20, p0)
  7725 |     |             mstore(0x40, p1)
  7726 |     |             mstore(0x60, p2)
  7727 |     |             mstore(0x80, p3)
  7728 |     |         }
  7729 |     |         _sendLogPayload(0x1c, 0x84);
  7730 |     |         assembly {
  7731 |     |             mstore(0x00, m0)
  7732 |     |             mstore(0x20, m1)
  7733 |     |             mstore(0x40, m2)
  7734 |     |             mstore(0x60, m3)
  7735 |     |             mstore(0x80, m4)
  7736 |     |         }
  7737 |     |     }
  7738 |     | 
  7739 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  7740 |     |         bytes32 m0;
  7741 |     |         bytes32 m1;
  7742 |     |         bytes32 m2;
  7743 |     |         bytes32 m3;
  7744 |     |         bytes32 m4;
  7745 |     |         assembly {
  7746 |     |             m0 := mload(0x00)
  7747 |     |             m1 := mload(0x20)
  7748 |     |             m2 := mload(0x40)
  7749 |     |             m3 := mload(0x60)
  7750 |     |             m4 := mload(0x80)
  7751 |     |             // Selector of `log(uint256,address,address,bool)`.
  7752 |     |             mstore(0x00, 0x091ffaf5)
  7753 |     |             mstore(0x20, p0)
  7754 |     |             mstore(0x40, p1)
  7755 |     |             mstore(0x60, p2)
  7756 |     |             mstore(0x80, p3)
  7757 |     |         }
  7758 |     |         _sendLogPayload(0x1c, 0x84);
  7759 |     |         assembly {
  7760 |     |             mstore(0x00, m0)
  7761 |     |             mstore(0x20, m1)
  7762 |     |             mstore(0x40, m2)
  7763 |     |             mstore(0x60, m3)
  7764 |     |             mstore(0x80, m4)
  7765 |     |         }
  7766 |     |     }
  7767 |     | 
  7768 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  7769 |     |         bytes32 m0;
  7770 |     |         bytes32 m1;
  7771 |     |         bytes32 m2;
  7772 |     |         bytes32 m3;
  7773 |     |         bytes32 m4;
  7774 |     |         assembly {
  7775 |     |             m0 := mload(0x00)
  7776 |     |             m1 := mload(0x20)
  7777 |     |             m2 := mload(0x40)
  7778 |     |             m3 := mload(0x60)
  7779 |     |             m4 := mload(0x80)
  7780 |     |             // Selector of `log(uint256,address,address,uint256)`.
  7781 |     |             mstore(0x00, 0x736efbb6)
  7782 |     |             mstore(0x20, p0)
  7783 |     |             mstore(0x40, p1)
  7784 |     |             mstore(0x60, p2)
  7785 |     |             mstore(0x80, p3)
  7786 |     |         }
  7787 |     |         _sendLogPayload(0x1c, 0x84);
  7788 |     |         assembly {
  7789 |     |             mstore(0x00, m0)
  7790 |     |             mstore(0x20, m1)
  7791 |     |             mstore(0x40, m2)
  7792 |     |             mstore(0x60, m3)
  7793 |     |             mstore(0x80, m4)
  7794 |     |         }
  7795 |     |     }
  7796 |     | 
  7797 |     |     function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {
  7798 |     |         bytes32 m0;
  7799 |     |         bytes32 m1;
  7800 |     |         bytes32 m2;
  7801 |     |         bytes32 m3;
  7802 |     |         bytes32 m4;
  7803 |     |         bytes32 m5;
  7804 |     |         bytes32 m6;
  7805 |     |         assembly {
  7806 |     |             function writeString(pos, w) {
  7807 |     |                 let length := 0
  7808 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7809 |     |                 mstore(pos, length)
  7810 |     |                 let shift := sub(256, shl(3, length))
  7811 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7812 |     |             }
  7813 |     |             m0 := mload(0x00)
  7814 |     |             m1 := mload(0x20)
  7815 |     |             m2 := mload(0x40)
  7816 |     |             m3 := mload(0x60)
  7817 |     |             m4 := mload(0x80)
  7818 |     |             m5 := mload(0xa0)
  7819 |     |             m6 := mload(0xc0)
  7820 |     |             // Selector of `log(uint256,address,address,string)`.
  7821 |     |             mstore(0x00, 0x031c6f73)
  7822 |     |             mstore(0x20, p0)
  7823 |     |             mstore(0x40, p1)
  7824 |     |             mstore(0x60, p2)
  7825 |     |             mstore(0x80, 0x80)
  7826 |     |             writeString(0xa0, p3)
  7827 |     |         }
  7828 |     |         _sendLogPayload(0x1c, 0xc4);
  7829 |     |         assembly {
  7830 |     |             mstore(0x00, m0)
  7831 |     |             mstore(0x20, m1)
  7832 |     |             mstore(0x40, m2)
  7833 |     |             mstore(0x60, m3)
  7834 |     |             mstore(0x80, m4)
  7835 |     |             mstore(0xa0, m5)
  7836 |     |             mstore(0xc0, m6)
  7837 |     |         }
  7838 |     |     }
  7839 |     | 
  7840 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  7841 |     |         bytes32 m0;
  7842 |     |         bytes32 m1;
  7843 |     |         bytes32 m2;
  7844 |     |         bytes32 m3;
  7845 |     |         bytes32 m4;
  7846 |     |         assembly {
  7847 |     |             m0 := mload(0x00)
  7848 |     |             m1 := mload(0x20)
  7849 |     |             m2 := mload(0x40)
  7850 |     |             m3 := mload(0x60)
  7851 |     |             m4 := mload(0x80)
  7852 |     |             // Selector of `log(uint256,address,bool,address)`.
  7853 |     |             mstore(0x00, 0xef72c513)
  7854 |     |             mstore(0x20, p0)
  7855 |     |             mstore(0x40, p1)
  7856 |     |             mstore(0x60, p2)
  7857 |     |             mstore(0x80, p3)
  7858 |     |         }
  7859 |     |         _sendLogPayload(0x1c, 0x84);
  7860 |     |         assembly {
  7861 |     |             mstore(0x00, m0)
  7862 |     |             mstore(0x20, m1)
  7863 |     |             mstore(0x40, m2)
  7864 |     |             mstore(0x60, m3)
  7865 |     |             mstore(0x80, m4)
  7866 |     |         }
  7867 |     |     }
  7868 |     | 
  7869 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  7870 |     |         bytes32 m0;
  7871 |     |         bytes32 m1;
  7872 |     |         bytes32 m2;
  7873 |     |         bytes32 m3;
  7874 |     |         bytes32 m4;
  7875 |     |         assembly {
  7876 |     |             m0 := mload(0x00)
  7877 |     |             m1 := mload(0x20)
  7878 |     |             m2 := mload(0x40)
  7879 |     |             m3 := mload(0x60)
  7880 |     |             m4 := mload(0x80)
  7881 |     |             // Selector of `log(uint256,address,bool,bool)`.
  7882 |     |             mstore(0x00, 0xe351140f)
  7883 |     |             mstore(0x20, p0)
  7884 |     |             mstore(0x40, p1)
  7885 |     |             mstore(0x60, p2)
  7886 |     |             mstore(0x80, p3)
  7887 |     |         }
  7888 |     |         _sendLogPayload(0x1c, 0x84);
  7889 |     |         assembly {
  7890 |     |             mstore(0x00, m0)
  7891 |     |             mstore(0x20, m1)
  7892 |     |             mstore(0x40, m2)
  7893 |     |             mstore(0x60, m3)
  7894 |     |             mstore(0x80, m4)
  7895 |     |         }
  7896 |     |     }
  7897 |     | 
  7898 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  7899 |     |         bytes32 m0;
  7900 |     |         bytes32 m1;
  7901 |     |         bytes32 m2;
  7902 |     |         bytes32 m3;
  7903 |     |         bytes32 m4;
  7904 |     |         assembly {
  7905 |     |             m0 := mload(0x00)
  7906 |     |             m1 := mload(0x20)
  7907 |     |             m2 := mload(0x40)
  7908 |     |             m3 := mload(0x60)
  7909 |     |             m4 := mload(0x80)
  7910 |     |             // Selector of `log(uint256,address,bool,uint256)`.
  7911 |     |             mstore(0x00, 0x5abd992a)
  7912 |     |             mstore(0x20, p0)
  7913 |     |             mstore(0x40, p1)
  7914 |     |             mstore(0x60, p2)
  7915 |     |             mstore(0x80, p3)
  7916 |     |         }
  7917 |     |         _sendLogPayload(0x1c, 0x84);
  7918 |     |         assembly {
  7919 |     |             mstore(0x00, m0)
  7920 |     |             mstore(0x20, m1)
  7921 |     |             mstore(0x40, m2)
  7922 |     |             mstore(0x60, m3)
  7923 |     |             mstore(0x80, m4)
  7924 |     |         }
  7925 |     |     }
  7926 |     | 
  7927 |     |     function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {
  7928 |     |         bytes32 m0;
  7929 |     |         bytes32 m1;
  7930 |     |         bytes32 m2;
  7931 |     |         bytes32 m3;
  7932 |     |         bytes32 m4;
  7933 |     |         bytes32 m5;
  7934 |     |         bytes32 m6;
  7935 |     |         assembly {
  7936 |     |             function writeString(pos, w) {
  7937 |     |                 let length := 0
  7938 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7939 |     |                 mstore(pos, length)
  7940 |     |                 let shift := sub(256, shl(3, length))
  7941 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7942 |     |             }
  7943 |     |             m0 := mload(0x00)
  7944 |     |             m1 := mload(0x20)
  7945 |     |             m2 := mload(0x40)
  7946 |     |             m3 := mload(0x60)
  7947 |     |             m4 := mload(0x80)
  7948 |     |             m5 := mload(0xa0)
  7949 |     |             m6 := mload(0xc0)
  7950 |     |             // Selector of `log(uint256,address,bool,string)`.
  7951 |     |             mstore(0x00, 0x90fb06aa)
  7952 |     |             mstore(0x20, p0)
  7953 |     |             mstore(0x40, p1)
  7954 |     |             mstore(0x60, p2)
  7955 |     |             mstore(0x80, 0x80)
  7956 |     |             writeString(0xa0, p3)
  7957 |     |         }
  7958 |     |         _sendLogPayload(0x1c, 0xc4);
  7959 |     |         assembly {
  7960 |     |             mstore(0x00, m0)
  7961 |     |             mstore(0x20, m1)
  7962 |     |             mstore(0x40, m2)
  7963 |     |             mstore(0x60, m3)
  7964 |     |             mstore(0x80, m4)
  7965 |     |             mstore(0xa0, m5)
  7966 |     |             mstore(0xc0, m6)
  7967 |     |         }
  7968 |     |     }
  7969 |     | 
  7970 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  7971 |     |         bytes32 m0;
  7972 |     |         bytes32 m1;
  7973 |     |         bytes32 m2;
  7974 |     |         bytes32 m3;
  7975 |     |         bytes32 m4;
  7976 |     |         assembly {
  7977 |     |             m0 := mload(0x00)
  7978 |     |             m1 := mload(0x20)
  7979 |     |             m2 := mload(0x40)
  7980 |     |             m3 := mload(0x60)
  7981 |     |             m4 := mload(0x80)
  7982 |     |             // Selector of `log(uint256,address,uint256,address)`.
  7983 |     |             mstore(0x00, 0x15c127b5)
  7984 |     |             mstore(0x20, p0)
  7985 |     |             mstore(0x40, p1)
  7986 |     |             mstore(0x60, p2)
  7987 |     |             mstore(0x80, p3)
  7988 |     |         }
  7989 |     |         _sendLogPayload(0x1c, 0x84);
  7990 |     |         assembly {
  7991 |     |             mstore(0x00, m0)
  7992 |     |             mstore(0x20, m1)
  7993 |     |             mstore(0x40, m2)
  7994 |     |             mstore(0x60, m3)
  7995 |     |             mstore(0x80, m4)
  7996 |     |         }
  7997 |     |     }
  7998 |     | 
  7999 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  8000 |     |         bytes32 m0;
  8001 |     |         bytes32 m1;
  8002 |     |         bytes32 m2;
  8003 |     |         bytes32 m3;
  8004 |     |         bytes32 m4;
  8005 |     |         assembly {
  8006 |     |             m0 := mload(0x00)
  8007 |     |             m1 := mload(0x20)
  8008 |     |             m2 := mload(0x40)
  8009 |     |             m3 := mload(0x60)
  8010 |     |             m4 := mload(0x80)
  8011 |     |             // Selector of `log(uint256,address,uint256,bool)`.
  8012 |     |             mstore(0x00, 0x5f743a7c)
  8013 |     |             mstore(0x20, p0)
  8014 |     |             mstore(0x40, p1)
  8015 |     |             mstore(0x60, p2)
  8016 |     |             mstore(0x80, p3)
  8017 |     |         }
  8018 |     |         _sendLogPayload(0x1c, 0x84);
  8019 |     |         assembly {
  8020 |     |             mstore(0x00, m0)
  8021 |     |             mstore(0x20, m1)
  8022 |     |             mstore(0x40, m2)
  8023 |     |             mstore(0x60, m3)
  8024 |     |             mstore(0x80, m4)
  8025 |     |         }
  8026 |     |     }
  8027 |     | 
  8028 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  8029 |     |         bytes32 m0;
  8030 |     |         bytes32 m1;
  8031 |     |         bytes32 m2;
  8032 |     |         bytes32 m3;
  8033 |     |         bytes32 m4;
  8034 |     |         assembly {
  8035 |     |             m0 := mload(0x00)
  8036 |     |             m1 := mload(0x20)
  8037 |     |             m2 := mload(0x40)
  8038 |     |             m3 := mload(0x60)
  8039 |     |             m4 := mload(0x80)
  8040 |     |             // Selector of `log(uint256,address,uint256,uint256)`.
  8041 |     |             mstore(0x00, 0x0c9cd9c1)
  8042 |     |             mstore(0x20, p0)
  8043 |     |             mstore(0x40, p1)
  8044 |     |             mstore(0x60, p2)
  8045 |     |             mstore(0x80, p3)
  8046 |     |         }
  8047 |     |         _sendLogPayload(0x1c, 0x84);
  8048 |     |         assembly {
  8049 |     |             mstore(0x00, m0)
  8050 |     |             mstore(0x20, m1)
  8051 |     |             mstore(0x40, m2)
  8052 |     |             mstore(0x60, m3)
  8053 |     |             mstore(0x80, m4)
  8054 |     |         }
  8055 |     |     }
  8056 |     | 
  8057 |     |     function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {
  8058 |     |         bytes32 m0;
  8059 |     |         bytes32 m1;
  8060 |     |         bytes32 m2;
  8061 |     |         bytes32 m3;
  8062 |     |         bytes32 m4;
  8063 |     |         bytes32 m5;
  8064 |     |         bytes32 m6;
  8065 |     |         assembly {
  8066 |     |             function writeString(pos, w) {
  8067 |     |                 let length := 0
  8068 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8069 |     |                 mstore(pos, length)
  8070 |     |                 let shift := sub(256, shl(3, length))
  8071 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8072 |     |             }
  8073 |     |             m0 := mload(0x00)
  8074 |     |             m1 := mload(0x20)
  8075 |     |             m2 := mload(0x40)
  8076 |     |             m3 := mload(0x60)
  8077 |     |             m4 := mload(0x80)
  8078 |     |             m5 := mload(0xa0)
  8079 |     |             m6 := mload(0xc0)
  8080 |     |             // Selector of `log(uint256,address,uint256,string)`.
  8081 |     |             mstore(0x00, 0xddb06521)
  8082 |     |             mstore(0x20, p0)
  8083 |     |             mstore(0x40, p1)
  8084 |     |             mstore(0x60, p2)
  8085 |     |             mstore(0x80, 0x80)
  8086 |     |             writeString(0xa0, p3)
  8087 |     |         }
  8088 |     |         _sendLogPayload(0x1c, 0xc4);
  8089 |     |         assembly {
  8090 |     |             mstore(0x00, m0)
  8091 |     |             mstore(0x20, m1)
  8092 |     |             mstore(0x40, m2)
  8093 |     |             mstore(0x60, m3)
  8094 |     |             mstore(0x80, m4)
  8095 |     |             mstore(0xa0, m5)
  8096 |     |             mstore(0xc0, m6)
  8097 |     |         }
  8098 |     |     }
  8099 |     | 
  8100 |     |     function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {
  8101 |     |         bytes32 m0;
  8102 |     |         bytes32 m1;
  8103 |     |         bytes32 m2;
  8104 |     |         bytes32 m3;
  8105 |     |         bytes32 m4;
  8106 |     |         bytes32 m5;
  8107 |     |         bytes32 m6;
  8108 |     |         assembly {
  8109 |     |             function writeString(pos, w) {
  8110 |     |                 let length := 0
  8111 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8112 |     |                 mstore(pos, length)
  8113 |     |                 let shift := sub(256, shl(3, length))
  8114 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8115 |     |             }
  8116 |     |             m0 := mload(0x00)
  8117 |     |             m1 := mload(0x20)
  8118 |     |             m2 := mload(0x40)
  8119 |     |             m3 := mload(0x60)
  8120 |     |             m4 := mload(0x80)
  8121 |     |             m5 := mload(0xa0)
  8122 |     |             m6 := mload(0xc0)
  8123 |     |             // Selector of `log(uint256,address,string,address)`.
  8124 |     |             mstore(0x00, 0x9cba8fff)
  8125 |     |             mstore(0x20, p0)
  8126 |     |             mstore(0x40, p1)
  8127 |     |             mstore(0x60, 0x80)
  8128 |     |             mstore(0x80, p3)
  8129 |     |             writeString(0xa0, p2)
  8130 |     |         }
  8131 |     |         _sendLogPayload(0x1c, 0xc4);
  8132 |     |         assembly {
  8133 |     |             mstore(0x00, m0)
  8134 |     |             mstore(0x20, m1)
  8135 |     |             mstore(0x40, m2)
  8136 |     |             mstore(0x60, m3)
  8137 |     |             mstore(0x80, m4)
  8138 |     |             mstore(0xa0, m5)
  8139 |     |             mstore(0xc0, m6)
  8140 |     |         }
  8141 |     |     }
  8142 |     | 
  8143 |     |     function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {
  8144 |     |         bytes32 m0;
  8145 |     |         bytes32 m1;
  8146 |     |         bytes32 m2;
  8147 |     |         bytes32 m3;
  8148 |     |         bytes32 m4;
  8149 |     |         bytes32 m5;
  8150 |     |         bytes32 m6;
  8151 |     |         assembly {
  8152 |     |             function writeString(pos, w) {
  8153 |     |                 let length := 0
  8154 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8155 |     |                 mstore(pos, length)
  8156 |     |                 let shift := sub(256, shl(3, length))
  8157 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8158 |     |             }
  8159 |     |             m0 := mload(0x00)
  8160 |     |             m1 := mload(0x20)
  8161 |     |             m2 := mload(0x40)
  8162 |     |             m3 := mload(0x60)
  8163 |     |             m4 := mload(0x80)
  8164 |     |             m5 := mload(0xa0)
  8165 |     |             m6 := mload(0xc0)
  8166 |     |             // Selector of `log(uint256,address,string,bool)`.
  8167 |     |             mstore(0x00, 0xcc32ab07)
  8168 |     |             mstore(0x20, p0)
  8169 |     |             mstore(0x40, p1)
  8170 |     |             mstore(0x60, 0x80)
  8171 |     |             mstore(0x80, p3)
  8172 |     |             writeString(0xa0, p2)
  8173 |     |         }
  8174 |     |         _sendLogPayload(0x1c, 0xc4);
  8175 |     |         assembly {
  8176 |     |             mstore(0x00, m0)
  8177 |     |             mstore(0x20, m1)
  8178 |     |             mstore(0x40, m2)
  8179 |     |             mstore(0x60, m3)
  8180 |     |             mstore(0x80, m4)
  8181 |     |             mstore(0xa0, m5)
  8182 |     |             mstore(0xc0, m6)
  8183 |     |         }
  8184 |     |     }
  8185 |     | 
  8186 |     |     function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {
  8187 |     |         bytes32 m0;
  8188 |     |         bytes32 m1;
  8189 |     |         bytes32 m2;
  8190 |     |         bytes32 m3;
  8191 |     |         bytes32 m4;
  8192 |     |         bytes32 m5;
  8193 |     |         bytes32 m6;
  8194 |     |         assembly {
  8195 |     |             function writeString(pos, w) {
  8196 |     |                 let length := 0
  8197 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8198 |     |                 mstore(pos, length)
  8199 |     |                 let shift := sub(256, shl(3, length))
  8200 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8201 |     |             }
  8202 |     |             m0 := mload(0x00)
  8203 |     |             m1 := mload(0x20)
  8204 |     |             m2 := mload(0x40)
  8205 |     |             m3 := mload(0x60)
  8206 |     |             m4 := mload(0x80)
  8207 |     |             m5 := mload(0xa0)
  8208 |     |             m6 := mload(0xc0)
  8209 |     |             // Selector of `log(uint256,address,string,uint256)`.
  8210 |     |             mstore(0x00, 0x46826b5d)
  8211 |     |             mstore(0x20, p0)
  8212 |     |             mstore(0x40, p1)
  8213 |     |             mstore(0x60, 0x80)
  8214 |     |             mstore(0x80, p3)
  8215 |     |             writeString(0xa0, p2)
  8216 |     |         }
  8217 |     |         _sendLogPayload(0x1c, 0xc4);
  8218 |     |         assembly {
  8219 |     |             mstore(0x00, m0)
  8220 |     |             mstore(0x20, m1)
  8221 |     |             mstore(0x40, m2)
  8222 |     |             mstore(0x60, m3)
  8223 |     |             mstore(0x80, m4)
  8224 |     |             mstore(0xa0, m5)
  8225 |     |             mstore(0xc0, m6)
  8226 |     |         }
  8227 |     |     }
  8228 |     | 
  8229 |     |     function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  8230 |     |         bytes32 m0;
  8231 |     |         bytes32 m1;
  8232 |     |         bytes32 m2;
  8233 |     |         bytes32 m3;
  8234 |     |         bytes32 m4;
  8235 |     |         bytes32 m5;
  8236 |     |         bytes32 m6;
  8237 |     |         bytes32 m7;
  8238 |     |         bytes32 m8;
  8239 |     |         assembly {
  8240 |     |             function writeString(pos, w) {
  8241 |     |                 let length := 0
  8242 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8243 |     |                 mstore(pos, length)
  8244 |     |                 let shift := sub(256, shl(3, length))
  8245 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8246 |     |             }
  8247 |     |             m0 := mload(0x00)
  8248 |     |             m1 := mload(0x20)
  8249 |     |             m2 := mload(0x40)
  8250 |     |             m3 := mload(0x60)
  8251 |     |             m4 := mload(0x80)
  8252 |     |             m5 := mload(0xa0)
  8253 |     |             m6 := mload(0xc0)
  8254 |     |             m7 := mload(0xe0)
  8255 |     |             m8 := mload(0x100)
  8256 |     |             // Selector of `log(uint256,address,string,string)`.
  8257 |     |             mstore(0x00, 0x3e128ca3)
  8258 |     |             mstore(0x20, p0)
  8259 |     |             mstore(0x40, p1)
  8260 |     |             mstore(0x60, 0x80)
  8261 |     |             mstore(0x80, 0xc0)
  8262 |     |             writeString(0xa0, p2)
  8263 |     |             writeString(0xe0, p3)
  8264 |     |         }
  8265 |     |         _sendLogPayload(0x1c, 0x104);
  8266 |     |         assembly {
  8267 |     |             mstore(0x00, m0)
  8268 |     |             mstore(0x20, m1)
  8269 |     |             mstore(0x40, m2)
  8270 |     |             mstore(0x60, m3)
  8271 |     |             mstore(0x80, m4)
  8272 |     |             mstore(0xa0, m5)
  8273 |     |             mstore(0xc0, m6)
  8274 |     |             mstore(0xe0, m7)
  8275 |     |             mstore(0x100, m8)
  8276 |     |         }
  8277 |     |     }
  8278 |     | 
  8279 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  8280 |     |         bytes32 m0;
  8281 |     |         bytes32 m1;
  8282 |     |         bytes32 m2;
  8283 |     |         bytes32 m3;
  8284 |     |         bytes32 m4;
  8285 |     |         assembly {
  8286 |     |             m0 := mload(0x00)
  8287 |     |             m1 := mload(0x20)
  8288 |     |             m2 := mload(0x40)
  8289 |     |             m3 := mload(0x60)
  8290 |     |             m4 := mload(0x80)
  8291 |     |             // Selector of `log(uint256,bool,address,address)`.
  8292 |     |             mstore(0x00, 0xa1ef4cbb)
  8293 |     |             mstore(0x20, p0)
  8294 |     |             mstore(0x40, p1)
  8295 |     |             mstore(0x60, p2)
  8296 |     |             mstore(0x80, p3)
  8297 |     |         }
  8298 |     |         _sendLogPayload(0x1c, 0x84);
  8299 |     |         assembly {
  8300 |     |             mstore(0x00, m0)
  8301 |     |             mstore(0x20, m1)
  8302 |     |             mstore(0x40, m2)
  8303 |     |             mstore(0x60, m3)
  8304 |     |             mstore(0x80, m4)
  8305 |     |         }
  8306 |     |     }
  8307 |     | 
  8308 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  8309 |     |         bytes32 m0;
  8310 |     |         bytes32 m1;
  8311 |     |         bytes32 m2;
  8312 |     |         bytes32 m3;
  8313 |     |         bytes32 m4;
  8314 |     |         assembly {
  8315 |     |             m0 := mload(0x00)
  8316 |     |             m1 := mload(0x20)
  8317 |     |             m2 := mload(0x40)
  8318 |     |             m3 := mload(0x60)
  8319 |     |             m4 := mload(0x80)
  8320 |     |             // Selector of `log(uint256,bool,address,bool)`.
  8321 |     |             mstore(0x00, 0x454d54a5)
  8322 |     |             mstore(0x20, p0)
  8323 |     |             mstore(0x40, p1)
  8324 |     |             mstore(0x60, p2)
  8325 |     |             mstore(0x80, p3)
  8326 |     |         }
  8327 |     |         _sendLogPayload(0x1c, 0x84);
  8328 |     |         assembly {
  8329 |     |             mstore(0x00, m0)
  8330 |     |             mstore(0x20, m1)
  8331 |     |             mstore(0x40, m2)
  8332 |     |             mstore(0x60, m3)
  8333 |     |             mstore(0x80, m4)
  8334 |     |         }
  8335 |     |     }
  8336 |     | 
  8337 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  8338 |     |         bytes32 m0;
  8339 |     |         bytes32 m1;
  8340 |     |         bytes32 m2;
  8341 |     |         bytes32 m3;
  8342 |     |         bytes32 m4;
  8343 |     |         assembly {
  8344 |     |             m0 := mload(0x00)
  8345 |     |             m1 := mload(0x20)
  8346 |     |             m2 := mload(0x40)
  8347 |     |             m3 := mload(0x60)
  8348 |     |             m4 := mload(0x80)
  8349 |     |             // Selector of `log(uint256,bool,address,uint256)`.
  8350 |     |             mstore(0x00, 0x078287f5)
  8351 |     |             mstore(0x20, p0)
  8352 |     |             mstore(0x40, p1)
  8353 |     |             mstore(0x60, p2)
  8354 |     |             mstore(0x80, p3)
  8355 |     |         }
  8356 |     |         _sendLogPayload(0x1c, 0x84);
  8357 |     |         assembly {
  8358 |     |             mstore(0x00, m0)
  8359 |     |             mstore(0x20, m1)
  8360 |     |             mstore(0x40, m2)
  8361 |     |             mstore(0x60, m3)
  8362 |     |             mstore(0x80, m4)
  8363 |     |         }
  8364 |     |     }
  8365 |     | 
  8366 |     |     function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {
  8367 |     |         bytes32 m0;
  8368 |     |         bytes32 m1;
  8369 |     |         bytes32 m2;
  8370 |     |         bytes32 m3;
  8371 |     |         bytes32 m4;
  8372 |     |         bytes32 m5;
  8373 |     |         bytes32 m6;
  8374 |     |         assembly {
  8375 |     |             function writeString(pos, w) {
  8376 |     |                 let length := 0
  8377 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8378 |     |                 mstore(pos, length)
  8379 |     |                 let shift := sub(256, shl(3, length))
  8380 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8381 |     |             }
  8382 |     |             m0 := mload(0x00)
  8383 |     |             m1 := mload(0x20)
  8384 |     |             m2 := mload(0x40)
  8385 |     |             m3 := mload(0x60)
  8386 |     |             m4 := mload(0x80)
  8387 |     |             m5 := mload(0xa0)
  8388 |     |             m6 := mload(0xc0)
  8389 |     |             // Selector of `log(uint256,bool,address,string)`.
  8390 |     |             mstore(0x00, 0xade052c7)
  8391 |     |             mstore(0x20, p0)
  8392 |     |             mstore(0x40, p1)
  8393 |     |             mstore(0x60, p2)
  8394 |     |             mstore(0x80, 0x80)
  8395 |     |             writeString(0xa0, p3)
  8396 |     |         }
  8397 |     |         _sendLogPayload(0x1c, 0xc4);
  8398 |     |         assembly {
  8399 |     |             mstore(0x00, m0)
  8400 |     |             mstore(0x20, m1)
  8401 |     |             mstore(0x40, m2)
  8402 |     |             mstore(0x60, m3)
  8403 |     |             mstore(0x80, m4)
  8404 |     |             mstore(0xa0, m5)
  8405 |     |             mstore(0xc0, m6)
  8406 |     |         }
  8407 |     |     }
  8408 |     | 
  8409 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  8410 |     |         bytes32 m0;
  8411 |     |         bytes32 m1;
  8412 |     |         bytes32 m2;
  8413 |     |         bytes32 m3;
  8414 |     |         bytes32 m4;
  8415 |     |         assembly {
  8416 |     |             m0 := mload(0x00)
  8417 |     |             m1 := mload(0x20)
  8418 |     |             m2 := mload(0x40)
  8419 |     |             m3 := mload(0x60)
  8420 |     |             m4 := mload(0x80)
  8421 |     |             // Selector of `log(uint256,bool,bool,address)`.
  8422 |     |             mstore(0x00, 0x69640b59)
  8423 |     |             mstore(0x20, p0)
  8424 |     |             mstore(0x40, p1)
  8425 |     |             mstore(0x60, p2)
  8426 |     |             mstore(0x80, p3)
  8427 |     |         }
  8428 |     |         _sendLogPayload(0x1c, 0x84);
  8429 |     |         assembly {
  8430 |     |             mstore(0x00, m0)
  8431 |     |             mstore(0x20, m1)
  8432 |     |             mstore(0x40, m2)
  8433 |     |             mstore(0x60, m3)
  8434 |     |             mstore(0x80, m4)
  8435 |     |         }
  8436 |     |     }
  8437 |     | 
  8438 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  8439 |     |         bytes32 m0;
  8440 |     |         bytes32 m1;
  8441 |     |         bytes32 m2;
  8442 |     |         bytes32 m3;
  8443 |     |         bytes32 m4;
  8444 |     |         assembly {
  8445 |     |             m0 := mload(0x00)
  8446 |     |             m1 := mload(0x20)
  8447 |     |             m2 := mload(0x40)
  8448 |     |             m3 := mload(0x60)
  8449 |     |             m4 := mload(0x80)
  8450 |     |             // Selector of `log(uint256,bool,bool,bool)`.
  8451 |     |             mstore(0x00, 0xb6f577a1)
  8452 |     |             mstore(0x20, p0)
  8453 |     |             mstore(0x40, p1)
  8454 |     |             mstore(0x60, p2)
  8455 |     |             mstore(0x80, p3)
  8456 |     |         }
  8457 |     |         _sendLogPayload(0x1c, 0x84);
  8458 |     |         assembly {
  8459 |     |             mstore(0x00, m0)
  8460 |     |             mstore(0x20, m1)
  8461 |     |             mstore(0x40, m2)
  8462 |     |             mstore(0x60, m3)
  8463 |     |             mstore(0x80, m4)
  8464 |     |         }
  8465 |     |     }
  8466 |     | 
  8467 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  8468 |     |         bytes32 m0;
  8469 |     |         bytes32 m1;
  8470 |     |         bytes32 m2;
  8471 |     |         bytes32 m3;
  8472 |     |         bytes32 m4;
  8473 |     |         assembly {
  8474 |     |             m0 := mload(0x00)
  8475 |     |             m1 := mload(0x20)
  8476 |     |             m2 := mload(0x40)
  8477 |     |             m3 := mload(0x60)
  8478 |     |             m4 := mload(0x80)
  8479 |     |             // Selector of `log(uint256,bool,bool,uint256)`.
  8480 |     |             mstore(0x00, 0x7464ce23)
  8481 |     |             mstore(0x20, p0)
  8482 |     |             mstore(0x40, p1)
  8483 |     |             mstore(0x60, p2)
  8484 |     |             mstore(0x80, p3)
  8485 |     |         }
  8486 |     |         _sendLogPayload(0x1c, 0x84);
  8487 |     |         assembly {
  8488 |     |             mstore(0x00, m0)
  8489 |     |             mstore(0x20, m1)
  8490 |     |             mstore(0x40, m2)
  8491 |     |             mstore(0x60, m3)
  8492 |     |             mstore(0x80, m4)
  8493 |     |         }
  8494 |     |     }
  8495 |     | 
  8496 |     |     function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {
  8497 |     |         bytes32 m0;
  8498 |     |         bytes32 m1;
  8499 |     |         bytes32 m2;
  8500 |     |         bytes32 m3;
  8501 |     |         bytes32 m4;
  8502 |     |         bytes32 m5;
  8503 |     |         bytes32 m6;
  8504 |     |         assembly {
  8505 |     |             function writeString(pos, w) {
  8506 |     |                 let length := 0
  8507 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8508 |     |                 mstore(pos, length)
  8509 |     |                 let shift := sub(256, shl(3, length))
  8510 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8511 |     |             }
  8512 |     |             m0 := mload(0x00)
  8513 |     |             m1 := mload(0x20)
  8514 |     |             m2 := mload(0x40)
  8515 |     |             m3 := mload(0x60)
  8516 |     |             m4 := mload(0x80)
  8517 |     |             m5 := mload(0xa0)
  8518 |     |             m6 := mload(0xc0)
  8519 |     |             // Selector of `log(uint256,bool,bool,string)`.
  8520 |     |             mstore(0x00, 0xdddb9561)
  8521 |     |             mstore(0x20, p0)
  8522 |     |             mstore(0x40, p1)
  8523 |     |             mstore(0x60, p2)
  8524 |     |             mstore(0x80, 0x80)
  8525 |     |             writeString(0xa0, p3)
  8526 |     |         }
  8527 |     |         _sendLogPayload(0x1c, 0xc4);
  8528 |     |         assembly {
  8529 |     |             mstore(0x00, m0)
  8530 |     |             mstore(0x20, m1)
  8531 |     |             mstore(0x40, m2)
  8532 |     |             mstore(0x60, m3)
  8533 |     |             mstore(0x80, m4)
  8534 |     |             mstore(0xa0, m5)
  8535 |     |             mstore(0xc0, m6)
  8536 |     |         }
  8537 |     |     }
  8538 |     | 
  8539 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  8540 |     |         bytes32 m0;
  8541 |     |         bytes32 m1;
  8542 |     |         bytes32 m2;
  8543 |     |         bytes32 m3;
  8544 |     |         bytes32 m4;
  8545 |     |         assembly {
  8546 |     |             m0 := mload(0x00)
  8547 |     |             m1 := mload(0x20)
  8548 |     |             m2 := mload(0x40)
  8549 |     |             m3 := mload(0x60)
  8550 |     |             m4 := mload(0x80)
  8551 |     |             // Selector of `log(uint256,bool,uint256,address)`.
  8552 |     |             mstore(0x00, 0x88cb6041)
  8553 |     |             mstore(0x20, p0)
  8554 |     |             mstore(0x40, p1)
  8555 |     |             mstore(0x60, p2)
  8556 |     |             mstore(0x80, p3)
  8557 |     |         }
  8558 |     |         _sendLogPayload(0x1c, 0x84);
  8559 |     |         assembly {
  8560 |     |             mstore(0x00, m0)
  8561 |     |             mstore(0x20, m1)
  8562 |     |             mstore(0x40, m2)
  8563 |     |             mstore(0x60, m3)
  8564 |     |             mstore(0x80, m4)
  8565 |     |         }
  8566 |     |     }
  8567 |     | 
  8568 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  8569 |     |         bytes32 m0;
  8570 |     |         bytes32 m1;
  8571 |     |         bytes32 m2;
  8572 |     |         bytes32 m3;
  8573 |     |         bytes32 m4;
  8574 |     |         assembly {
  8575 |     |             m0 := mload(0x00)
  8576 |     |             m1 := mload(0x20)
  8577 |     |             m2 := mload(0x40)
  8578 |     |             m3 := mload(0x60)
  8579 |     |             m4 := mload(0x80)
  8580 |     |             // Selector of `log(uint256,bool,uint256,bool)`.
  8581 |     |             mstore(0x00, 0x91a02e2a)
  8582 |     |             mstore(0x20, p0)
  8583 |     |             mstore(0x40, p1)
  8584 |     |             mstore(0x60, p2)
  8585 |     |             mstore(0x80, p3)
  8586 |     |         }
  8587 |     |         _sendLogPayload(0x1c, 0x84);
  8588 |     |         assembly {
  8589 |     |             mstore(0x00, m0)
  8590 |     |             mstore(0x20, m1)
  8591 |     |             mstore(0x40, m2)
  8592 |     |             mstore(0x60, m3)
  8593 |     |             mstore(0x80, m4)
  8594 |     |         }
  8595 |     |     }
  8596 |     | 
  8597 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  8598 |     |         bytes32 m0;
  8599 |     |         bytes32 m1;
  8600 |     |         bytes32 m2;
  8601 |     |         bytes32 m3;
  8602 |     |         bytes32 m4;
  8603 |     |         assembly {
  8604 |     |             m0 := mload(0x00)
  8605 |     |             m1 := mload(0x20)
  8606 |     |             m2 := mload(0x40)
  8607 |     |             m3 := mload(0x60)
  8608 |     |             m4 := mload(0x80)
  8609 |     |             // Selector of `log(uint256,bool,uint256,uint256)`.
  8610 |     |             mstore(0x00, 0xc6acc7a8)
  8611 |     |             mstore(0x20, p0)
  8612 |     |             mstore(0x40, p1)
  8613 |     |             mstore(0x60, p2)
  8614 |     |             mstore(0x80, p3)
  8615 |     |         }
  8616 |     |         _sendLogPayload(0x1c, 0x84);
  8617 |     |         assembly {
  8618 |     |             mstore(0x00, m0)
  8619 |     |             mstore(0x20, m1)
  8620 |     |             mstore(0x40, m2)
  8621 |     |             mstore(0x60, m3)
  8622 |     |             mstore(0x80, m4)
  8623 |     |         }
  8624 |     |     }
  8625 |     | 
  8626 |     |     function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  8627 |     |         bytes32 m0;
  8628 |     |         bytes32 m1;
  8629 |     |         bytes32 m2;
  8630 |     |         bytes32 m3;
  8631 |     |         bytes32 m4;
  8632 |     |         bytes32 m5;
  8633 |     |         bytes32 m6;
  8634 |     |         assembly {
  8635 |     |             function writeString(pos, w) {
  8636 |     |                 let length := 0
  8637 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8638 |     |                 mstore(pos, length)
  8639 |     |                 let shift := sub(256, shl(3, length))
  8640 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8641 |     |             }
  8642 |     |             m0 := mload(0x00)
  8643 |     |             m1 := mload(0x20)
  8644 |     |             m2 := mload(0x40)
  8645 |     |             m3 := mload(0x60)
  8646 |     |             m4 := mload(0x80)
  8647 |     |             m5 := mload(0xa0)
  8648 |     |             m6 := mload(0xc0)
  8649 |     |             // Selector of `log(uint256,bool,uint256,string)`.
  8650 |     |             mstore(0x00, 0xde03e774)
  8651 |     |             mstore(0x20, p0)
  8652 |     |             mstore(0x40, p1)
  8653 |     |             mstore(0x60, p2)
  8654 |     |             mstore(0x80, 0x80)
  8655 |     |             writeString(0xa0, p3)
  8656 |     |         }
  8657 |     |         _sendLogPayload(0x1c, 0xc4);
  8658 |     |         assembly {
  8659 |     |             mstore(0x00, m0)
  8660 |     |             mstore(0x20, m1)
  8661 |     |             mstore(0x40, m2)
  8662 |     |             mstore(0x60, m3)
  8663 |     |             mstore(0x80, m4)
  8664 |     |             mstore(0xa0, m5)
  8665 |     |             mstore(0xc0, m6)
  8666 |     |         }
  8667 |     |     }
  8668 |     | 
  8669 |     |     function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {
  8670 |     |         bytes32 m0;
  8671 |     |         bytes32 m1;
  8672 |     |         bytes32 m2;
  8673 |     |         bytes32 m3;
  8674 |     |         bytes32 m4;
  8675 |     |         bytes32 m5;
  8676 |     |         bytes32 m6;
  8677 |     |         assembly {
  8678 |     |             function writeString(pos, w) {
  8679 |     |                 let length := 0
  8680 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8681 |     |                 mstore(pos, length)
  8682 |     |                 let shift := sub(256, shl(3, length))
  8683 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8684 |     |             }
  8685 |     |             m0 := mload(0x00)
  8686 |     |             m1 := mload(0x20)
  8687 |     |             m2 := mload(0x40)
  8688 |     |             m3 := mload(0x60)
  8689 |     |             m4 := mload(0x80)
  8690 |     |             m5 := mload(0xa0)
  8691 |     |             m6 := mload(0xc0)
  8692 |     |             // Selector of `log(uint256,bool,string,address)`.
  8693 |     |             mstore(0x00, 0xef529018)
  8694 |     |             mstore(0x20, p0)
  8695 |     |             mstore(0x40, p1)
  8696 |     |             mstore(0x60, 0x80)
  8697 |     |             mstore(0x80, p3)
  8698 |     |             writeString(0xa0, p2)
  8699 |     |         }
  8700 |     |         _sendLogPayload(0x1c, 0xc4);
  8701 |     |         assembly {
  8702 |     |             mstore(0x00, m0)
  8703 |     |             mstore(0x20, m1)
  8704 |     |             mstore(0x40, m2)
  8705 |     |             mstore(0x60, m3)
  8706 |     |             mstore(0x80, m4)
  8707 |     |             mstore(0xa0, m5)
  8708 |     |             mstore(0xc0, m6)
  8709 |     |         }
  8710 |     |     }
  8711 |     | 
  8712 |     |     function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {
  8713 |     |         bytes32 m0;
  8714 |     |         bytes32 m1;
  8715 |     |         bytes32 m2;
  8716 |     |         bytes32 m3;
  8717 |     |         bytes32 m4;
  8718 |     |         bytes32 m5;
  8719 |     |         bytes32 m6;
  8720 |     |         assembly {
  8721 |     |             function writeString(pos, w) {
  8722 |     |                 let length := 0
  8723 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8724 |     |                 mstore(pos, length)
  8725 |     |                 let shift := sub(256, shl(3, length))
  8726 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8727 |     |             }
  8728 |     |             m0 := mload(0x00)
  8729 |     |             m1 := mload(0x20)
  8730 |     |             m2 := mload(0x40)
  8731 |     |             m3 := mload(0x60)
  8732 |     |             m4 := mload(0x80)
  8733 |     |             m5 := mload(0xa0)
  8734 |     |             m6 := mload(0xc0)
  8735 |     |             // Selector of `log(uint256,bool,string,bool)`.
  8736 |     |             mstore(0x00, 0xeb928d7f)
  8737 |     |             mstore(0x20, p0)
  8738 |     |             mstore(0x40, p1)
  8739 |     |             mstore(0x60, 0x80)
  8740 |     |             mstore(0x80, p3)
  8741 |     |             writeString(0xa0, p2)
  8742 |     |         }
  8743 |     |         _sendLogPayload(0x1c, 0xc4);
  8744 |     |         assembly {
  8745 |     |             mstore(0x00, m0)
  8746 |     |             mstore(0x20, m1)
  8747 |     |             mstore(0x40, m2)
  8748 |     |             mstore(0x60, m3)
  8749 |     |             mstore(0x80, m4)
  8750 |     |             mstore(0xa0, m5)
  8751 |     |             mstore(0xc0, m6)
  8752 |     |         }
  8753 |     |     }
  8754 |     | 
  8755 |     |     function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  8756 |     |         bytes32 m0;
  8757 |     |         bytes32 m1;
  8758 |     |         bytes32 m2;
  8759 |     |         bytes32 m3;
  8760 |     |         bytes32 m4;
  8761 |     |         bytes32 m5;
  8762 |     |         bytes32 m6;
  8763 |     |         assembly {
  8764 |     |             function writeString(pos, w) {
  8765 |     |                 let length := 0
  8766 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8767 |     |                 mstore(pos, length)
  8768 |     |                 let shift := sub(256, shl(3, length))
  8769 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8770 |     |             }
  8771 |     |             m0 := mload(0x00)
  8772 |     |             m1 := mload(0x20)
  8773 |     |             m2 := mload(0x40)
  8774 |     |             m3 := mload(0x60)
  8775 |     |             m4 := mload(0x80)
  8776 |     |             m5 := mload(0xa0)
  8777 |     |             m6 := mload(0xc0)
  8778 |     |             // Selector of `log(uint256,bool,string,uint256)`.
  8779 |     |             mstore(0x00, 0x2c1d0746)
  8780 |     |             mstore(0x20, p0)
  8781 |     |             mstore(0x40, p1)
  8782 |     |             mstore(0x60, 0x80)
  8783 |     |             mstore(0x80, p3)
  8784 |     |             writeString(0xa0, p2)
  8785 |     |         }
  8786 |     |         _sendLogPayload(0x1c, 0xc4);
  8787 |     |         assembly {
  8788 |     |             mstore(0x00, m0)
  8789 |     |             mstore(0x20, m1)
  8790 |     |             mstore(0x40, m2)
  8791 |     |             mstore(0x60, m3)
  8792 |     |             mstore(0x80, m4)
  8793 |     |             mstore(0xa0, m5)
  8794 |     |             mstore(0xc0, m6)
  8795 |     |         }
  8796 |     |     }
  8797 |     | 
  8798 |     |     function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  8799 |     |         bytes32 m0;
  8800 |     |         bytes32 m1;
  8801 |     |         bytes32 m2;
  8802 |     |         bytes32 m3;
  8803 |     |         bytes32 m4;
  8804 |     |         bytes32 m5;
  8805 |     |         bytes32 m6;
  8806 |     |         bytes32 m7;
  8807 |     |         bytes32 m8;
  8808 |     |         assembly {
  8809 |     |             function writeString(pos, w) {
  8810 |     |                 let length := 0
  8811 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8812 |     |                 mstore(pos, length)
  8813 |     |                 let shift := sub(256, shl(3, length))
  8814 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8815 |     |             }
  8816 |     |             m0 := mload(0x00)
  8817 |     |             m1 := mload(0x20)
  8818 |     |             m2 := mload(0x40)
  8819 |     |             m3 := mload(0x60)
  8820 |     |             m4 := mload(0x80)
  8821 |     |             m5 := mload(0xa0)
  8822 |     |             m6 := mload(0xc0)
  8823 |     |             m7 := mload(0xe0)
  8824 |     |             m8 := mload(0x100)
  8825 |     |             // Selector of `log(uint256,bool,string,string)`.
  8826 |     |             mstore(0x00, 0x68c8b8bd)
  8827 |     |             mstore(0x20, p0)
  8828 |     |             mstore(0x40, p1)
  8829 |     |             mstore(0x60, 0x80)
  8830 |     |             mstore(0x80, 0xc0)
  8831 |     |             writeString(0xa0, p2)
  8832 |     |             writeString(0xe0, p3)
  8833 |     |         }
  8834 |     |         _sendLogPayload(0x1c, 0x104);
  8835 |     |         assembly {
  8836 |     |             mstore(0x00, m0)
  8837 |     |             mstore(0x20, m1)
  8838 |     |             mstore(0x40, m2)
  8839 |     |             mstore(0x60, m3)
  8840 |     |             mstore(0x80, m4)
  8841 |     |             mstore(0xa0, m5)
  8842 |     |             mstore(0xc0, m6)
  8843 |     |             mstore(0xe0, m7)
  8844 |     |             mstore(0x100, m8)
  8845 |     |         }
  8846 |     |     }
  8847 |     | 
  8848 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  8849 |     |         bytes32 m0;
  8850 |     |         bytes32 m1;
  8851 |     |         bytes32 m2;
  8852 |     |         bytes32 m3;
  8853 |     |         bytes32 m4;
  8854 |     |         assembly {
  8855 |     |             m0 := mload(0x00)
  8856 |     |             m1 := mload(0x20)
  8857 |     |             m2 := mload(0x40)
  8858 |     |             m3 := mload(0x60)
  8859 |     |             m4 := mload(0x80)
  8860 |     |             // Selector of `log(uint256,uint256,address,address)`.
  8861 |     |             mstore(0x00, 0x56a5d1b1)
  8862 |     |             mstore(0x20, p0)
  8863 |     |             mstore(0x40, p1)
  8864 |     |             mstore(0x60, p2)
  8865 |     |             mstore(0x80, p3)
  8866 |     |         }
  8867 |     |         _sendLogPayload(0x1c, 0x84);
  8868 |     |         assembly {
  8869 |     |             mstore(0x00, m0)
  8870 |     |             mstore(0x20, m1)
  8871 |     |             mstore(0x40, m2)
  8872 |     |             mstore(0x60, m3)
  8873 |     |             mstore(0x80, m4)
  8874 |     |         }
  8875 |     |     }
  8876 |     | 
  8877 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  8878 |     |         bytes32 m0;
  8879 |     |         bytes32 m1;
  8880 |     |         bytes32 m2;
  8881 |     |         bytes32 m3;
  8882 |     |         bytes32 m4;
  8883 |     |         assembly {
  8884 |     |             m0 := mload(0x00)
  8885 |     |             m1 := mload(0x20)
  8886 |     |             m2 := mload(0x40)
  8887 |     |             m3 := mload(0x60)
  8888 |     |             m4 := mload(0x80)
  8889 |     |             // Selector of `log(uint256,uint256,address,bool)`.
  8890 |     |             mstore(0x00, 0x15cac476)
  8891 |     |             mstore(0x20, p0)
  8892 |     |             mstore(0x40, p1)
  8893 |     |             mstore(0x60, p2)
  8894 |     |             mstore(0x80, p3)
  8895 |     |         }
  8896 |     |         _sendLogPayload(0x1c, 0x84);
  8897 |     |         assembly {
  8898 |     |             mstore(0x00, m0)
  8899 |     |             mstore(0x20, m1)
  8900 |     |             mstore(0x40, m2)
  8901 |     |             mstore(0x60, m3)
  8902 |     |             mstore(0x80, m4)
  8903 |     |         }
  8904 |     |     }
  8905 |     | 
  8906 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  8907 |     |         bytes32 m0;
  8908 |     |         bytes32 m1;
  8909 |     |         bytes32 m2;
  8910 |     |         bytes32 m3;
  8911 |     |         bytes32 m4;
  8912 |     |         assembly {
  8913 |     |             m0 := mload(0x00)
  8914 |     |             m1 := mload(0x20)
  8915 |     |             m2 := mload(0x40)
  8916 |     |             m3 := mload(0x60)
  8917 |     |             m4 := mload(0x80)
  8918 |     |             // Selector of `log(uint256,uint256,address,uint256)`.
  8919 |     |             mstore(0x00, 0x88f6e4b2)
  8920 |     |             mstore(0x20, p0)
  8921 |     |             mstore(0x40, p1)
  8922 |     |             mstore(0x60, p2)
  8923 |     |             mstore(0x80, p3)
  8924 |     |         }
  8925 |     |         _sendLogPayload(0x1c, 0x84);
  8926 |     |         assembly {
  8927 |     |             mstore(0x00, m0)
  8928 |     |             mstore(0x20, m1)
  8929 |     |             mstore(0x40, m2)
  8930 |     |             mstore(0x60, m3)
  8931 |     |             mstore(0x80, m4)
  8932 |     |         }
  8933 |     |     }
  8934 |     | 
  8935 |     |     function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {
  8936 |     |         bytes32 m0;
  8937 |     |         bytes32 m1;
  8938 |     |         bytes32 m2;
  8939 |     |         bytes32 m3;
  8940 |     |         bytes32 m4;
  8941 |     |         bytes32 m5;
  8942 |     |         bytes32 m6;
  8943 |     |         assembly {
  8944 |     |             function writeString(pos, w) {
  8945 |     |                 let length := 0
  8946 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8947 |     |                 mstore(pos, length)
  8948 |     |                 let shift := sub(256, shl(3, length))
  8949 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8950 |     |             }
  8951 |     |             m0 := mload(0x00)
  8952 |     |             m1 := mload(0x20)
  8953 |     |             m2 := mload(0x40)
  8954 |     |             m3 := mload(0x60)
  8955 |     |             m4 := mload(0x80)
  8956 |     |             m5 := mload(0xa0)
  8957 |     |             m6 := mload(0xc0)
  8958 |     |             // Selector of `log(uint256,uint256,address,string)`.
  8959 |     |             mstore(0x00, 0x6cde40b8)
  8960 |     |             mstore(0x20, p0)
  8961 |     |             mstore(0x40, p1)
  8962 |     |             mstore(0x60, p2)
  8963 |     |             mstore(0x80, 0x80)
  8964 |     |             writeString(0xa0, p3)
  8965 |     |         }
  8966 |     |         _sendLogPayload(0x1c, 0xc4);
  8967 |     |         assembly {
  8968 |     |             mstore(0x00, m0)
  8969 |     |             mstore(0x20, m1)
  8970 |     |             mstore(0x40, m2)
  8971 |     |             mstore(0x60, m3)
  8972 |     |             mstore(0x80, m4)
  8973 |     |             mstore(0xa0, m5)
  8974 |     |             mstore(0xc0, m6)
  8975 |     |         }
  8976 |     |     }
  8977 |     | 
  8978 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  8979 |     |         bytes32 m0;
  8980 |     |         bytes32 m1;
  8981 |     |         bytes32 m2;
  8982 |     |         bytes32 m3;
  8983 |     |         bytes32 m4;
  8984 |     |         assembly {
  8985 |     |             m0 := mload(0x00)
  8986 |     |             m1 := mload(0x20)
  8987 |     |             m2 := mload(0x40)
  8988 |     |             m3 := mload(0x60)
  8989 |     |             m4 := mload(0x80)
  8990 |     |             // Selector of `log(uint256,uint256,bool,address)`.
  8991 |     |             mstore(0x00, 0x9a816a83)
  8992 |     |             mstore(0x20, p0)
  8993 |     |             mstore(0x40, p1)
  8994 |     |             mstore(0x60, p2)
  8995 |     |             mstore(0x80, p3)
  8996 |     |         }
  8997 |     |         _sendLogPayload(0x1c, 0x84);
  8998 |     |         assembly {
  8999 |     |             mstore(0x00, m0)
  9000 |     |             mstore(0x20, m1)
  9001 |     |             mstore(0x40, m2)
  9002 |     |             mstore(0x60, m3)
  9003 |     |             mstore(0x80, m4)
  9004 |     |         }
  9005 |     |     }
  9006 |     | 
  9007 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  9008 |     |         bytes32 m0;
  9009 |     |         bytes32 m1;
  9010 |     |         bytes32 m2;
  9011 |     |         bytes32 m3;
  9012 |     |         bytes32 m4;
  9013 |     |         assembly {
  9014 |     |             m0 := mload(0x00)
  9015 |     |             m1 := mload(0x20)
  9016 |     |             m2 := mload(0x40)
  9017 |     |             m3 := mload(0x60)
  9018 |     |             m4 := mload(0x80)
  9019 |     |             // Selector of `log(uint256,uint256,bool,bool)`.
  9020 |     |             mstore(0x00, 0xab085ae6)
  9021 |     |             mstore(0x20, p0)
  9022 |     |             mstore(0x40, p1)
  9023 |     |             mstore(0x60, p2)
  9024 |     |             mstore(0x80, p3)
  9025 |     |         }
  9026 |     |         _sendLogPayload(0x1c, 0x84);
  9027 |     |         assembly {
  9028 |     |             mstore(0x00, m0)
  9029 |     |             mstore(0x20, m1)
  9030 |     |             mstore(0x40, m2)
  9031 |     |             mstore(0x60, m3)
  9032 |     |             mstore(0x80, m4)
  9033 |     |         }
  9034 |     |     }
  9035 |     | 
  9036 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  9037 |     |         bytes32 m0;
  9038 |     |         bytes32 m1;
  9039 |     |         bytes32 m2;
  9040 |     |         bytes32 m3;
  9041 |     |         bytes32 m4;
  9042 |     |         assembly {
  9043 |     |             m0 := mload(0x00)
  9044 |     |             m1 := mload(0x20)
  9045 |     |             m2 := mload(0x40)
  9046 |     |             m3 := mload(0x60)
  9047 |     |             m4 := mload(0x80)
  9048 |     |             // Selector of `log(uint256,uint256,bool,uint256)`.
  9049 |     |             mstore(0x00, 0xeb7f6fd2)
  9050 |     |             mstore(0x20, p0)
  9051 |     |             mstore(0x40, p1)
  9052 |     |             mstore(0x60, p2)
  9053 |     |             mstore(0x80, p3)
  9054 |     |         }
  9055 |     |         _sendLogPayload(0x1c, 0x84);
  9056 |     |         assembly {
  9057 |     |             mstore(0x00, m0)
  9058 |     |             mstore(0x20, m1)
  9059 |     |             mstore(0x40, m2)
  9060 |     |             mstore(0x60, m3)
  9061 |     |             mstore(0x80, m4)
  9062 |     |         }
  9063 |     |     }
  9064 |     | 
  9065 |     |     function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  9066 |     |         bytes32 m0;
  9067 |     |         bytes32 m1;
  9068 |     |         bytes32 m2;
  9069 |     |         bytes32 m3;
  9070 |     |         bytes32 m4;
  9071 |     |         bytes32 m5;
  9072 |     |         bytes32 m6;
  9073 |     |         assembly {
  9074 |     |             function writeString(pos, w) {
  9075 |     |                 let length := 0
  9076 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9077 |     |                 mstore(pos, length)
  9078 |     |                 let shift := sub(256, shl(3, length))
  9079 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9080 |     |             }
  9081 |     |             m0 := mload(0x00)
  9082 |     |             m1 := mload(0x20)
  9083 |     |             m2 := mload(0x40)
  9084 |     |             m3 := mload(0x60)
  9085 |     |             m4 := mload(0x80)
  9086 |     |             m5 := mload(0xa0)
  9087 |     |             m6 := mload(0xc0)
  9088 |     |             // Selector of `log(uint256,uint256,bool,string)`.
  9089 |     |             mstore(0x00, 0xa5b4fc99)
  9090 |     |             mstore(0x20, p0)
  9091 |     |             mstore(0x40, p1)
  9092 |     |             mstore(0x60, p2)
  9093 |     |             mstore(0x80, 0x80)
  9094 |     |             writeString(0xa0, p3)
  9095 |     |         }
  9096 |     |         _sendLogPayload(0x1c, 0xc4);
  9097 |     |         assembly {
  9098 |     |             mstore(0x00, m0)
  9099 |     |             mstore(0x20, m1)
  9100 |     |             mstore(0x40, m2)
  9101 |     |             mstore(0x60, m3)
  9102 |     |             mstore(0x80, m4)
  9103 |     |             mstore(0xa0, m5)
  9104 |     |             mstore(0xc0, m6)
  9105 |     |         }
  9106 |     |     }
  9107 |     | 
  9108 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  9109 |     |         bytes32 m0;
  9110 |     |         bytes32 m1;
  9111 |     |         bytes32 m2;
  9112 |     |         bytes32 m3;
  9113 |     |         bytes32 m4;
  9114 |     |         assembly {
  9115 |     |             m0 := mload(0x00)
  9116 |     |             m1 := mload(0x20)
  9117 |     |             m2 := mload(0x40)
  9118 |     |             m3 := mload(0x60)
  9119 |     |             m4 := mload(0x80)
  9120 |     |             // Selector of `log(uint256,uint256,uint256,address)`.
  9121 |     |             mstore(0x00, 0xfa8185af)
  9122 |     |             mstore(0x20, p0)
  9123 |     |             mstore(0x40, p1)
  9124 |     |             mstore(0x60, p2)
  9125 |     |             mstore(0x80, p3)
  9126 |     |         }
  9127 |     |         _sendLogPayload(0x1c, 0x84);
  9128 |     |         assembly {
  9129 |     |             mstore(0x00, m0)
  9130 |     |             mstore(0x20, m1)
  9131 |     |             mstore(0x40, m2)
  9132 |     |             mstore(0x60, m3)
  9133 |     |             mstore(0x80, m4)
  9134 |     |         }
  9135 |     |     }
  9136 |     | 
  9137 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  9138 |     |         bytes32 m0;
  9139 |     |         bytes32 m1;
  9140 |     |         bytes32 m2;
  9141 |     |         bytes32 m3;
  9142 |     |         bytes32 m4;
  9143 |     |         assembly {
  9144 |     |             m0 := mload(0x00)
  9145 |     |             m1 := mload(0x20)
  9146 |     |             m2 := mload(0x40)
  9147 |     |             m3 := mload(0x60)
  9148 |     |             m4 := mload(0x80)
  9149 |     |             // Selector of `log(uint256,uint256,uint256,bool)`.
  9150 |     |             mstore(0x00, 0xc598d185)
  9151 |     |             mstore(0x20, p0)
  9152 |     |             mstore(0x40, p1)
  9153 |     |             mstore(0x60, p2)
  9154 |     |             mstore(0x80, p3)
  9155 |     |         }
  9156 |     |         _sendLogPayload(0x1c, 0x84);
  9157 |     |         assembly {
  9158 |     |             mstore(0x00, m0)
  9159 |     |             mstore(0x20, m1)
  9160 |     |             mstore(0x40, m2)
  9161 |     |             mstore(0x60, m3)
  9162 |     |             mstore(0x80, m4)
  9163 |     |         }
  9164 |     |     }
  9165 |     | 
  9166 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  9167 |     |         bytes32 m0;
  9168 |     |         bytes32 m1;
  9169 |     |         bytes32 m2;
  9170 |     |         bytes32 m3;
  9171 |     |         bytes32 m4;
  9172 |     |         assembly {
  9173 |     |             m0 := mload(0x00)
  9174 |     |             m1 := mload(0x20)
  9175 |     |             m2 := mload(0x40)
  9176 |     |             m3 := mload(0x60)
  9177 |     |             m4 := mload(0x80)
  9178 |     |             // Selector of `log(uint256,uint256,uint256,uint256)`.
  9179 |     |             mstore(0x00, 0x193fb800)
  9180 |     |             mstore(0x20, p0)
  9181 |     |             mstore(0x40, p1)
  9182 |     |             mstore(0x60, p2)
  9183 |     |             mstore(0x80, p3)
  9184 |     |         }
  9185 |     |         _sendLogPayload(0x1c, 0x84);
  9186 |     |         assembly {
  9187 |     |             mstore(0x00, m0)
  9188 |     |             mstore(0x20, m1)
  9189 |     |             mstore(0x40, m2)
  9190 |     |             mstore(0x60, m3)
  9191 |     |             mstore(0x80, m4)
  9192 |     |         }
  9193 |     |     }
  9194 |     | 
  9195 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  9196 |     |         bytes32 m0;
  9197 |     |         bytes32 m1;
  9198 |     |         bytes32 m2;
  9199 |     |         bytes32 m3;
  9200 |     |         bytes32 m4;
  9201 |     |         bytes32 m5;
  9202 |     |         bytes32 m6;
  9203 |     |         assembly {
  9204 |     |             function writeString(pos, w) {
  9205 |     |                 let length := 0
  9206 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9207 |     |                 mstore(pos, length)
  9208 |     |                 let shift := sub(256, shl(3, length))
  9209 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9210 |     |             }
  9211 |     |             m0 := mload(0x00)
  9212 |     |             m1 := mload(0x20)
  9213 |     |             m2 := mload(0x40)
  9214 |     |             m3 := mload(0x60)
  9215 |     |             m4 := mload(0x80)
  9216 |     |             m5 := mload(0xa0)
  9217 |     |             m6 := mload(0xc0)
  9218 |     |             // Selector of `log(uint256,uint256,uint256,string)`.
  9219 |     |             mstore(0x00, 0x59cfcbe3)
  9220 |     |             mstore(0x20, p0)
  9221 |     |             mstore(0x40, p1)
  9222 |     |             mstore(0x60, p2)
  9223 |     |             mstore(0x80, 0x80)
  9224 |     |             writeString(0xa0, p3)
  9225 |     |         }
  9226 |     |         _sendLogPayload(0x1c, 0xc4);
  9227 |     |         assembly {
  9228 |     |             mstore(0x00, m0)
  9229 |     |             mstore(0x20, m1)
  9230 |     |             mstore(0x40, m2)
  9231 |     |             mstore(0x60, m3)
  9232 |     |             mstore(0x80, m4)
  9233 |     |             mstore(0xa0, m5)
  9234 |     |             mstore(0xc0, m6)
  9235 |     |         }
  9236 |     |     }
  9237 |     | 
  9238 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {
  9239 |     |         bytes32 m0;
  9240 |     |         bytes32 m1;
  9241 |     |         bytes32 m2;
  9242 |     |         bytes32 m3;
  9243 |     |         bytes32 m4;
  9244 |     |         bytes32 m5;
  9245 |     |         bytes32 m6;
  9246 |     |         assembly {
  9247 |     |             function writeString(pos, w) {
  9248 |     |                 let length := 0
  9249 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9250 |     |                 mstore(pos, length)
  9251 |     |                 let shift := sub(256, shl(3, length))
  9252 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9253 |     |             }
  9254 |     |             m0 := mload(0x00)
  9255 |     |             m1 := mload(0x20)
  9256 |     |             m2 := mload(0x40)
  9257 |     |             m3 := mload(0x60)
  9258 |     |             m4 := mload(0x80)
  9259 |     |             m5 := mload(0xa0)
  9260 |     |             m6 := mload(0xc0)
  9261 |     |             // Selector of `log(uint256,uint256,string,address)`.
  9262 |     |             mstore(0x00, 0x42d21db7)
  9263 |     |             mstore(0x20, p0)
  9264 |     |             mstore(0x40, p1)
  9265 |     |             mstore(0x60, 0x80)
  9266 |     |             mstore(0x80, p3)
  9267 |     |             writeString(0xa0, p2)
  9268 |     |         }
  9269 |     |         _sendLogPayload(0x1c, 0xc4);
  9270 |     |         assembly {
  9271 |     |             mstore(0x00, m0)
  9272 |     |             mstore(0x20, m1)
  9273 |     |             mstore(0x40, m2)
  9274 |     |             mstore(0x60, m3)
  9275 |     |             mstore(0x80, m4)
  9276 |     |             mstore(0xa0, m5)
  9277 |     |             mstore(0xc0, m6)
  9278 |     |         }
  9279 |     |     }
  9280 |     | 
  9281 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  9282 |     |         bytes32 m0;
  9283 |     |         bytes32 m1;
  9284 |     |         bytes32 m2;
  9285 |     |         bytes32 m3;
  9286 |     |         bytes32 m4;
  9287 |     |         bytes32 m5;
  9288 |     |         bytes32 m6;
  9289 |     |         assembly {
  9290 |     |             function writeString(pos, w) {
  9291 |     |                 let length := 0
  9292 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9293 |     |                 mstore(pos, length)
  9294 |     |                 let shift := sub(256, shl(3, length))
  9295 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9296 |     |             }
  9297 |     |             m0 := mload(0x00)
  9298 |     |             m1 := mload(0x20)
  9299 |     |             m2 := mload(0x40)
  9300 |     |             m3 := mload(0x60)
  9301 |     |             m4 := mload(0x80)
  9302 |     |             m5 := mload(0xa0)
  9303 |     |             m6 := mload(0xc0)
  9304 |     |             // Selector of `log(uint256,uint256,string,bool)`.
  9305 |     |             mstore(0x00, 0x7af6ab25)
  9306 |     |             mstore(0x20, p0)
  9307 |     |             mstore(0x40, p1)
  9308 |     |             mstore(0x60, 0x80)
  9309 |     |             mstore(0x80, p3)
  9310 |     |             writeString(0xa0, p2)
  9311 |     |         }
  9312 |     |         _sendLogPayload(0x1c, 0xc4);
  9313 |     |         assembly {
  9314 |     |             mstore(0x00, m0)
  9315 |     |             mstore(0x20, m1)
  9316 |     |             mstore(0x40, m2)
  9317 |     |             mstore(0x60, m3)
  9318 |     |             mstore(0x80, m4)
  9319 |     |             mstore(0xa0, m5)
  9320 |     |             mstore(0xc0, m6)
  9321 |     |         }
  9322 |     |     }
  9323 |     | 
  9324 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  9325 |     |         bytes32 m0;
  9326 |     |         bytes32 m1;
  9327 |     |         bytes32 m2;
  9328 |     |         bytes32 m3;
  9329 |     |         bytes32 m4;
  9330 |     |         bytes32 m5;
  9331 |     |         bytes32 m6;
  9332 |     |         assembly {
  9333 |     |             function writeString(pos, w) {
  9334 |     |                 let length := 0
  9335 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9336 |     |                 mstore(pos, length)
  9337 |     |                 let shift := sub(256, shl(3, length))
  9338 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9339 |     |             }
  9340 |     |             m0 := mload(0x00)
  9341 |     |             m1 := mload(0x20)
  9342 |     |             m2 := mload(0x40)
  9343 |     |             m3 := mload(0x60)
  9344 |     |             m4 := mload(0x80)
  9345 |     |             m5 := mload(0xa0)
  9346 |     |             m6 := mload(0xc0)
  9347 |     |             // Selector of `log(uint256,uint256,string,uint256)`.
  9348 |     |             mstore(0x00, 0x5da297eb)
  9349 |     |             mstore(0x20, p0)
  9350 |     |             mstore(0x40, p1)
  9351 |     |             mstore(0x60, 0x80)
  9352 |     |             mstore(0x80, p3)
  9353 |     |             writeString(0xa0, p2)
  9354 |     |         }
  9355 |     |         _sendLogPayload(0x1c, 0xc4);
  9356 |     |         assembly {
  9357 |     |             mstore(0x00, m0)
  9358 |     |             mstore(0x20, m1)
  9359 |     |             mstore(0x40, m2)
  9360 |     |             mstore(0x60, m3)
  9361 |     |             mstore(0x80, m4)
  9362 |     |             mstore(0xa0, m5)
  9363 |     |             mstore(0xc0, m6)
  9364 |     |         }
  9365 |     |     }
  9366 |     | 
  9367 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  9368 |     |         bytes32 m0;
  9369 |     |         bytes32 m1;
  9370 |     |         bytes32 m2;
  9371 |     |         bytes32 m3;
  9372 |     |         bytes32 m4;
  9373 |     |         bytes32 m5;
  9374 |     |         bytes32 m6;
  9375 |     |         bytes32 m7;
  9376 |     |         bytes32 m8;
  9377 |     |         assembly {
  9378 |     |             function writeString(pos, w) {
  9379 |     |                 let length := 0
  9380 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9381 |     |                 mstore(pos, length)
  9382 |     |                 let shift := sub(256, shl(3, length))
  9383 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9384 |     |             }
  9385 |     |             m0 := mload(0x00)
  9386 |     |             m1 := mload(0x20)
  9387 |     |             m2 := mload(0x40)
  9388 |     |             m3 := mload(0x60)
  9389 |     |             m4 := mload(0x80)
  9390 |     |             m5 := mload(0xa0)
  9391 |     |             m6 := mload(0xc0)
  9392 |     |             m7 := mload(0xe0)
  9393 |     |             m8 := mload(0x100)
  9394 |     |             // Selector of `log(uint256,uint256,string,string)`.
  9395 |     |             mstore(0x00, 0x27d8afd2)
  9396 |     |             mstore(0x20, p0)
  9397 |     |             mstore(0x40, p1)
  9398 |     |             mstore(0x60, 0x80)
  9399 |     |             mstore(0x80, 0xc0)
  9400 |     |             writeString(0xa0, p2)
  9401 |     |             writeString(0xe0, p3)
  9402 |     |         }
  9403 |     |         _sendLogPayload(0x1c, 0x104);
  9404 |     |         assembly {
  9405 |     |             mstore(0x00, m0)
  9406 |     |             mstore(0x20, m1)
  9407 |     |             mstore(0x40, m2)
  9408 |     |             mstore(0x60, m3)
  9409 |     |             mstore(0x80, m4)
  9410 |     |             mstore(0xa0, m5)
  9411 |     |             mstore(0xc0, m6)
  9412 |     |             mstore(0xe0, m7)
  9413 |     |             mstore(0x100, m8)
  9414 |     |         }
  9415 |     |     }
  9416 |     | 
  9417 |     |     function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {
  9418 |     |         bytes32 m0;
  9419 |     |         bytes32 m1;
  9420 |     |         bytes32 m2;
  9421 |     |         bytes32 m3;
  9422 |     |         bytes32 m4;
  9423 |     |         bytes32 m5;
  9424 |     |         bytes32 m6;
  9425 |     |         assembly {
  9426 |     |             function writeString(pos, w) {
  9427 |     |                 let length := 0
  9428 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9429 |     |                 mstore(pos, length)
  9430 |     |                 let shift := sub(256, shl(3, length))
  9431 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9432 |     |             }
  9433 |     |             m0 := mload(0x00)
  9434 |     |             m1 := mload(0x20)
  9435 |     |             m2 := mload(0x40)
  9436 |     |             m3 := mload(0x60)
  9437 |     |             m4 := mload(0x80)
  9438 |     |             m5 := mload(0xa0)
  9439 |     |             m6 := mload(0xc0)
  9440 |     |             // Selector of `log(uint256,string,address,address)`.
  9441 |     |             mstore(0x00, 0x6168ed61)
  9442 |     |             mstore(0x20, p0)
  9443 |     |             mstore(0x40, 0x80)
  9444 |     |             mstore(0x60, p2)
  9445 |     |             mstore(0x80, p3)
  9446 |     |             writeString(0xa0, p1)
  9447 |     |         }
  9448 |     |         _sendLogPayload(0x1c, 0xc4);
  9449 |     |         assembly {
  9450 |     |             mstore(0x00, m0)
  9451 |     |             mstore(0x20, m1)
  9452 |     |             mstore(0x40, m2)
  9453 |     |             mstore(0x60, m3)
  9454 |     |             mstore(0x80, m4)
  9455 |     |             mstore(0xa0, m5)
  9456 |     |             mstore(0xc0, m6)
  9457 |     |         }
  9458 |     |     }
  9459 |     | 
  9460 |     |     function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {
  9461 |     |         bytes32 m0;
  9462 |     |         bytes32 m1;
  9463 |     |         bytes32 m2;
  9464 |     |         bytes32 m3;
  9465 |     |         bytes32 m4;
  9466 |     |         bytes32 m5;
  9467 |     |         bytes32 m6;
  9468 |     |         assembly {
  9469 |     |             function writeString(pos, w) {
  9470 |     |                 let length := 0
  9471 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9472 |     |                 mstore(pos, length)
  9473 |     |                 let shift := sub(256, shl(3, length))
  9474 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9475 |     |             }
  9476 |     |             m0 := mload(0x00)
  9477 |     |             m1 := mload(0x20)
  9478 |     |             m2 := mload(0x40)
  9479 |     |             m3 := mload(0x60)
  9480 |     |             m4 := mload(0x80)
  9481 |     |             m5 := mload(0xa0)
  9482 |     |             m6 := mload(0xc0)
  9483 |     |             // Selector of `log(uint256,string,address,bool)`.
  9484 |     |             mstore(0x00, 0x90c30a56)
  9485 |     |             mstore(0x20, p0)
  9486 |     |             mstore(0x40, 0x80)
  9487 |     |             mstore(0x60, p2)
  9488 |     |             mstore(0x80, p3)
  9489 |     |             writeString(0xa0, p1)
  9490 |     |         }
  9491 |     |         _sendLogPayload(0x1c, 0xc4);
  9492 |     |         assembly {
  9493 |     |             mstore(0x00, m0)
  9494 |     |             mstore(0x20, m1)
  9495 |     |             mstore(0x40, m2)
  9496 |     |             mstore(0x60, m3)
  9497 |     |             mstore(0x80, m4)
  9498 |     |             mstore(0xa0, m5)
  9499 |     |             mstore(0xc0, m6)
  9500 |     |         }
  9501 |     |     }
  9502 |     | 
  9503 |     |     function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {
  9504 |     |         bytes32 m0;
  9505 |     |         bytes32 m1;
  9506 |     |         bytes32 m2;
  9507 |     |         bytes32 m3;
  9508 |     |         bytes32 m4;
  9509 |     |         bytes32 m5;
  9510 |     |         bytes32 m6;
  9511 |     |         assembly {
  9512 |     |             function writeString(pos, w) {
  9513 |     |                 let length := 0
  9514 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9515 |     |                 mstore(pos, length)
  9516 |     |                 let shift := sub(256, shl(3, length))
  9517 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9518 |     |             }
  9519 |     |             m0 := mload(0x00)
  9520 |     |             m1 := mload(0x20)
  9521 |     |             m2 := mload(0x40)
  9522 |     |             m3 := mload(0x60)
  9523 |     |             m4 := mload(0x80)
  9524 |     |             m5 := mload(0xa0)
  9525 |     |             m6 := mload(0xc0)
  9526 |     |             // Selector of `log(uint256,string,address,uint256)`.
  9527 |     |             mstore(0x00, 0xe8d3018d)
  9528 |     |             mstore(0x20, p0)
  9529 |     |             mstore(0x40, 0x80)
  9530 |     |             mstore(0x60, p2)
  9531 |     |             mstore(0x80, p3)
  9532 |     |             writeString(0xa0, p1)
  9533 |     |         }
  9534 |     |         _sendLogPayload(0x1c, 0xc4);
  9535 |     |         assembly {
  9536 |     |             mstore(0x00, m0)
  9537 |     |             mstore(0x20, m1)
  9538 |     |             mstore(0x40, m2)
  9539 |     |             mstore(0x60, m3)
  9540 |     |             mstore(0x80, m4)
  9541 |     |             mstore(0xa0, m5)
  9542 |     |             mstore(0xc0, m6)
  9543 |     |         }
  9544 |     |     }
  9545 |     | 
  9546 |     |     function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  9547 |     |         bytes32 m0;
  9548 |     |         bytes32 m1;
  9549 |     |         bytes32 m2;
  9550 |     |         bytes32 m3;
  9551 |     |         bytes32 m4;
  9552 |     |         bytes32 m5;
  9553 |     |         bytes32 m6;
  9554 |     |         bytes32 m7;
  9555 |     |         bytes32 m8;
  9556 |     |         assembly {
  9557 |     |             function writeString(pos, w) {
  9558 |     |                 let length := 0
  9559 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9560 |     |                 mstore(pos, length)
  9561 |     |                 let shift := sub(256, shl(3, length))
  9562 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9563 |     |             }
  9564 |     |             m0 := mload(0x00)
  9565 |     |             m1 := mload(0x20)
  9566 |     |             m2 := mload(0x40)
  9567 |     |             m3 := mload(0x60)
  9568 |     |             m4 := mload(0x80)
  9569 |     |             m5 := mload(0xa0)
  9570 |     |             m6 := mload(0xc0)
  9571 |     |             m7 := mload(0xe0)
  9572 |     |             m8 := mload(0x100)
  9573 |     |             // Selector of `log(uint256,string,address,string)`.
  9574 |     |             mstore(0x00, 0x9c3adfa1)
  9575 |     |             mstore(0x20, p0)
  9576 |     |             mstore(0x40, 0x80)
  9577 |     |             mstore(0x60, p2)
  9578 |     |             mstore(0x80, 0xc0)
  9579 |     |             writeString(0xa0, p1)
  9580 |     |             writeString(0xe0, p3)
  9581 |     |         }
  9582 |     |         _sendLogPayload(0x1c, 0x104);
  9583 |     |         assembly {
  9584 |     |             mstore(0x00, m0)
  9585 |     |             mstore(0x20, m1)
  9586 |     |             mstore(0x40, m2)
  9587 |     |             mstore(0x60, m3)
  9588 |     |             mstore(0x80, m4)
  9589 |     |             mstore(0xa0, m5)
  9590 |     |             mstore(0xc0, m6)
  9591 |     |             mstore(0xe0, m7)
  9592 |     |             mstore(0x100, m8)
  9593 |     |         }
  9594 |     |     }
  9595 |     | 
  9596 |     |     function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {
  9597 |     |         bytes32 m0;
  9598 |     |         bytes32 m1;
  9599 |     |         bytes32 m2;
  9600 |     |         bytes32 m3;
  9601 |     |         bytes32 m4;
  9602 |     |         bytes32 m5;
  9603 |     |         bytes32 m6;
  9604 |     |         assembly {
  9605 |     |             function writeString(pos, w) {
  9606 |     |                 let length := 0
  9607 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9608 |     |                 mstore(pos, length)
  9609 |     |                 let shift := sub(256, shl(3, length))
  9610 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9611 |     |             }
  9612 |     |             m0 := mload(0x00)
  9613 |     |             m1 := mload(0x20)
  9614 |     |             m2 := mload(0x40)
  9615 |     |             m3 := mload(0x60)
  9616 |     |             m4 := mload(0x80)
  9617 |     |             m5 := mload(0xa0)
  9618 |     |             m6 := mload(0xc0)
  9619 |     |             // Selector of `log(uint256,string,bool,address)`.
  9620 |     |             mstore(0x00, 0xae2ec581)
  9621 |     |             mstore(0x20, p0)
  9622 |     |             mstore(0x40, 0x80)
  9623 |     |             mstore(0x60, p2)
  9624 |     |             mstore(0x80, p3)
  9625 |     |             writeString(0xa0, p1)
  9626 |     |         }
  9627 |     |         _sendLogPayload(0x1c, 0xc4);
  9628 |     |         assembly {
  9629 |     |             mstore(0x00, m0)
  9630 |     |             mstore(0x20, m1)
  9631 |     |             mstore(0x40, m2)
  9632 |     |             mstore(0x60, m3)
  9633 |     |             mstore(0x80, m4)
  9634 |     |             mstore(0xa0, m5)
  9635 |     |             mstore(0xc0, m6)
  9636 |     |         }
  9637 |     |     }
  9638 |     | 
  9639 |     |     function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {
  9640 |     |         bytes32 m0;
  9641 |     |         bytes32 m1;
  9642 |     |         bytes32 m2;
  9643 |     |         bytes32 m3;
  9644 |     |         bytes32 m4;
  9645 |     |         bytes32 m5;
  9646 |     |         bytes32 m6;
  9647 |     |         assembly {
  9648 |     |             function writeString(pos, w) {
  9649 |     |                 let length := 0
  9650 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9651 |     |                 mstore(pos, length)
  9652 |     |                 let shift := sub(256, shl(3, length))
  9653 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9654 |     |             }
  9655 |     |             m0 := mload(0x00)
  9656 |     |             m1 := mload(0x20)
  9657 |     |             m2 := mload(0x40)
  9658 |     |             m3 := mload(0x60)
  9659 |     |             m4 := mload(0x80)
  9660 |     |             m5 := mload(0xa0)
  9661 |     |             m6 := mload(0xc0)
  9662 |     |             // Selector of `log(uint256,string,bool,bool)`.
  9663 |     |             mstore(0x00, 0xba535d9c)
  9664 |     |             mstore(0x20, p0)
  9665 |     |             mstore(0x40, 0x80)
  9666 |     |             mstore(0x60, p2)
  9667 |     |             mstore(0x80, p3)
  9668 |     |             writeString(0xa0, p1)
  9669 |     |         }
  9670 |     |         _sendLogPayload(0x1c, 0xc4);
  9671 |     |         assembly {
  9672 |     |             mstore(0x00, m0)
  9673 |     |             mstore(0x20, m1)
  9674 |     |             mstore(0x40, m2)
  9675 |     |             mstore(0x60, m3)
  9676 |     |             mstore(0x80, m4)
  9677 |     |             mstore(0xa0, m5)
  9678 |     |             mstore(0xc0, m6)
  9679 |     |         }
  9680 |     |     }
  9681 |     | 
  9682 |     |     function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  9683 |     |         bytes32 m0;
  9684 |     |         bytes32 m1;
  9685 |     |         bytes32 m2;
  9686 |     |         bytes32 m3;
  9687 |     |         bytes32 m4;
  9688 |     |         bytes32 m5;
  9689 |     |         bytes32 m6;
  9690 |     |         assembly {
  9691 |     |             function writeString(pos, w) {
  9692 |     |                 let length := 0
  9693 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9694 |     |                 mstore(pos, length)
  9695 |     |                 let shift := sub(256, shl(3, length))
  9696 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9697 |     |             }
  9698 |     |             m0 := mload(0x00)
  9699 |     |             m1 := mload(0x20)
  9700 |     |             m2 := mload(0x40)
  9701 |     |             m3 := mload(0x60)
  9702 |     |             m4 := mload(0x80)
  9703 |     |             m5 := mload(0xa0)
  9704 |     |             m6 := mload(0xc0)
  9705 |     |             // Selector of `log(uint256,string,bool,uint256)`.
  9706 |     |             mstore(0x00, 0xcf009880)
  9707 |     |             mstore(0x20, p0)
  9708 |     |             mstore(0x40, 0x80)
  9709 |     |             mstore(0x60, p2)
  9710 |     |             mstore(0x80, p3)
  9711 |     |             writeString(0xa0, p1)
  9712 |     |         }
  9713 |     |         _sendLogPayload(0x1c, 0xc4);
  9714 |     |         assembly {
  9715 |     |             mstore(0x00, m0)
  9716 |     |             mstore(0x20, m1)
  9717 |     |             mstore(0x40, m2)
  9718 |     |             mstore(0x60, m3)
  9719 |     |             mstore(0x80, m4)
  9720 |     |             mstore(0xa0, m5)
  9721 |     |             mstore(0xc0, m6)
  9722 |     |         }
  9723 |     |     }
  9724 |     | 
  9725 |     |     function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  9726 |     |         bytes32 m0;
  9727 |     |         bytes32 m1;
  9728 |     |         bytes32 m2;
  9729 |     |         bytes32 m3;
  9730 |     |         bytes32 m4;
  9731 |     |         bytes32 m5;
  9732 |     |         bytes32 m6;
  9733 |     |         bytes32 m7;
  9734 |     |         bytes32 m8;
  9735 |     |         assembly {
  9736 |     |             function writeString(pos, w) {
  9737 |     |                 let length := 0
  9738 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9739 |     |                 mstore(pos, length)
  9740 |     |                 let shift := sub(256, shl(3, length))
  9741 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9742 |     |             }
  9743 |     |             m0 := mload(0x00)
  9744 |     |             m1 := mload(0x20)
  9745 |     |             m2 := mload(0x40)
  9746 |     |             m3 := mload(0x60)
  9747 |     |             m4 := mload(0x80)
  9748 |     |             m5 := mload(0xa0)
  9749 |     |             m6 := mload(0xc0)
  9750 |     |             m7 := mload(0xe0)
  9751 |     |             m8 := mload(0x100)
  9752 |     |             // Selector of `log(uint256,string,bool,string)`.
  9753 |     |             mstore(0x00, 0xd2d423cd)
  9754 |     |             mstore(0x20, p0)
  9755 |     |             mstore(0x40, 0x80)
  9756 |     |             mstore(0x60, p2)
  9757 |     |             mstore(0x80, 0xc0)
  9758 |     |             writeString(0xa0, p1)
  9759 |     |             writeString(0xe0, p3)
  9760 |     |         }
  9761 |     |         _sendLogPayload(0x1c, 0x104);
  9762 |     |         assembly {
  9763 |     |             mstore(0x00, m0)
  9764 |     |             mstore(0x20, m1)
  9765 |     |             mstore(0x40, m2)
  9766 |     |             mstore(0x60, m3)
  9767 |     |             mstore(0x80, m4)
  9768 |     |             mstore(0xa0, m5)
  9769 |     |             mstore(0xc0, m6)
  9770 |     |             mstore(0xe0, m7)
  9771 |     |             mstore(0x100, m8)
  9772 |     |         }
  9773 |     |     }
  9774 |     | 
  9775 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {
  9776 |     |         bytes32 m0;
  9777 |     |         bytes32 m1;
  9778 |     |         bytes32 m2;
  9779 |     |         bytes32 m3;
  9780 |     |         bytes32 m4;
  9781 |     |         bytes32 m5;
  9782 |     |         bytes32 m6;
  9783 |     |         assembly {
  9784 |     |             function writeString(pos, w) {
  9785 |     |                 let length := 0
  9786 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9787 |     |                 mstore(pos, length)
  9788 |     |                 let shift := sub(256, shl(3, length))
  9789 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9790 |     |             }
  9791 |     |             m0 := mload(0x00)
  9792 |     |             m1 := mload(0x20)
  9793 |     |             m2 := mload(0x40)
  9794 |     |             m3 := mload(0x60)
  9795 |     |             m4 := mload(0x80)
  9796 |     |             m5 := mload(0xa0)
  9797 |     |             m6 := mload(0xc0)
  9798 |     |             // Selector of `log(uint256,string,uint256,address)`.
  9799 |     |             mstore(0x00, 0x3b2279b4)
  9800 |     |             mstore(0x20, p0)
  9801 |     |             mstore(0x40, 0x80)
  9802 |     |             mstore(0x60, p2)
  9803 |     |             mstore(0x80, p3)
  9804 |     |             writeString(0xa0, p1)
  9805 |     |         }
  9806 |     |         _sendLogPayload(0x1c, 0xc4);
  9807 |     |         assembly {
  9808 |     |             mstore(0x00, m0)
  9809 |     |             mstore(0x20, m1)
  9810 |     |             mstore(0x40, m2)
  9811 |     |             mstore(0x60, m3)
  9812 |     |             mstore(0x80, m4)
  9813 |     |             mstore(0xa0, m5)
  9814 |     |             mstore(0xc0, m6)
  9815 |     |         }
  9816 |     |     }
  9817 |     | 
  9818 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  9819 |     |         bytes32 m0;
  9820 |     |         bytes32 m1;
  9821 |     |         bytes32 m2;
  9822 |     |         bytes32 m3;
  9823 |     |         bytes32 m4;
  9824 |     |         bytes32 m5;
  9825 |     |         bytes32 m6;
  9826 |     |         assembly {
  9827 |     |             function writeString(pos, w) {
  9828 |     |                 let length := 0
  9829 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9830 |     |                 mstore(pos, length)
  9831 |     |                 let shift := sub(256, shl(3, length))
  9832 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9833 |     |             }
  9834 |     |             m0 := mload(0x00)
  9835 |     |             m1 := mload(0x20)
  9836 |     |             m2 := mload(0x40)
  9837 |     |             m3 := mload(0x60)
  9838 |     |             m4 := mload(0x80)
  9839 |     |             m5 := mload(0xa0)
  9840 |     |             m6 := mload(0xc0)
  9841 |     |             // Selector of `log(uint256,string,uint256,bool)`.
  9842 |     |             mstore(0x00, 0x691a8f74)
  9843 |     |             mstore(0x20, p0)
  9844 |     |             mstore(0x40, 0x80)
  9845 |     |             mstore(0x60, p2)
  9846 |     |             mstore(0x80, p3)
  9847 |     |             writeString(0xa0, p1)
  9848 |     |         }
  9849 |     |         _sendLogPayload(0x1c, 0xc4);
  9850 |     |         assembly {
  9851 |     |             mstore(0x00, m0)
  9852 |     |             mstore(0x20, m1)
  9853 |     |             mstore(0x40, m2)
  9854 |     |             mstore(0x60, m3)
  9855 |     |             mstore(0x80, m4)
  9856 |     |             mstore(0xa0, m5)
  9857 |     |             mstore(0xc0, m6)
  9858 |     |         }
  9859 |     |     }
  9860 |     | 
  9861 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  9862 |     |         bytes32 m0;
  9863 |     |         bytes32 m1;
  9864 |     |         bytes32 m2;
  9865 |     |         bytes32 m3;
  9866 |     |         bytes32 m4;
  9867 |     |         bytes32 m5;
  9868 |     |         bytes32 m6;
  9869 |     |         assembly {
  9870 |     |             function writeString(pos, w) {
  9871 |     |                 let length := 0
  9872 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9873 |     |                 mstore(pos, length)
  9874 |     |                 let shift := sub(256, shl(3, length))
  9875 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9876 |     |             }
  9877 |     |             m0 := mload(0x00)
  9878 |     |             m1 := mload(0x20)
  9879 |     |             m2 := mload(0x40)
  9880 |     |             m3 := mload(0x60)
  9881 |     |             m4 := mload(0x80)
  9882 |     |             m5 := mload(0xa0)
  9883 |     |             m6 := mload(0xc0)
  9884 |     |             // Selector of `log(uint256,string,uint256,uint256)`.
  9885 |     |             mstore(0x00, 0x82c25b74)
  9886 |     |             mstore(0x20, p0)
  9887 |     |             mstore(0x40, 0x80)
  9888 |     |             mstore(0x60, p2)
  9889 |     |             mstore(0x80, p3)
  9890 |     |             writeString(0xa0, p1)
  9891 |     |         }
  9892 |     |         _sendLogPayload(0x1c, 0xc4);
  9893 |     |         assembly {
  9894 |     |             mstore(0x00, m0)
  9895 |     |             mstore(0x20, m1)
  9896 |     |             mstore(0x40, m2)
  9897 |     |             mstore(0x60, m3)
  9898 |     |             mstore(0x80, m4)
  9899 |     |             mstore(0xa0, m5)
  9900 |     |             mstore(0xc0, m6)
  9901 |     |         }
  9902 |     |     }
  9903 |     | 
  9904 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  9905 |     |         bytes32 m0;
  9906 |     |         bytes32 m1;
  9907 |     |         bytes32 m2;
  9908 |     |         bytes32 m3;
  9909 |     |         bytes32 m4;
  9910 |     |         bytes32 m5;
  9911 |     |         bytes32 m6;
  9912 |     |         bytes32 m7;
  9913 |     |         bytes32 m8;
  9914 |     |         assembly {
  9915 |     |             function writeString(pos, w) {
  9916 |     |                 let length := 0
  9917 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9918 |     |                 mstore(pos, length)
  9919 |     |                 let shift := sub(256, shl(3, length))
  9920 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9921 |     |             }
  9922 |     |             m0 := mload(0x00)
  9923 |     |             m1 := mload(0x20)
  9924 |     |             m2 := mload(0x40)
  9925 |     |             m3 := mload(0x60)
  9926 |     |             m4 := mload(0x80)
  9927 |     |             m5 := mload(0xa0)
  9928 |     |             m6 := mload(0xc0)
  9929 |     |             m7 := mload(0xe0)
  9930 |     |             m8 := mload(0x100)
  9931 |     |             // Selector of `log(uint256,string,uint256,string)`.
  9932 |     |             mstore(0x00, 0xb7b914ca)
  9933 |     |             mstore(0x20, p0)
  9934 |     |             mstore(0x40, 0x80)
  9935 |     |             mstore(0x60, p2)
  9936 |     |             mstore(0x80, 0xc0)
  9937 |     |             writeString(0xa0, p1)
  9938 |     |             writeString(0xe0, p3)
  9939 |     |         }
  9940 |     |         _sendLogPayload(0x1c, 0x104);
  9941 |     |         assembly {
  9942 |     |             mstore(0x00, m0)
  9943 |     |             mstore(0x20, m1)
  9944 |     |             mstore(0x40, m2)
  9945 |     |             mstore(0x60, m3)
  9946 |     |             mstore(0x80, m4)
  9947 |     |             mstore(0xa0, m5)
  9948 |     |             mstore(0xc0, m6)
  9949 |     |             mstore(0xe0, m7)
  9950 |     |             mstore(0x100, m8)
  9951 |     |         }
  9952 |     |     }
  9953 |     | 
  9954 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  9955 |     |         bytes32 m0;
  9956 |     |         bytes32 m1;
  9957 |     |         bytes32 m2;
  9958 |     |         bytes32 m3;
  9959 |     |         bytes32 m4;
  9960 |     |         bytes32 m5;
  9961 |     |         bytes32 m6;
  9962 |     |         bytes32 m7;
  9963 |     |         bytes32 m8;
  9964 |     |         assembly {
  9965 |     |             function writeString(pos, w) {
  9966 |     |                 let length := 0
  9967 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9968 |     |                 mstore(pos, length)
  9969 |     |                 let shift := sub(256, shl(3, length))
  9970 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9971 |     |             }
  9972 |     |             m0 := mload(0x00)
  9973 |     |             m1 := mload(0x20)
  9974 |     |             m2 := mload(0x40)
  9975 |     |             m3 := mload(0x60)
  9976 |     |             m4 := mload(0x80)
  9977 |     |             m5 := mload(0xa0)
  9978 |     |             m6 := mload(0xc0)
  9979 |     |             m7 := mload(0xe0)
  9980 |     |             m8 := mload(0x100)
  9981 |     |             // Selector of `log(uint256,string,string,address)`.
  9982 |     |             mstore(0x00, 0xd583c602)
  9983 |     |             mstore(0x20, p0)
  9984 |     |             mstore(0x40, 0x80)
  9985 |     |             mstore(0x60, 0xc0)
  9986 |     |             mstore(0x80, p3)
  9987 |     |             writeString(0xa0, p1)
  9988 |     |             writeString(0xe0, p2)
  9989 |     |         }
  9990 |     |         _sendLogPayload(0x1c, 0x104);
  9991 |     |         assembly {
  9992 |     |             mstore(0x00, m0)
  9993 |     |             mstore(0x20, m1)
  9994 |     |             mstore(0x40, m2)
  9995 |     |             mstore(0x60, m3)
  9996 |     |             mstore(0x80, m4)
  9997 |     |             mstore(0xa0, m5)
  9998 |     |             mstore(0xc0, m6)
  9999 |     |             mstore(0xe0, m7)
 10000 |     |             mstore(0x100, m8)
 10001 |     |         }
 10002 |     |     }
 10003 |     | 
 10004 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 10005 |     |         bytes32 m0;
 10006 |     |         bytes32 m1;
 10007 |     |         bytes32 m2;
 10008 |     |         bytes32 m3;
 10009 |     |         bytes32 m4;
 10010 |     |         bytes32 m5;
 10011 |     |         bytes32 m6;
 10012 |     |         bytes32 m7;
 10013 |     |         bytes32 m8;
 10014 |     |         assembly {
 10015 |     |             function writeString(pos, w) {
 10016 |     |                 let length := 0
 10017 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10018 |     |                 mstore(pos, length)
 10019 |     |                 let shift := sub(256, shl(3, length))
 10020 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10021 |     |             }
 10022 |     |             m0 := mload(0x00)
 10023 |     |             m1 := mload(0x20)
 10024 |     |             m2 := mload(0x40)
 10025 |     |             m3 := mload(0x60)
 10026 |     |             m4 := mload(0x80)
 10027 |     |             m5 := mload(0xa0)
 10028 |     |             m6 := mload(0xc0)
 10029 |     |             m7 := mload(0xe0)
 10030 |     |             m8 := mload(0x100)
 10031 |     |             // Selector of `log(uint256,string,string,bool)`.
 10032 |     |             mstore(0x00, 0xb3a6b6bd)
 10033 |     |             mstore(0x20, p0)
 10034 |     |             mstore(0x40, 0x80)
 10035 |     |             mstore(0x60, 0xc0)
 10036 |     |             mstore(0x80, p3)
 10037 |     |             writeString(0xa0, p1)
 10038 |     |             writeString(0xe0, p2)
 10039 |     |         }
 10040 |     |         _sendLogPayload(0x1c, 0x104);
 10041 |     |         assembly {
 10042 |     |             mstore(0x00, m0)
 10043 |     |             mstore(0x20, m1)
 10044 |     |             mstore(0x40, m2)
 10045 |     |             mstore(0x60, m3)
 10046 |     |             mstore(0x80, m4)
 10047 |     |             mstore(0xa0, m5)
 10048 |     |             mstore(0xc0, m6)
 10049 |     |             mstore(0xe0, m7)
 10050 |     |             mstore(0x100, m8)
 10051 |     |         }
 10052 |     |     }
 10053 |     | 
 10054 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 10055 |     |         bytes32 m0;
 10056 |     |         bytes32 m1;
 10057 |     |         bytes32 m2;
 10058 |     |         bytes32 m3;
 10059 |     |         bytes32 m4;
 10060 |     |         bytes32 m5;
 10061 |     |         bytes32 m6;
 10062 |     |         bytes32 m7;
 10063 |     |         bytes32 m8;
 10064 |     |         assembly {
 10065 |     |             function writeString(pos, w) {
 10066 |     |                 let length := 0
 10067 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10068 |     |                 mstore(pos, length)
 10069 |     |                 let shift := sub(256, shl(3, length))
 10070 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10071 |     |             }
 10072 |     |             m0 := mload(0x00)
 10073 |     |             m1 := mload(0x20)
 10074 |     |             m2 := mload(0x40)
 10075 |     |             m3 := mload(0x60)
 10076 |     |             m4 := mload(0x80)
 10077 |     |             m5 := mload(0xa0)
 10078 |     |             m6 := mload(0xc0)
 10079 |     |             m7 := mload(0xe0)
 10080 |     |             m8 := mload(0x100)
 10081 |     |             // Selector of `log(uint256,string,string,uint256)`.
 10082 |     |             mstore(0x00, 0xb028c9bd)
 10083 |     |             mstore(0x20, p0)
 10084 |     |             mstore(0x40, 0x80)
 10085 |     |             mstore(0x60, 0xc0)
 10086 |     |             mstore(0x80, p3)
 10087 |     |             writeString(0xa0, p1)
 10088 |     |             writeString(0xe0, p2)
 10089 |     |         }
 10090 |     |         _sendLogPayload(0x1c, 0x104);
 10091 |     |         assembly {
 10092 |     |             mstore(0x00, m0)
 10093 |     |             mstore(0x20, m1)
 10094 |     |             mstore(0x40, m2)
 10095 |     |             mstore(0x60, m3)
 10096 |     |             mstore(0x80, m4)
 10097 |     |             mstore(0xa0, m5)
 10098 |     |             mstore(0xc0, m6)
 10099 |     |             mstore(0xe0, m7)
 10100 |     |             mstore(0x100, m8)
 10101 |     |         }
 10102 |     |     }
 10103 |     | 
 10104 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 10105 |     |         bytes32 m0;
 10106 |     |         bytes32 m1;
 10107 |     |         bytes32 m2;
 10108 |     |         bytes32 m3;
 10109 |     |         bytes32 m4;
 10110 |     |         bytes32 m5;
 10111 |     |         bytes32 m6;
 10112 |     |         bytes32 m7;
 10113 |     |         bytes32 m8;
 10114 |     |         bytes32 m9;
 10115 |     |         bytes32 m10;
 10116 |     |         assembly {
 10117 |     |             function writeString(pos, w) {
 10118 |     |                 let length := 0
 10119 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10120 |     |                 mstore(pos, length)
 10121 |     |                 let shift := sub(256, shl(3, length))
 10122 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10123 |     |             }
 10124 |     |             m0 := mload(0x00)
 10125 |     |             m1 := mload(0x20)
 10126 |     |             m2 := mload(0x40)
 10127 |     |             m3 := mload(0x60)
 10128 |     |             m4 := mload(0x80)
 10129 |     |             m5 := mload(0xa0)
 10130 |     |             m6 := mload(0xc0)
 10131 |     |             m7 := mload(0xe0)
 10132 |     |             m8 := mload(0x100)
 10133 |     |             m9 := mload(0x120)
 10134 |     |             m10 := mload(0x140)
 10135 |     |             // Selector of `log(uint256,string,string,string)`.
 10136 |     |             mstore(0x00, 0x21ad0683)
 10137 |     |             mstore(0x20, p0)
 10138 |     |             mstore(0x40, 0x80)
 10139 |     |             mstore(0x60, 0xc0)
 10140 |     |             mstore(0x80, 0x100)
 10141 |     |             writeString(0xa0, p1)
 10142 |     |             writeString(0xe0, p2)
 10143 |     |             writeString(0x120, p3)
 10144 |     |         }
 10145 |     |         _sendLogPayload(0x1c, 0x144);
 10146 |     |         assembly {
 10147 |     |             mstore(0x00, m0)
 10148 |     |             mstore(0x20, m1)
 10149 |     |             mstore(0x40, m2)
 10150 |     |             mstore(0x60, m3)
 10151 |     |             mstore(0x80, m4)
 10152 |     |             mstore(0xa0, m5)
 10153 |     |             mstore(0xc0, m6)
 10154 |     |             mstore(0xe0, m7)
 10155 |     |             mstore(0x100, m8)
 10156 |     |             mstore(0x120, m9)
 10157 |     |             mstore(0x140, m10)
 10158 |     |         }
 10159 |     |     }
 10160 |     | 
 10161 |     |     function log(bytes32 p0, address p1, address p2, address p3) internal pure {
 10162 |     |         bytes32 m0;
 10163 |     |         bytes32 m1;
 10164 |     |         bytes32 m2;
 10165 |     |         bytes32 m3;
 10166 |     |         bytes32 m4;
 10167 |     |         bytes32 m5;
 10168 |     |         bytes32 m6;
 10169 |     |         assembly {
 10170 |     |             function writeString(pos, w) {
 10171 |     |                 let length := 0
 10172 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10173 |     |                 mstore(pos, length)
 10174 |     |                 let shift := sub(256, shl(3, length))
 10175 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10176 |     |             }
 10177 |     |             m0 := mload(0x00)
 10178 |     |             m1 := mload(0x20)
 10179 |     |             m2 := mload(0x40)
 10180 |     |             m3 := mload(0x60)
 10181 |     |             m4 := mload(0x80)
 10182 |     |             m5 := mload(0xa0)
 10183 |     |             m6 := mload(0xc0)
 10184 |     |             // Selector of `log(string,address,address,address)`.
 10185 |     |             mstore(0x00, 0xed8f28f6)
 10186 |     |             mstore(0x20, 0x80)
 10187 |     |             mstore(0x40, p1)
 10188 |     |             mstore(0x60, p2)
 10189 |     |             mstore(0x80, p3)
 10190 |     |             writeString(0xa0, p0)
 10191 |     |         }
 10192 |     |         _sendLogPayload(0x1c, 0xc4);
 10193 |     |         assembly {
 10194 |     |             mstore(0x00, m0)
 10195 |     |             mstore(0x20, m1)
 10196 |     |             mstore(0x40, m2)
 10197 |     |             mstore(0x60, m3)
 10198 |     |             mstore(0x80, m4)
 10199 |     |             mstore(0xa0, m5)
 10200 |     |             mstore(0xc0, m6)
 10201 |     |         }
 10202 |     |     }
 10203 |     | 
 10204 |     |     function log(bytes32 p0, address p1, address p2, bool p3) internal pure {
 10205 |     |         bytes32 m0;
 10206 |     |         bytes32 m1;
 10207 |     |         bytes32 m2;
 10208 |     |         bytes32 m3;
 10209 |     |         bytes32 m4;
 10210 |     |         bytes32 m5;
 10211 |     |         bytes32 m6;
 10212 |     |         assembly {
 10213 |     |             function writeString(pos, w) {
 10214 |     |                 let length := 0
 10215 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10216 |     |                 mstore(pos, length)
 10217 |     |                 let shift := sub(256, shl(3, length))
 10218 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10219 |     |             }
 10220 |     |             m0 := mload(0x00)
 10221 |     |             m1 := mload(0x20)
 10222 |     |             m2 := mload(0x40)
 10223 |     |             m3 := mload(0x60)
 10224 |     |             m4 := mload(0x80)
 10225 |     |             m5 := mload(0xa0)
 10226 |     |             m6 := mload(0xc0)
 10227 |     |             // Selector of `log(string,address,address,bool)`.
 10228 |     |             mstore(0x00, 0xb59dbd60)
 10229 |     |             mstore(0x20, 0x80)
 10230 |     |             mstore(0x40, p1)
 10231 |     |             mstore(0x60, p2)
 10232 |     |             mstore(0x80, p3)
 10233 |     |             writeString(0xa0, p0)
 10234 |     |         }
 10235 |     |         _sendLogPayload(0x1c, 0xc4);
 10236 |     |         assembly {
 10237 |     |             mstore(0x00, m0)
 10238 |     |             mstore(0x20, m1)
 10239 |     |             mstore(0x40, m2)
 10240 |     |             mstore(0x60, m3)
 10241 |     |             mstore(0x80, m4)
 10242 |     |             mstore(0xa0, m5)
 10243 |     |             mstore(0xc0, m6)
 10244 |     |         }
 10245 |     |     }
 10246 |     | 
 10247 |     |     function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {
 10248 |     |         bytes32 m0;
 10249 |     |         bytes32 m1;
 10250 |     |         bytes32 m2;
 10251 |     |         bytes32 m3;
 10252 |     |         bytes32 m4;
 10253 |     |         bytes32 m5;
 10254 |     |         bytes32 m6;
 10255 |     |         assembly {
 10256 |     |             function writeString(pos, w) {
 10257 |     |                 let length := 0
 10258 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10259 |     |                 mstore(pos, length)
 10260 |     |                 let shift := sub(256, shl(3, length))
 10261 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10262 |     |             }
 10263 |     |             m0 := mload(0x00)
 10264 |     |             m1 := mload(0x20)
 10265 |     |             m2 := mload(0x40)
 10266 |     |             m3 := mload(0x60)
 10267 |     |             m4 := mload(0x80)
 10268 |     |             m5 := mload(0xa0)
 10269 |     |             m6 := mload(0xc0)
 10270 |     |             // Selector of `log(string,address,address,uint256)`.
 10271 |     |             mstore(0x00, 0x8ef3f399)
 10272 |     |             mstore(0x20, 0x80)
 10273 |     |             mstore(0x40, p1)
 10274 |     |             mstore(0x60, p2)
 10275 |     |             mstore(0x80, p3)
 10276 |     |             writeString(0xa0, p0)
 10277 |     |         }
 10278 |     |         _sendLogPayload(0x1c, 0xc4);
 10279 |     |         assembly {
 10280 |     |             mstore(0x00, m0)
 10281 |     |             mstore(0x20, m1)
 10282 |     |             mstore(0x40, m2)
 10283 |     |             mstore(0x60, m3)
 10284 |     |             mstore(0x80, m4)
 10285 |     |             mstore(0xa0, m5)
 10286 |     |             mstore(0xc0, m6)
 10287 |     |         }
 10288 |     |     }
 10289 |     | 
 10290 |     |     function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {
 10291 |     |         bytes32 m0;
 10292 |     |         bytes32 m1;
 10293 |     |         bytes32 m2;
 10294 |     |         bytes32 m3;
 10295 |     |         bytes32 m4;
 10296 |     |         bytes32 m5;
 10297 |     |         bytes32 m6;
 10298 |     |         bytes32 m7;
 10299 |     |         bytes32 m8;
 10300 |     |         assembly {
 10301 |     |             function writeString(pos, w) {
 10302 |     |                 let length := 0
 10303 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10304 |     |                 mstore(pos, length)
 10305 |     |                 let shift := sub(256, shl(3, length))
 10306 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10307 |     |             }
 10308 |     |             m0 := mload(0x00)
 10309 |     |             m1 := mload(0x20)
 10310 |     |             m2 := mload(0x40)
 10311 |     |             m3 := mload(0x60)
 10312 |     |             m4 := mload(0x80)
 10313 |     |             m5 := mload(0xa0)
 10314 |     |             m6 := mload(0xc0)
 10315 |     |             m7 := mload(0xe0)
 10316 |     |             m8 := mload(0x100)
 10317 |     |             // Selector of `log(string,address,address,string)`.
 10318 |     |             mstore(0x00, 0x800a1c67)
 10319 |     |             mstore(0x20, 0x80)
 10320 |     |             mstore(0x40, p1)
 10321 |     |             mstore(0x60, p2)
 10322 |     |             mstore(0x80, 0xc0)
 10323 |     |             writeString(0xa0, p0)
 10324 |     |             writeString(0xe0, p3)
 10325 |     |         }
 10326 |     |         _sendLogPayload(0x1c, 0x104);
 10327 |     |         assembly {
 10328 |     |             mstore(0x00, m0)
 10329 |     |             mstore(0x20, m1)
 10330 |     |             mstore(0x40, m2)
 10331 |     |             mstore(0x60, m3)
 10332 |     |             mstore(0x80, m4)
 10333 |     |             mstore(0xa0, m5)
 10334 |     |             mstore(0xc0, m6)
 10335 |     |             mstore(0xe0, m7)
 10336 |     |             mstore(0x100, m8)
 10337 |     |         }
 10338 |     |     }
 10339 |     | 
 10340 |     |     function log(bytes32 p0, address p1, bool p2, address p3) internal pure {
 10341 |     |         bytes32 m0;
 10342 |     |         bytes32 m1;
 10343 |     |         bytes32 m2;
 10344 |     |         bytes32 m3;
 10345 |     |         bytes32 m4;
 10346 |     |         bytes32 m5;
 10347 |     |         bytes32 m6;
 10348 |     |         assembly {
 10349 |     |             function writeString(pos, w) {
 10350 |     |                 let length := 0
 10351 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10352 |     |                 mstore(pos, length)
 10353 |     |                 let shift := sub(256, shl(3, length))
 10354 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10355 |     |             }
 10356 |     |             m0 := mload(0x00)
 10357 |     |             m1 := mload(0x20)
 10358 |     |             m2 := mload(0x40)
 10359 |     |             m3 := mload(0x60)
 10360 |     |             m4 := mload(0x80)
 10361 |     |             m5 := mload(0xa0)
 10362 |     |             m6 := mload(0xc0)
 10363 |     |             // Selector of `log(string,address,bool,address)`.
 10364 |     |             mstore(0x00, 0x223603bd)
 10365 |     |             mstore(0x20, 0x80)
 10366 |     |             mstore(0x40, p1)
 10367 |     |             mstore(0x60, p2)
 10368 |     |             mstore(0x80, p3)
 10369 |     |             writeString(0xa0, p0)
 10370 |     |         }
 10371 |     |         _sendLogPayload(0x1c, 0xc4);
 10372 |     |         assembly {
 10373 |     |             mstore(0x00, m0)
 10374 |     |             mstore(0x20, m1)
 10375 |     |             mstore(0x40, m2)
 10376 |     |             mstore(0x60, m3)
 10377 |     |             mstore(0x80, m4)
 10378 |     |             mstore(0xa0, m5)
 10379 |     |             mstore(0xc0, m6)
 10380 |     |         }
 10381 |     |     }
 10382 |     | 
 10383 |     |     function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {
 10384 |     |         bytes32 m0;
 10385 |     |         bytes32 m1;
 10386 |     |         bytes32 m2;
 10387 |     |         bytes32 m3;
 10388 |     |         bytes32 m4;
 10389 |     |         bytes32 m5;
 10390 |     |         bytes32 m6;
 10391 |     |         assembly {
 10392 |     |             function writeString(pos, w) {
 10393 |     |                 let length := 0
 10394 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10395 |     |                 mstore(pos, length)
 10396 |     |                 let shift := sub(256, shl(3, length))
 10397 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10398 |     |             }
 10399 |     |             m0 := mload(0x00)
 10400 |     |             m1 := mload(0x20)
 10401 |     |             m2 := mload(0x40)
 10402 |     |             m3 := mload(0x60)
 10403 |     |             m4 := mload(0x80)
 10404 |     |             m5 := mload(0xa0)
 10405 |     |             m6 := mload(0xc0)
 10406 |     |             // Selector of `log(string,address,bool,bool)`.
 10407 |     |             mstore(0x00, 0x79884c2b)
 10408 |     |             mstore(0x20, 0x80)
 10409 |     |             mstore(0x40, p1)
 10410 |     |             mstore(0x60, p2)
 10411 |     |             mstore(0x80, p3)
 10412 |     |             writeString(0xa0, p0)
 10413 |     |         }
 10414 |     |         _sendLogPayload(0x1c, 0xc4);
 10415 |     |         assembly {
 10416 |     |             mstore(0x00, m0)
 10417 |     |             mstore(0x20, m1)
 10418 |     |             mstore(0x40, m2)
 10419 |     |             mstore(0x60, m3)
 10420 |     |             mstore(0x80, m4)
 10421 |     |             mstore(0xa0, m5)
 10422 |     |             mstore(0xc0, m6)
 10423 |     |         }
 10424 |     |     }
 10425 |     | 
 10426 |     |     function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {
 10427 |     |         bytes32 m0;
 10428 |     |         bytes32 m1;
 10429 |     |         bytes32 m2;
 10430 |     |         bytes32 m3;
 10431 |     |         bytes32 m4;
 10432 |     |         bytes32 m5;
 10433 |     |         bytes32 m6;
 10434 |     |         assembly {
 10435 |     |             function writeString(pos, w) {
 10436 |     |                 let length := 0
 10437 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10438 |     |                 mstore(pos, length)
 10439 |     |                 let shift := sub(256, shl(3, length))
 10440 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10441 |     |             }
 10442 |     |             m0 := mload(0x00)
 10443 |     |             m1 := mload(0x20)
 10444 |     |             m2 := mload(0x40)
 10445 |     |             m3 := mload(0x60)
 10446 |     |             m4 := mload(0x80)
 10447 |     |             m5 := mload(0xa0)
 10448 |     |             m6 := mload(0xc0)
 10449 |     |             // Selector of `log(string,address,bool,uint256)`.
 10450 |     |             mstore(0x00, 0x3e9f866a)
 10451 |     |             mstore(0x20, 0x80)
 10452 |     |             mstore(0x40, p1)
 10453 |     |             mstore(0x60, p2)
 10454 |     |             mstore(0x80, p3)
 10455 |     |             writeString(0xa0, p0)
 10456 |     |         }
 10457 |     |         _sendLogPayload(0x1c, 0xc4);
 10458 |     |         assembly {
 10459 |     |             mstore(0x00, m0)
 10460 |     |             mstore(0x20, m1)
 10461 |     |             mstore(0x40, m2)
 10462 |     |             mstore(0x60, m3)
 10463 |     |             mstore(0x80, m4)
 10464 |     |             mstore(0xa0, m5)
 10465 |     |             mstore(0xc0, m6)
 10466 |     |         }
 10467 |     |     }
 10468 |     | 
 10469 |     |     function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {
 10470 |     |         bytes32 m0;
 10471 |     |         bytes32 m1;
 10472 |     |         bytes32 m2;
 10473 |     |         bytes32 m3;
 10474 |     |         bytes32 m4;
 10475 |     |         bytes32 m5;
 10476 |     |         bytes32 m6;
 10477 |     |         bytes32 m7;
 10478 |     |         bytes32 m8;
 10479 |     |         assembly {
 10480 |     |             function writeString(pos, w) {
 10481 |     |                 let length := 0
 10482 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10483 |     |                 mstore(pos, length)
 10484 |     |                 let shift := sub(256, shl(3, length))
 10485 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10486 |     |             }
 10487 |     |             m0 := mload(0x00)
 10488 |     |             m1 := mload(0x20)
 10489 |     |             m2 := mload(0x40)
 10490 |     |             m3 := mload(0x60)
 10491 |     |             m4 := mload(0x80)
 10492 |     |             m5 := mload(0xa0)
 10493 |     |             m6 := mload(0xc0)
 10494 |     |             m7 := mload(0xe0)
 10495 |     |             m8 := mload(0x100)
 10496 |     |             // Selector of `log(string,address,bool,string)`.
 10497 |     |             mstore(0x00, 0x0454c079)
 10498 |     |             mstore(0x20, 0x80)
 10499 |     |             mstore(0x40, p1)
 10500 |     |             mstore(0x60, p2)
 10501 |     |             mstore(0x80, 0xc0)
 10502 |     |             writeString(0xa0, p0)
 10503 |     |             writeString(0xe0, p3)
 10504 |     |         }
 10505 |     |         _sendLogPayload(0x1c, 0x104);
 10506 |     |         assembly {
 10507 |     |             mstore(0x00, m0)
 10508 |     |             mstore(0x20, m1)
 10509 |     |             mstore(0x40, m2)
 10510 |     |             mstore(0x60, m3)
 10511 |     |             mstore(0x80, m4)
 10512 |     |             mstore(0xa0, m5)
 10513 |     |             mstore(0xc0, m6)
 10514 |     |             mstore(0xe0, m7)
 10515 |     |             mstore(0x100, m8)
 10516 |     |         }
 10517 |     |     }
 10518 |     | 
 10519 |     |     function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {
 10520 |     |         bytes32 m0;
 10521 |     |         bytes32 m1;
 10522 |     |         bytes32 m2;
 10523 |     |         bytes32 m3;
 10524 |     |         bytes32 m4;
 10525 |     |         bytes32 m5;
 10526 |     |         bytes32 m6;
 10527 |     |         assembly {
 10528 |     |             function writeString(pos, w) {
 10529 |     |                 let length := 0
 10530 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10531 |     |                 mstore(pos, length)
 10532 |     |                 let shift := sub(256, shl(3, length))
 10533 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10534 |     |             }
 10535 |     |             m0 := mload(0x00)
 10536 |     |             m1 := mload(0x20)
 10537 |     |             m2 := mload(0x40)
 10538 |     |             m3 := mload(0x60)
 10539 |     |             m4 := mload(0x80)
 10540 |     |             m5 := mload(0xa0)
 10541 |     |             m6 := mload(0xc0)
 10542 |     |             // Selector of `log(string,address,uint256,address)`.
 10543 |     |             mstore(0x00, 0x63fb8bc5)
 10544 |     |             mstore(0x20, 0x80)
 10545 |     |             mstore(0x40, p1)
 10546 |     |             mstore(0x60, p2)
 10547 |     |             mstore(0x80, p3)
 10548 |     |             writeString(0xa0, p0)
 10549 |     |         }
 10550 |     |         _sendLogPayload(0x1c, 0xc4);
 10551 |     |         assembly {
 10552 |     |             mstore(0x00, m0)
 10553 |     |             mstore(0x20, m1)
 10554 |     |             mstore(0x40, m2)
 10555 |     |             mstore(0x60, m3)
 10556 |     |             mstore(0x80, m4)
 10557 |     |             mstore(0xa0, m5)
 10558 |     |             mstore(0xc0, m6)
 10559 |     |         }
 10560 |     |     }
 10561 |     | 
 10562 |     |     function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {
 10563 |     |         bytes32 m0;
 10564 |     |         bytes32 m1;
 10565 |     |         bytes32 m2;
 10566 |     |         bytes32 m3;
 10567 |     |         bytes32 m4;
 10568 |     |         bytes32 m5;
 10569 |     |         bytes32 m6;
 10570 |     |         assembly {
 10571 |     |             function writeString(pos, w) {
 10572 |     |                 let length := 0
 10573 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10574 |     |                 mstore(pos, length)
 10575 |     |                 let shift := sub(256, shl(3, length))
 10576 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10577 |     |             }
 10578 |     |             m0 := mload(0x00)
 10579 |     |             m1 := mload(0x20)
 10580 |     |             m2 := mload(0x40)
 10581 |     |             m3 := mload(0x60)
 10582 |     |             m4 := mload(0x80)
 10583 |     |             m5 := mload(0xa0)
 10584 |     |             m6 := mload(0xc0)
 10585 |     |             // Selector of `log(string,address,uint256,bool)`.
 10586 |     |             mstore(0x00, 0xfc4845f0)
 10587 |     |             mstore(0x20, 0x80)
 10588 |     |             mstore(0x40, p1)
 10589 |     |             mstore(0x60, p2)
 10590 |     |             mstore(0x80, p3)
 10591 |     |             writeString(0xa0, p0)
 10592 |     |         }
 10593 |     |         _sendLogPayload(0x1c, 0xc4);
 10594 |     |         assembly {
 10595 |     |             mstore(0x00, m0)
 10596 |     |             mstore(0x20, m1)
 10597 |     |             mstore(0x40, m2)
 10598 |     |             mstore(0x60, m3)
 10599 |     |             mstore(0x80, m4)
 10600 |     |             mstore(0xa0, m5)
 10601 |     |             mstore(0xc0, m6)
 10602 |     |         }
 10603 |     |     }
 10604 |     | 
 10605 |     |     function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {
 10606 |     |         bytes32 m0;
 10607 |     |         bytes32 m1;
 10608 |     |         bytes32 m2;
 10609 |     |         bytes32 m3;
 10610 |     |         bytes32 m4;
 10611 |     |         bytes32 m5;
 10612 |     |         bytes32 m6;
 10613 |     |         assembly {
 10614 |     |             function writeString(pos, w) {
 10615 |     |                 let length := 0
 10616 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10617 |     |                 mstore(pos, length)
 10618 |     |                 let shift := sub(256, shl(3, length))
 10619 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10620 |     |             }
 10621 |     |             m0 := mload(0x00)
 10622 |     |             m1 := mload(0x20)
 10623 |     |             m2 := mload(0x40)
 10624 |     |             m3 := mload(0x60)
 10625 |     |             m4 := mload(0x80)
 10626 |     |             m5 := mload(0xa0)
 10627 |     |             m6 := mload(0xc0)
 10628 |     |             // Selector of `log(string,address,uint256,uint256)`.
 10629 |     |             mstore(0x00, 0xf8f51b1e)
 10630 |     |             mstore(0x20, 0x80)
 10631 |     |             mstore(0x40, p1)
 10632 |     |             mstore(0x60, p2)
 10633 |     |             mstore(0x80, p3)
 10634 |     |             writeString(0xa0, p0)
 10635 |     |         }
 10636 |     |         _sendLogPayload(0x1c, 0xc4);
 10637 |     |         assembly {
 10638 |     |             mstore(0x00, m0)
 10639 |     |             mstore(0x20, m1)
 10640 |     |             mstore(0x40, m2)
 10641 |     |             mstore(0x60, m3)
 10642 |     |             mstore(0x80, m4)
 10643 |     |             mstore(0xa0, m5)
 10644 |     |             mstore(0xc0, m6)
 10645 |     |         }
 10646 |     |     }
 10647 |     | 
 10648 |     |     function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {
 10649 |     |         bytes32 m0;
 10650 |     |         bytes32 m1;
 10651 |     |         bytes32 m2;
 10652 |     |         bytes32 m3;
 10653 |     |         bytes32 m4;
 10654 |     |         bytes32 m5;
 10655 |     |         bytes32 m6;
 10656 |     |         bytes32 m7;
 10657 |     |         bytes32 m8;
 10658 |     |         assembly {
 10659 |     |             function writeString(pos, w) {
 10660 |     |                 let length := 0
 10661 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10662 |     |                 mstore(pos, length)
 10663 |     |                 let shift := sub(256, shl(3, length))
 10664 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10665 |     |             }
 10666 |     |             m0 := mload(0x00)
 10667 |     |             m1 := mload(0x20)
 10668 |     |             m2 := mload(0x40)
 10669 |     |             m3 := mload(0x60)
 10670 |     |             m4 := mload(0x80)
 10671 |     |             m5 := mload(0xa0)
 10672 |     |             m6 := mload(0xc0)
 10673 |     |             m7 := mload(0xe0)
 10674 |     |             m8 := mload(0x100)
 10675 |     |             // Selector of `log(string,address,uint256,string)`.
 10676 |     |             mstore(0x00, 0x5a477632)
 10677 |     |             mstore(0x20, 0x80)
 10678 |     |             mstore(0x40, p1)
 10679 |     |             mstore(0x60, p2)
 10680 |     |             mstore(0x80, 0xc0)
 10681 |     |             writeString(0xa0, p0)
 10682 |     |             writeString(0xe0, p3)
 10683 |     |         }
 10684 |     |         _sendLogPayload(0x1c, 0x104);
 10685 |     |         assembly {
 10686 |     |             mstore(0x00, m0)
 10687 |     |             mstore(0x20, m1)
 10688 |     |             mstore(0x40, m2)
 10689 |     |             mstore(0x60, m3)
 10690 |     |             mstore(0x80, m4)
 10691 |     |             mstore(0xa0, m5)
 10692 |     |             mstore(0xc0, m6)
 10693 |     |             mstore(0xe0, m7)
 10694 |     |             mstore(0x100, m8)
 10695 |     |         }
 10696 |     |     }
 10697 |     | 
 10698 |     |     function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {
 10699 |     |         bytes32 m0;
 10700 |     |         bytes32 m1;
 10701 |     |         bytes32 m2;
 10702 |     |         bytes32 m3;
 10703 |     |         bytes32 m4;
 10704 |     |         bytes32 m5;
 10705 |     |         bytes32 m6;
 10706 |     |         bytes32 m7;
 10707 |     |         bytes32 m8;
 10708 |     |         assembly {
 10709 |     |             function writeString(pos, w) {
 10710 |     |                 let length := 0
 10711 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10712 |     |                 mstore(pos, length)
 10713 |     |                 let shift := sub(256, shl(3, length))
 10714 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10715 |     |             }
 10716 |     |             m0 := mload(0x00)
 10717 |     |             m1 := mload(0x20)
 10718 |     |             m2 := mload(0x40)
 10719 |     |             m3 := mload(0x60)
 10720 |     |             m4 := mload(0x80)
 10721 |     |             m5 := mload(0xa0)
 10722 |     |             m6 := mload(0xc0)
 10723 |     |             m7 := mload(0xe0)
 10724 |     |             m8 := mload(0x100)
 10725 |     |             // Selector of `log(string,address,string,address)`.
 10726 |     |             mstore(0x00, 0xaabc9a31)
 10727 |     |             mstore(0x20, 0x80)
 10728 |     |             mstore(0x40, p1)
 10729 |     |             mstore(0x60, 0xc0)
 10730 |     |             mstore(0x80, p3)
 10731 |     |             writeString(0xa0, p0)
 10732 |     |             writeString(0xe0, p2)
 10733 |     |         }
 10734 |     |         _sendLogPayload(0x1c, 0x104);
 10735 |     |         assembly {
 10736 |     |             mstore(0x00, m0)
 10737 |     |             mstore(0x20, m1)
 10738 |     |             mstore(0x40, m2)
 10739 |     |             mstore(0x60, m3)
 10740 |     |             mstore(0x80, m4)
 10741 |     |             mstore(0xa0, m5)
 10742 |     |             mstore(0xc0, m6)
 10743 |     |             mstore(0xe0, m7)
 10744 |     |             mstore(0x100, m8)
 10745 |     |         }
 10746 |     |     }
 10747 |     | 
 10748 |     |     function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {
 10749 |     |         bytes32 m0;
 10750 |     |         bytes32 m1;
 10751 |     |         bytes32 m2;
 10752 |     |         bytes32 m3;
 10753 |     |         bytes32 m4;
 10754 |     |         bytes32 m5;
 10755 |     |         bytes32 m6;
 10756 |     |         bytes32 m7;
 10757 |     |         bytes32 m8;
 10758 |     |         assembly {
 10759 |     |             function writeString(pos, w) {
 10760 |     |                 let length := 0
 10761 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10762 |     |                 mstore(pos, length)
 10763 |     |                 let shift := sub(256, shl(3, length))
 10764 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10765 |     |             }
 10766 |     |             m0 := mload(0x00)
 10767 |     |             m1 := mload(0x20)
 10768 |     |             m2 := mload(0x40)
 10769 |     |             m3 := mload(0x60)
 10770 |     |             m4 := mload(0x80)
 10771 |     |             m5 := mload(0xa0)
 10772 |     |             m6 := mload(0xc0)
 10773 |     |             m7 := mload(0xe0)
 10774 |     |             m8 := mload(0x100)
 10775 |     |             // Selector of `log(string,address,string,bool)`.
 10776 |     |             mstore(0x00, 0x5f15d28c)
 10777 |     |             mstore(0x20, 0x80)
 10778 |     |             mstore(0x40, p1)
 10779 |     |             mstore(0x60, 0xc0)
 10780 |     |             mstore(0x80, p3)
 10781 |     |             writeString(0xa0, p0)
 10782 |     |             writeString(0xe0, p2)
 10783 |     |         }
 10784 |     |         _sendLogPayload(0x1c, 0x104);
 10785 |     |         assembly {
 10786 |     |             mstore(0x00, m0)
 10787 |     |             mstore(0x20, m1)
 10788 |     |             mstore(0x40, m2)
 10789 |     |             mstore(0x60, m3)
 10790 |     |             mstore(0x80, m4)
 10791 |     |             mstore(0xa0, m5)
 10792 |     |             mstore(0xc0, m6)
 10793 |     |             mstore(0xe0, m7)
 10794 |     |             mstore(0x100, m8)
 10795 |     |         }
 10796 |     |     }
 10797 |     | 
 10798 |     |     function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {
 10799 |     |         bytes32 m0;
 10800 |     |         bytes32 m1;
 10801 |     |         bytes32 m2;
 10802 |     |         bytes32 m3;
 10803 |     |         bytes32 m4;
 10804 |     |         bytes32 m5;
 10805 |     |         bytes32 m6;
 10806 |     |         bytes32 m7;
 10807 |     |         bytes32 m8;
 10808 |     |         assembly {
 10809 |     |             function writeString(pos, w) {
 10810 |     |                 let length := 0
 10811 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10812 |     |                 mstore(pos, length)
 10813 |     |                 let shift := sub(256, shl(3, length))
 10814 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10815 |     |             }
 10816 |     |             m0 := mload(0x00)
 10817 |     |             m1 := mload(0x20)
 10818 |     |             m2 := mload(0x40)
 10819 |     |             m3 := mload(0x60)
 10820 |     |             m4 := mload(0x80)
 10821 |     |             m5 := mload(0xa0)
 10822 |     |             m6 := mload(0xc0)
 10823 |     |             m7 := mload(0xe0)
 10824 |     |             m8 := mload(0x100)
 10825 |     |             // Selector of `log(string,address,string,uint256)`.
 10826 |     |             mstore(0x00, 0x91d1112e)
 10827 |     |             mstore(0x20, 0x80)
 10828 |     |             mstore(0x40, p1)
 10829 |     |             mstore(0x60, 0xc0)
 10830 |     |             mstore(0x80, p3)
 10831 |     |             writeString(0xa0, p0)
 10832 |     |             writeString(0xe0, p2)
 10833 |     |         }
 10834 |     |         _sendLogPayload(0x1c, 0x104);
 10835 |     |         assembly {
 10836 |     |             mstore(0x00, m0)
 10837 |     |             mstore(0x20, m1)
 10838 |     |             mstore(0x40, m2)
 10839 |     |             mstore(0x60, m3)
 10840 |     |             mstore(0x80, m4)
 10841 |     |             mstore(0xa0, m5)
 10842 |     |             mstore(0xc0, m6)
 10843 |     |             mstore(0xe0, m7)
 10844 |     |             mstore(0x100, m8)
 10845 |     |         }
 10846 |     |     }
 10847 |     | 
 10848 |     |     function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
 10849 |     |         bytes32 m0;
 10850 |     |         bytes32 m1;
 10851 |     |         bytes32 m2;
 10852 |     |         bytes32 m3;
 10853 |     |         bytes32 m4;
 10854 |     |         bytes32 m5;
 10855 |     |         bytes32 m6;
 10856 |     |         bytes32 m7;
 10857 |     |         bytes32 m8;
 10858 |     |         bytes32 m9;
 10859 |     |         bytes32 m10;
 10860 |     |         assembly {
 10861 |     |             function writeString(pos, w) {
 10862 |     |                 let length := 0
 10863 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10864 |     |                 mstore(pos, length)
 10865 |     |                 let shift := sub(256, shl(3, length))
 10866 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10867 |     |             }
 10868 |     |             m0 := mload(0x00)
 10869 |     |             m1 := mload(0x20)
 10870 |     |             m2 := mload(0x40)
 10871 |     |             m3 := mload(0x60)
 10872 |     |             m4 := mload(0x80)
 10873 |     |             m5 := mload(0xa0)
 10874 |     |             m6 := mload(0xc0)
 10875 |     |             m7 := mload(0xe0)
 10876 |     |             m8 := mload(0x100)
 10877 |     |             m9 := mload(0x120)
 10878 |     |             m10 := mload(0x140)
 10879 |     |             // Selector of `log(string,address,string,string)`.
 10880 |     |             mstore(0x00, 0x245986f2)
 10881 |     |             mstore(0x20, 0x80)
 10882 |     |             mstore(0x40, p1)
 10883 |     |             mstore(0x60, 0xc0)
 10884 |     |             mstore(0x80, 0x100)
 10885 |     |             writeString(0xa0, p0)
 10886 |     |             writeString(0xe0, p2)
 10887 |     |             writeString(0x120, p3)
 10888 |     |         }
 10889 |     |         _sendLogPayload(0x1c, 0x144);
 10890 |     |         assembly {
 10891 |     |             mstore(0x00, m0)
 10892 |     |             mstore(0x20, m1)
 10893 |     |             mstore(0x40, m2)
 10894 |     |             mstore(0x60, m3)
 10895 |     |             mstore(0x80, m4)
 10896 |     |             mstore(0xa0, m5)
 10897 |     |             mstore(0xc0, m6)
 10898 |     |             mstore(0xe0, m7)
 10899 |     |             mstore(0x100, m8)
 10900 |     |             mstore(0x120, m9)
 10901 |     |             mstore(0x140, m10)
 10902 |     |         }
 10903 |     |     }
 10904 |     | 
 10905 |     |     function log(bytes32 p0, bool p1, address p2, address p3) internal pure {
 10906 |     |         bytes32 m0;
 10907 |     |         bytes32 m1;
 10908 |     |         bytes32 m2;
 10909 |     |         bytes32 m3;
 10910 |     |         bytes32 m4;
 10911 |     |         bytes32 m5;
 10912 |     |         bytes32 m6;
 10913 |     |         assembly {
 10914 |     |             function writeString(pos, w) {
 10915 |     |                 let length := 0
 10916 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10917 |     |                 mstore(pos, length)
 10918 |     |                 let shift := sub(256, shl(3, length))
 10919 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10920 |     |             }
 10921 |     |             m0 := mload(0x00)
 10922 |     |             m1 := mload(0x20)
 10923 |     |             m2 := mload(0x40)
 10924 |     |             m3 := mload(0x60)
 10925 |     |             m4 := mload(0x80)
 10926 |     |             m5 := mload(0xa0)
 10927 |     |             m6 := mload(0xc0)
 10928 |     |             // Selector of `log(string,bool,address,address)`.
 10929 |     |             mstore(0x00, 0x33e9dd1d)
 10930 |     |             mstore(0x20, 0x80)
 10931 |     |             mstore(0x40, p1)
 10932 |     |             mstore(0x60, p2)
 10933 |     |             mstore(0x80, p3)
 10934 |     |             writeString(0xa0, p0)
 10935 |     |         }
 10936 |     |         _sendLogPayload(0x1c, 0xc4);
 10937 |     |         assembly {
 10938 |     |             mstore(0x00, m0)
 10939 |     |             mstore(0x20, m1)
 10940 |     |             mstore(0x40, m2)
 10941 |     |             mstore(0x60, m3)
 10942 |     |             mstore(0x80, m4)
 10943 |     |             mstore(0xa0, m5)
 10944 |     |             mstore(0xc0, m6)
 10945 |     |         }
 10946 |     |     }
 10947 |     | 
 10948 |     |     function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {
 10949 |     |         bytes32 m0;
 10950 |     |         bytes32 m1;
 10951 |     |         bytes32 m2;
 10952 |     |         bytes32 m3;
 10953 |     |         bytes32 m4;
 10954 |     |         bytes32 m5;
 10955 |     |         bytes32 m6;
 10956 |     |         assembly {
 10957 |     |             function writeString(pos, w) {
 10958 |     |                 let length := 0
 10959 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10960 |     |                 mstore(pos, length)
 10961 |     |                 let shift := sub(256, shl(3, length))
 10962 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10963 |     |             }
 10964 |     |             m0 := mload(0x00)
 10965 |     |             m1 := mload(0x20)
 10966 |     |             m2 := mload(0x40)
 10967 |     |             m3 := mload(0x60)
 10968 |     |             m4 := mload(0x80)
 10969 |     |             m5 := mload(0xa0)
 10970 |     |             m6 := mload(0xc0)
 10971 |     |             // Selector of `log(string,bool,address,bool)`.
 10972 |     |             mstore(0x00, 0x958c28c6)
 10973 |     |             mstore(0x20, 0x80)
 10974 |     |             mstore(0x40, p1)
 10975 |     |             mstore(0x60, p2)
 10976 |     |             mstore(0x80, p3)
 10977 |     |             writeString(0xa0, p0)
 10978 |     |         }
 10979 |     |         _sendLogPayload(0x1c, 0xc4);
 10980 |     |         assembly {
 10981 |     |             mstore(0x00, m0)
 10982 |     |             mstore(0x20, m1)
 10983 |     |             mstore(0x40, m2)
 10984 |     |             mstore(0x60, m3)
 10985 |     |             mstore(0x80, m4)
 10986 |     |             mstore(0xa0, m5)
 10987 |     |             mstore(0xc0, m6)
 10988 |     |         }
 10989 |     |     }
 10990 |     | 
 10991 |     |     function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {
 10992 |     |         bytes32 m0;
 10993 |     |         bytes32 m1;
 10994 |     |         bytes32 m2;
 10995 |     |         bytes32 m3;
 10996 |     |         bytes32 m4;
 10997 |     |         bytes32 m5;
 10998 |     |         bytes32 m6;
 10999 |     |         assembly {
 11000 |     |             function writeString(pos, w) {
 11001 |     |                 let length := 0
 11002 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11003 |     |                 mstore(pos, length)
 11004 |     |                 let shift := sub(256, shl(3, length))
 11005 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11006 |     |             }
 11007 |     |             m0 := mload(0x00)
 11008 |     |             m1 := mload(0x20)
 11009 |     |             m2 := mload(0x40)
 11010 |     |             m3 := mload(0x60)
 11011 |     |             m4 := mload(0x80)
 11012 |     |             m5 := mload(0xa0)
 11013 |     |             m6 := mload(0xc0)
 11014 |     |             // Selector of `log(string,bool,address,uint256)`.
 11015 |     |             mstore(0x00, 0x5d08bb05)
 11016 |     |             mstore(0x20, 0x80)
 11017 |     |             mstore(0x40, p1)
 11018 |     |             mstore(0x60, p2)
 11019 |     |             mstore(0x80, p3)
 11020 |     |             writeString(0xa0, p0)
 11021 |     |         }
 11022 |     |         _sendLogPayload(0x1c, 0xc4);
 11023 |     |         assembly {
 11024 |     |             mstore(0x00, m0)
 11025 |     |             mstore(0x20, m1)
 11026 |     |             mstore(0x40, m2)
 11027 |     |             mstore(0x60, m3)
 11028 |     |             mstore(0x80, m4)
 11029 |     |             mstore(0xa0, m5)
 11030 |     |             mstore(0xc0, m6)
 11031 |     |         }
 11032 |     |     }
 11033 |     | 
 11034 |     |     function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {
 11035 |     |         bytes32 m0;
 11036 |     |         bytes32 m1;
 11037 |     |         bytes32 m2;
 11038 |     |         bytes32 m3;
 11039 |     |         bytes32 m4;
 11040 |     |         bytes32 m5;
 11041 |     |         bytes32 m6;
 11042 |     |         bytes32 m7;
 11043 |     |         bytes32 m8;
 11044 |     |         assembly {
 11045 |     |             function writeString(pos, w) {
 11046 |     |                 let length := 0
 11047 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11048 |     |                 mstore(pos, length)
 11049 |     |                 let shift := sub(256, shl(3, length))
 11050 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11051 |     |             }
 11052 |     |             m0 := mload(0x00)
 11053 |     |             m1 := mload(0x20)
 11054 |     |             m2 := mload(0x40)
 11055 |     |             m3 := mload(0x60)
 11056 |     |             m4 := mload(0x80)
 11057 |     |             m5 := mload(0xa0)
 11058 |     |             m6 := mload(0xc0)
 11059 |     |             m7 := mload(0xe0)
 11060 |     |             m8 := mload(0x100)
 11061 |     |             // Selector of `log(string,bool,address,string)`.
 11062 |     |             mstore(0x00, 0x2d8e33a4)
 11063 |     |             mstore(0x20, 0x80)
 11064 |     |             mstore(0x40, p1)
 11065 |     |             mstore(0x60, p2)
 11066 |     |             mstore(0x80, 0xc0)
 11067 |     |             writeString(0xa0, p0)
 11068 |     |             writeString(0xe0, p3)
 11069 |     |         }
 11070 |     |         _sendLogPayload(0x1c, 0x104);
 11071 |     |         assembly {
 11072 |     |             mstore(0x00, m0)
 11073 |     |             mstore(0x20, m1)
 11074 |     |             mstore(0x40, m2)
 11075 |     |             mstore(0x60, m3)
 11076 |     |             mstore(0x80, m4)
 11077 |     |             mstore(0xa0, m5)
 11078 |     |             mstore(0xc0, m6)
 11079 |     |             mstore(0xe0, m7)
 11080 |     |             mstore(0x100, m8)
 11081 |     |         }
 11082 |     |     }
 11083 |     | 
 11084 |     |     function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {
 11085 |     |         bytes32 m0;
 11086 |     |         bytes32 m1;
 11087 |     |         bytes32 m2;
 11088 |     |         bytes32 m3;
 11089 |     |         bytes32 m4;
 11090 |     |         bytes32 m5;
 11091 |     |         bytes32 m6;
 11092 |     |         assembly {
 11093 |     |             function writeString(pos, w) {
 11094 |     |                 let length := 0
 11095 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11096 |     |                 mstore(pos, length)
 11097 |     |                 let shift := sub(256, shl(3, length))
 11098 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11099 |     |             }
 11100 |     |             m0 := mload(0x00)
 11101 |     |             m1 := mload(0x20)
 11102 |     |             m2 := mload(0x40)
 11103 |     |             m3 := mload(0x60)
 11104 |     |             m4 := mload(0x80)
 11105 |     |             m5 := mload(0xa0)
 11106 |     |             m6 := mload(0xc0)
 11107 |     |             // Selector of `log(string,bool,bool,address)`.
 11108 |     |             mstore(0x00, 0x7190a529)
 11109 |     |             mstore(0x20, 0x80)
 11110 |     |             mstore(0x40, p1)
 11111 |     |             mstore(0x60, p2)
 11112 |     |             mstore(0x80, p3)
 11113 |     |             writeString(0xa0, p0)
 11114 |     |         }
 11115 |     |         _sendLogPayload(0x1c, 0xc4);
 11116 |     |         assembly {
 11117 |     |             mstore(0x00, m0)
 11118 |     |             mstore(0x20, m1)
 11119 |     |             mstore(0x40, m2)
 11120 |     |             mstore(0x60, m3)
 11121 |     |             mstore(0x80, m4)
 11122 |     |             mstore(0xa0, m5)
 11123 |     |             mstore(0xc0, m6)
 11124 |     |         }
 11125 |     |     }
 11126 |     | 
 11127 |     |     function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {
 11128 |     |         bytes32 m0;
 11129 |     |         bytes32 m1;
 11130 |     |         bytes32 m2;
 11131 |     |         bytes32 m3;
 11132 |     |         bytes32 m4;
 11133 |     |         bytes32 m5;
 11134 |     |         bytes32 m6;
 11135 |     |         assembly {
 11136 |     |             function writeString(pos, w) {
 11137 |     |                 let length := 0
 11138 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11139 |     |                 mstore(pos, length)
 11140 |     |                 let shift := sub(256, shl(3, length))
 11141 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11142 |     |             }
 11143 |     |             m0 := mload(0x00)
 11144 |     |             m1 := mload(0x20)
 11145 |     |             m2 := mload(0x40)
 11146 |     |             m3 := mload(0x60)
 11147 |     |             m4 := mload(0x80)
 11148 |     |             m5 := mload(0xa0)
 11149 |     |             m6 := mload(0xc0)
 11150 |     |             // Selector of `log(string,bool,bool,bool)`.
 11151 |     |             mstore(0x00, 0x895af8c5)
 11152 |     |             mstore(0x20, 0x80)
 11153 |     |             mstore(0x40, p1)
 11154 |     |             mstore(0x60, p2)
 11155 |     |             mstore(0x80, p3)
 11156 |     |             writeString(0xa0, p0)
 11157 |     |         }
 11158 |     |         _sendLogPayload(0x1c, 0xc4);
 11159 |     |         assembly {
 11160 |     |             mstore(0x00, m0)
 11161 |     |             mstore(0x20, m1)
 11162 |     |             mstore(0x40, m2)
 11163 |     |             mstore(0x60, m3)
 11164 |     |             mstore(0x80, m4)
 11165 |     |             mstore(0xa0, m5)
 11166 |     |             mstore(0xc0, m6)
 11167 |     |         }
 11168 |     |     }
 11169 |     | 
 11170 |     |     function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {
 11171 |     |         bytes32 m0;
 11172 |     |         bytes32 m1;
 11173 |     |         bytes32 m2;
 11174 |     |         bytes32 m3;
 11175 |     |         bytes32 m4;
 11176 |     |         bytes32 m5;
 11177 |     |         bytes32 m6;
 11178 |     |         assembly {
 11179 |     |             function writeString(pos, w) {
 11180 |     |                 let length := 0
 11181 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11182 |     |                 mstore(pos, length)
 11183 |     |                 let shift := sub(256, shl(3, length))
 11184 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11185 |     |             }
 11186 |     |             m0 := mload(0x00)
 11187 |     |             m1 := mload(0x20)
 11188 |     |             m2 := mload(0x40)
 11189 |     |             m3 := mload(0x60)
 11190 |     |             m4 := mload(0x80)
 11191 |     |             m5 := mload(0xa0)
 11192 |     |             m6 := mload(0xc0)
 11193 |     |             // Selector of `log(string,bool,bool,uint256)`.
 11194 |     |             mstore(0x00, 0x8e3f78a9)
 11195 |     |             mstore(0x20, 0x80)
 11196 |     |             mstore(0x40, p1)
 11197 |     |             mstore(0x60, p2)
 11198 |     |             mstore(0x80, p3)
 11199 |     |             writeString(0xa0, p0)
 11200 |     |         }
 11201 |     |         _sendLogPayload(0x1c, 0xc4);
 11202 |     |         assembly {
 11203 |     |             mstore(0x00, m0)
 11204 |     |             mstore(0x20, m1)
 11205 |     |             mstore(0x40, m2)
 11206 |     |             mstore(0x60, m3)
 11207 |     |             mstore(0x80, m4)
 11208 |     |             mstore(0xa0, m5)
 11209 |     |             mstore(0xc0, m6)
 11210 |     |         }
 11211 |     |     }
 11212 |     | 
 11213 |     |     function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {
 11214 |     |         bytes32 m0;
 11215 |     |         bytes32 m1;
 11216 |     |         bytes32 m2;
 11217 |     |         bytes32 m3;
 11218 |     |         bytes32 m4;
 11219 |     |         bytes32 m5;
 11220 |     |         bytes32 m6;
 11221 |     |         bytes32 m7;
 11222 |     |         bytes32 m8;
 11223 |     |         assembly {
 11224 |     |             function writeString(pos, w) {
 11225 |     |                 let length := 0
 11226 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11227 |     |                 mstore(pos, length)
 11228 |     |                 let shift := sub(256, shl(3, length))
 11229 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11230 |     |             }
 11231 |     |             m0 := mload(0x00)
 11232 |     |             m1 := mload(0x20)
 11233 |     |             m2 := mload(0x40)
 11234 |     |             m3 := mload(0x60)
 11235 |     |             m4 := mload(0x80)
 11236 |     |             m5 := mload(0xa0)
 11237 |     |             m6 := mload(0xc0)
 11238 |     |             m7 := mload(0xe0)
 11239 |     |             m8 := mload(0x100)
 11240 |     |             // Selector of `log(string,bool,bool,string)`.
 11241 |     |             mstore(0x00, 0x9d22d5dd)
 11242 |     |             mstore(0x20, 0x80)
 11243 |     |             mstore(0x40, p1)
 11244 |     |             mstore(0x60, p2)
 11245 |     |             mstore(0x80, 0xc0)
 11246 |     |             writeString(0xa0, p0)
 11247 |     |             writeString(0xe0, p3)
 11248 |     |         }
 11249 |     |         _sendLogPayload(0x1c, 0x104);
 11250 |     |         assembly {
 11251 |     |             mstore(0x00, m0)
 11252 |     |             mstore(0x20, m1)
 11253 |     |             mstore(0x40, m2)
 11254 |     |             mstore(0x60, m3)
 11255 |     |             mstore(0x80, m4)
 11256 |     |             mstore(0xa0, m5)
 11257 |     |             mstore(0xc0, m6)
 11258 |     |             mstore(0xe0, m7)
 11259 |     |             mstore(0x100, m8)
 11260 |     |         }
 11261 |     |     }
 11262 |     | 
 11263 |     |     function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {
 11264 |     |         bytes32 m0;
 11265 |     |         bytes32 m1;
 11266 |     |         bytes32 m2;
 11267 |     |         bytes32 m3;
 11268 |     |         bytes32 m4;
 11269 |     |         bytes32 m5;
 11270 |     |         bytes32 m6;
 11271 |     |         assembly {
 11272 |     |             function writeString(pos, w) {
 11273 |     |                 let length := 0
 11274 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11275 |     |                 mstore(pos, length)
 11276 |     |                 let shift := sub(256, shl(3, length))
 11277 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11278 |     |             }
 11279 |     |             m0 := mload(0x00)
 11280 |     |             m1 := mload(0x20)
 11281 |     |             m2 := mload(0x40)
 11282 |     |             m3 := mload(0x60)
 11283 |     |             m4 := mload(0x80)
 11284 |     |             m5 := mload(0xa0)
 11285 |     |             m6 := mload(0xc0)
 11286 |     |             // Selector of `log(string,bool,uint256,address)`.
 11287 |     |             mstore(0x00, 0x935e09bf)
 11288 |     |             mstore(0x20, 0x80)
 11289 |     |             mstore(0x40, p1)
 11290 |     |             mstore(0x60, p2)
 11291 |     |             mstore(0x80, p3)
 11292 |     |             writeString(0xa0, p0)
 11293 |     |         }
 11294 |     |         _sendLogPayload(0x1c, 0xc4);
 11295 |     |         assembly {
 11296 |     |             mstore(0x00, m0)
 11297 |     |             mstore(0x20, m1)
 11298 |     |             mstore(0x40, m2)
 11299 |     |             mstore(0x60, m3)
 11300 |     |             mstore(0x80, m4)
 11301 |     |             mstore(0xa0, m5)
 11302 |     |             mstore(0xc0, m6)
 11303 |     |         }
 11304 |     |     }
 11305 |     | 
 11306 |     |     function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {
 11307 |     |         bytes32 m0;
 11308 |     |         bytes32 m1;
 11309 |     |         bytes32 m2;
 11310 |     |         bytes32 m3;
 11311 |     |         bytes32 m4;
 11312 |     |         bytes32 m5;
 11313 |     |         bytes32 m6;
 11314 |     |         assembly {
 11315 |     |             function writeString(pos, w) {
 11316 |     |                 let length := 0
 11317 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11318 |     |                 mstore(pos, length)
 11319 |     |                 let shift := sub(256, shl(3, length))
 11320 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11321 |     |             }
 11322 |     |             m0 := mload(0x00)
 11323 |     |             m1 := mload(0x20)
 11324 |     |             m2 := mload(0x40)
 11325 |     |             m3 := mload(0x60)
 11326 |     |             m4 := mload(0x80)
 11327 |     |             m5 := mload(0xa0)
 11328 |     |             m6 := mload(0xc0)
 11329 |     |             // Selector of `log(string,bool,uint256,bool)`.
 11330 |     |             mstore(0x00, 0x8af7cf8a)
 11331 |     |             mstore(0x20, 0x80)
 11332 |     |             mstore(0x40, p1)
 11333 |     |             mstore(0x60, p2)
 11334 |     |             mstore(0x80, p3)
 11335 |     |             writeString(0xa0, p0)
 11336 |     |         }
 11337 |     |         _sendLogPayload(0x1c, 0xc4);
 11338 |     |         assembly {
 11339 |     |             mstore(0x00, m0)
 11340 |     |             mstore(0x20, m1)
 11341 |     |             mstore(0x40, m2)
 11342 |     |             mstore(0x60, m3)
 11343 |     |             mstore(0x80, m4)
 11344 |     |             mstore(0xa0, m5)
 11345 |     |             mstore(0xc0, m6)
 11346 |     |         }
 11347 |     |     }
 11348 |     | 
 11349 |     |     function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {
 11350 |     |         bytes32 m0;
 11351 |     |         bytes32 m1;
 11352 |     |         bytes32 m2;
 11353 |     |         bytes32 m3;
 11354 |     |         bytes32 m4;
 11355 |     |         bytes32 m5;
 11356 |     |         bytes32 m6;
 11357 |     |         assembly {
 11358 |     |             function writeString(pos, w) {
 11359 |     |                 let length := 0
 11360 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11361 |     |                 mstore(pos, length)
 11362 |     |                 let shift := sub(256, shl(3, length))
 11363 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11364 |     |             }
 11365 |     |             m0 := mload(0x00)
 11366 |     |             m1 := mload(0x20)
 11367 |     |             m2 := mload(0x40)
 11368 |     |             m3 := mload(0x60)
 11369 |     |             m4 := mload(0x80)
 11370 |     |             m5 := mload(0xa0)
 11371 |     |             m6 := mload(0xc0)
 11372 |     |             // Selector of `log(string,bool,uint256,uint256)`.
 11373 |     |             mstore(0x00, 0x64b5bb67)
 11374 |     |             mstore(0x20, 0x80)
 11375 |     |             mstore(0x40, p1)
 11376 |     |             mstore(0x60, p2)
 11377 |     |             mstore(0x80, p3)
 11378 |     |             writeString(0xa0, p0)
 11379 |     |         }
 11380 |     |         _sendLogPayload(0x1c, 0xc4);
 11381 |     |         assembly {
 11382 |     |             mstore(0x00, m0)
 11383 |     |             mstore(0x20, m1)
 11384 |     |             mstore(0x40, m2)
 11385 |     |             mstore(0x60, m3)
 11386 |     |             mstore(0x80, m4)
 11387 |     |             mstore(0xa0, m5)
 11388 |     |             mstore(0xc0, m6)
 11389 |     |         }
 11390 |     |     }
 11391 |     | 
 11392 |     |     function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
 11393 |     |         bytes32 m0;
 11394 |     |         bytes32 m1;
 11395 |     |         bytes32 m2;
 11396 |     |         bytes32 m3;
 11397 |     |         bytes32 m4;
 11398 |     |         bytes32 m5;
 11399 |     |         bytes32 m6;
 11400 |     |         bytes32 m7;
 11401 |     |         bytes32 m8;
 11402 |     |         assembly {
 11403 |     |             function writeString(pos, w) {
 11404 |     |                 let length := 0
 11405 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11406 |     |                 mstore(pos, length)
 11407 |     |                 let shift := sub(256, shl(3, length))
 11408 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11409 |     |             }
 11410 |     |             m0 := mload(0x00)
 11411 |     |             m1 := mload(0x20)
 11412 |     |             m2 := mload(0x40)
 11413 |     |             m3 := mload(0x60)
 11414 |     |             m4 := mload(0x80)
 11415 |     |             m5 := mload(0xa0)
 11416 |     |             m6 := mload(0xc0)
 11417 |     |             m7 := mload(0xe0)
 11418 |     |             m8 := mload(0x100)
 11419 |     |             // Selector of `log(string,bool,uint256,string)`.
 11420 |     |             mstore(0x00, 0x742d6ee7)
 11421 |     |             mstore(0x20, 0x80)
 11422 |     |             mstore(0x40, p1)
 11423 |     |             mstore(0x60, p2)
 11424 |     |             mstore(0x80, 0xc0)
 11425 |     |             writeString(0xa0, p0)
 11426 |     |             writeString(0xe0, p3)
 11427 |     |         }
 11428 |     |         _sendLogPayload(0x1c, 0x104);
 11429 |     |         assembly {
 11430 |     |             mstore(0x00, m0)
 11431 |     |             mstore(0x20, m1)
 11432 |     |             mstore(0x40, m2)
 11433 |     |             mstore(0x60, m3)
 11434 |     |             mstore(0x80, m4)
 11435 |     |             mstore(0xa0, m5)
 11436 |     |             mstore(0xc0, m6)
 11437 |     |             mstore(0xe0, m7)
 11438 |     |             mstore(0x100, m8)
 11439 |     |         }
 11440 |     |     }
 11441 |     | 
 11442 |     |     function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {
 11443 |     |         bytes32 m0;
 11444 |     |         bytes32 m1;
 11445 |     |         bytes32 m2;
 11446 |     |         bytes32 m3;
 11447 |     |         bytes32 m4;
 11448 |     |         bytes32 m5;
 11449 |     |         bytes32 m6;
 11450 |     |         bytes32 m7;
 11451 |     |         bytes32 m8;
 11452 |     |         assembly {
 11453 |     |             function writeString(pos, w) {
 11454 |     |                 let length := 0
 11455 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11456 |     |                 mstore(pos, length)
 11457 |     |                 let shift := sub(256, shl(3, length))
 11458 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11459 |     |             }
 11460 |     |             m0 := mload(0x00)
 11461 |     |             m1 := mload(0x20)
 11462 |     |             m2 := mload(0x40)
 11463 |     |             m3 := mload(0x60)
 11464 |     |             m4 := mload(0x80)
 11465 |     |             m5 := mload(0xa0)
 11466 |     |             m6 := mload(0xc0)
 11467 |     |             m7 := mload(0xe0)
 11468 |     |             m8 := mload(0x100)
 11469 |     |             // Selector of `log(string,bool,string,address)`.
 11470 |     |             mstore(0x00, 0xe0625b29)
 11471 |     |             mstore(0x20, 0x80)
 11472 |     |             mstore(0x40, p1)
 11473 |     |             mstore(0x60, 0xc0)
 11474 |     |             mstore(0x80, p3)
 11475 |     |             writeString(0xa0, p0)
 11476 |     |             writeString(0xe0, p2)
 11477 |     |         }
 11478 |     |         _sendLogPayload(0x1c, 0x104);
 11479 |     |         assembly {
 11480 |     |             mstore(0x00, m0)
 11481 |     |             mstore(0x20, m1)
 11482 |     |             mstore(0x40, m2)
 11483 |     |             mstore(0x60, m3)
 11484 |     |             mstore(0x80, m4)
 11485 |     |             mstore(0xa0, m5)
 11486 |     |             mstore(0xc0, m6)
 11487 |     |             mstore(0xe0, m7)
 11488 |     |             mstore(0x100, m8)
 11489 |     |         }
 11490 |     |     }
 11491 |     | 
 11492 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {
 11493 |     |         bytes32 m0;
 11494 |     |         bytes32 m1;
 11495 |     |         bytes32 m2;
 11496 |     |         bytes32 m3;
 11497 |     |         bytes32 m4;
 11498 |     |         bytes32 m5;
 11499 |     |         bytes32 m6;
 11500 |     |         bytes32 m7;
 11501 |     |         bytes32 m8;
 11502 |     |         assembly {
 11503 |     |             function writeString(pos, w) {
 11504 |     |                 let length := 0
 11505 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11506 |     |                 mstore(pos, length)
 11507 |     |                 let shift := sub(256, shl(3, length))
 11508 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11509 |     |             }
 11510 |     |             m0 := mload(0x00)
 11511 |     |             m1 := mload(0x20)
 11512 |     |             m2 := mload(0x40)
 11513 |     |             m3 := mload(0x60)
 11514 |     |             m4 := mload(0x80)
 11515 |     |             m5 := mload(0xa0)
 11516 |     |             m6 := mload(0xc0)
 11517 |     |             m7 := mload(0xe0)
 11518 |     |             m8 := mload(0x100)
 11519 |     |             // Selector of `log(string,bool,string,bool)`.
 11520 |     |             mstore(0x00, 0x3f8a701d)
 11521 |     |             mstore(0x20, 0x80)
 11522 |     |             mstore(0x40, p1)
 11523 |     |             mstore(0x60, 0xc0)
 11524 |     |             mstore(0x80, p3)
 11525 |     |             writeString(0xa0, p0)
 11526 |     |             writeString(0xe0, p2)
 11527 |     |         }
 11528 |     |         _sendLogPayload(0x1c, 0x104);
 11529 |     |         assembly {
 11530 |     |             mstore(0x00, m0)
 11531 |     |             mstore(0x20, m1)
 11532 |     |             mstore(0x40, m2)
 11533 |     |             mstore(0x60, m3)
 11534 |     |             mstore(0x80, m4)
 11535 |     |             mstore(0xa0, m5)
 11536 |     |             mstore(0xc0, m6)
 11537 |     |             mstore(0xe0, m7)
 11538 |     |             mstore(0x100, m8)
 11539 |     |         }
 11540 |     |     }
 11541 |     | 
 11542 |     |     function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
 11543 |     |         bytes32 m0;
 11544 |     |         bytes32 m1;
 11545 |     |         bytes32 m2;
 11546 |     |         bytes32 m3;
 11547 |     |         bytes32 m4;
 11548 |     |         bytes32 m5;
 11549 |     |         bytes32 m6;
 11550 |     |         bytes32 m7;
 11551 |     |         bytes32 m8;
 11552 |     |         assembly {
 11553 |     |             function writeString(pos, w) {
 11554 |     |                 let length := 0
 11555 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11556 |     |                 mstore(pos, length)
 11557 |     |                 let shift := sub(256, shl(3, length))
 11558 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11559 |     |             }
 11560 |     |             m0 := mload(0x00)
 11561 |     |             m1 := mload(0x20)
 11562 |     |             m2 := mload(0x40)
 11563 |     |             m3 := mload(0x60)
 11564 |     |             m4 := mload(0x80)
 11565 |     |             m5 := mload(0xa0)
 11566 |     |             m6 := mload(0xc0)
 11567 |     |             m7 := mload(0xe0)
 11568 |     |             m8 := mload(0x100)
 11569 |     |             // Selector of `log(string,bool,string,uint256)`.
 11570 |     |             mstore(0x00, 0x24f91465)
 11571 |     |             mstore(0x20, 0x80)
 11572 |     |             mstore(0x40, p1)
 11573 |     |             mstore(0x60, 0xc0)
 11574 |     |             mstore(0x80, p3)
 11575 |     |             writeString(0xa0, p0)
 11576 |     |             writeString(0xe0, p2)
 11577 |     |         }
 11578 |     |         _sendLogPayload(0x1c, 0x104);
 11579 |     |         assembly {
 11580 |     |             mstore(0x00, m0)
 11581 |     |             mstore(0x20, m1)
 11582 |     |             mstore(0x40, m2)
 11583 |     |             mstore(0x60, m3)
 11584 |     |             mstore(0x80, m4)
 11585 |     |             mstore(0xa0, m5)
 11586 |     |             mstore(0xc0, m6)
 11587 |     |             mstore(0xe0, m7)
 11588 |     |             mstore(0x100, m8)
 11589 |     |         }
 11590 |     |     }
 11591 |     | 
 11592 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
 11593 |     |         bytes32 m0;
 11594 |     |         bytes32 m1;
 11595 |     |         bytes32 m2;
 11596 |     |         bytes32 m3;
 11597 |     |         bytes32 m4;
 11598 |     |         bytes32 m5;
 11599 |     |         bytes32 m6;
 11600 |     |         bytes32 m7;
 11601 |     |         bytes32 m8;
 11602 |     |         bytes32 m9;
 11603 |     |         bytes32 m10;
 11604 |     |         assembly {
 11605 |     |             function writeString(pos, w) {
 11606 |     |                 let length := 0
 11607 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11608 |     |                 mstore(pos, length)
 11609 |     |                 let shift := sub(256, shl(3, length))
 11610 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11611 |     |             }
 11612 |     |             m0 := mload(0x00)
 11613 |     |             m1 := mload(0x20)
 11614 |     |             m2 := mload(0x40)
 11615 |     |             m3 := mload(0x60)
 11616 |     |             m4 := mload(0x80)
 11617 |     |             m5 := mload(0xa0)
 11618 |     |             m6 := mload(0xc0)
 11619 |     |             m7 := mload(0xe0)
 11620 |     |             m8 := mload(0x100)
 11621 |     |             m9 := mload(0x120)
 11622 |     |             m10 := mload(0x140)
 11623 |     |             // Selector of `log(string,bool,string,string)`.
 11624 |     |             mstore(0x00, 0xa826caeb)
 11625 |     |             mstore(0x20, 0x80)
 11626 |     |             mstore(0x40, p1)
 11627 |     |             mstore(0x60, 0xc0)
 11628 |     |             mstore(0x80, 0x100)
 11629 |     |             writeString(0xa0, p0)
 11630 |     |             writeString(0xe0, p2)
 11631 |     |             writeString(0x120, p3)
 11632 |     |         }
 11633 |     |         _sendLogPayload(0x1c, 0x144);
 11634 |     |         assembly {
 11635 |     |             mstore(0x00, m0)
 11636 |     |             mstore(0x20, m1)
 11637 |     |             mstore(0x40, m2)
 11638 |     |             mstore(0x60, m3)
 11639 |     |             mstore(0x80, m4)
 11640 |     |             mstore(0xa0, m5)
 11641 |     |             mstore(0xc0, m6)
 11642 |     |             mstore(0xe0, m7)
 11643 |     |             mstore(0x100, m8)
 11644 |     |             mstore(0x120, m9)
 11645 |     |             mstore(0x140, m10)
 11646 |     |         }
 11647 |     |     }
 11648 |     | 
 11649 |     |     function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {
 11650 |     |         bytes32 m0;
 11651 |     |         bytes32 m1;
 11652 |     |         bytes32 m2;
 11653 |     |         bytes32 m3;
 11654 |     |         bytes32 m4;
 11655 |     |         bytes32 m5;
 11656 |     |         bytes32 m6;
 11657 |     |         assembly {
 11658 |     |             function writeString(pos, w) {
 11659 |     |                 let length := 0
 11660 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11661 |     |                 mstore(pos, length)
 11662 |     |                 let shift := sub(256, shl(3, length))
 11663 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11664 |     |             }
 11665 |     |             m0 := mload(0x00)
 11666 |     |             m1 := mload(0x20)
 11667 |     |             m2 := mload(0x40)
 11668 |     |             m3 := mload(0x60)
 11669 |     |             m4 := mload(0x80)
 11670 |     |             m5 := mload(0xa0)
 11671 |     |             m6 := mload(0xc0)
 11672 |     |             // Selector of `log(string,uint256,address,address)`.
 11673 |     |             mstore(0x00, 0x5ea2b7ae)
 11674 |     |             mstore(0x20, 0x80)
 11675 |     |             mstore(0x40, p1)
 11676 |     |             mstore(0x60, p2)
 11677 |     |             mstore(0x80, p3)
 11678 |     |             writeString(0xa0, p0)
 11679 |     |         }
 11680 |     |         _sendLogPayload(0x1c, 0xc4);
 11681 |     |         assembly {
 11682 |     |             mstore(0x00, m0)
 11683 |     |             mstore(0x20, m1)
 11684 |     |             mstore(0x40, m2)
 11685 |     |             mstore(0x60, m3)
 11686 |     |             mstore(0x80, m4)
 11687 |     |             mstore(0xa0, m5)
 11688 |     |             mstore(0xc0, m6)
 11689 |     |         }
 11690 |     |     }
 11691 |     | 
 11692 |     |     function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {
 11693 |     |         bytes32 m0;
 11694 |     |         bytes32 m1;
 11695 |     |         bytes32 m2;
 11696 |     |         bytes32 m3;
 11697 |     |         bytes32 m4;
 11698 |     |         bytes32 m5;
 11699 |     |         bytes32 m6;
 11700 |     |         assembly {
 11701 |     |             function writeString(pos, w) {
 11702 |     |                 let length := 0
 11703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11704 |     |                 mstore(pos, length)
 11705 |     |                 let shift := sub(256, shl(3, length))
 11706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11707 |     |             }
 11708 |     |             m0 := mload(0x00)
 11709 |     |             m1 := mload(0x20)
 11710 |     |             m2 := mload(0x40)
 11711 |     |             m3 := mload(0x60)
 11712 |     |             m4 := mload(0x80)
 11713 |     |             m5 := mload(0xa0)
 11714 |     |             m6 := mload(0xc0)
 11715 |     |             // Selector of `log(string,uint256,address,bool)`.
 11716 |     |             mstore(0x00, 0x82112a42)
 11717 |     |             mstore(0x20, 0x80)
 11718 |     |             mstore(0x40, p1)
 11719 |     |             mstore(0x60, p2)
 11720 |     |             mstore(0x80, p3)
 11721 |     |             writeString(0xa0, p0)
 11722 |     |         }
 11723 |     |         _sendLogPayload(0x1c, 0xc4);
 11724 |     |         assembly {
 11725 |     |             mstore(0x00, m0)
 11726 |     |             mstore(0x20, m1)
 11727 |     |             mstore(0x40, m2)
 11728 |     |             mstore(0x60, m3)
 11729 |     |             mstore(0x80, m4)
 11730 |     |             mstore(0xa0, m5)
 11731 |     |             mstore(0xc0, m6)
 11732 |     |         }
 11733 |     |     }
 11734 |     | 
 11735 |     |     function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {
 11736 |     |         bytes32 m0;
 11737 |     |         bytes32 m1;
 11738 |     |         bytes32 m2;
 11739 |     |         bytes32 m3;
 11740 |     |         bytes32 m4;
 11741 |     |         bytes32 m5;
 11742 |     |         bytes32 m6;
 11743 |     |         assembly {
 11744 |     |             function writeString(pos, w) {
 11745 |     |                 let length := 0
 11746 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11747 |     |                 mstore(pos, length)
 11748 |     |                 let shift := sub(256, shl(3, length))
 11749 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11750 |     |             }
 11751 |     |             m0 := mload(0x00)
 11752 |     |             m1 := mload(0x20)
 11753 |     |             m2 := mload(0x40)
 11754 |     |             m3 := mload(0x60)
 11755 |     |             m4 := mload(0x80)
 11756 |     |             m5 := mload(0xa0)
 11757 |     |             m6 := mload(0xc0)
 11758 |     |             // Selector of `log(string,uint256,address,uint256)`.
 11759 |     |             mstore(0x00, 0x4f04fdc6)
 11760 |     |             mstore(0x20, 0x80)
 11761 |     |             mstore(0x40, p1)
 11762 |     |             mstore(0x60, p2)
 11763 |     |             mstore(0x80, p3)
 11764 |     |             writeString(0xa0, p0)
 11765 |     |         }
 11766 |     |         _sendLogPayload(0x1c, 0xc4);
 11767 |     |         assembly {
 11768 |     |             mstore(0x00, m0)
 11769 |     |             mstore(0x20, m1)
 11770 |     |             mstore(0x40, m2)
 11771 |     |             mstore(0x60, m3)
 11772 |     |             mstore(0x80, m4)
 11773 |     |             mstore(0xa0, m5)
 11774 |     |             mstore(0xc0, m6)
 11775 |     |         }
 11776 |     |     }
 11777 |     | 
 11778 |     |     function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {
 11779 |     |         bytes32 m0;
 11780 |     |         bytes32 m1;
 11781 |     |         bytes32 m2;
 11782 |     |         bytes32 m3;
 11783 |     |         bytes32 m4;
 11784 |     |         bytes32 m5;
 11785 |     |         bytes32 m6;
 11786 |     |         bytes32 m7;
 11787 |     |         bytes32 m8;
 11788 |     |         assembly {
 11789 |     |             function writeString(pos, w) {
 11790 |     |                 let length := 0
 11791 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11792 |     |                 mstore(pos, length)
 11793 |     |                 let shift := sub(256, shl(3, length))
 11794 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11795 |     |             }
 11796 |     |             m0 := mload(0x00)
 11797 |     |             m1 := mload(0x20)
 11798 |     |             m2 := mload(0x40)
 11799 |     |             m3 := mload(0x60)
 11800 |     |             m4 := mload(0x80)
 11801 |     |             m5 := mload(0xa0)
 11802 |     |             m6 := mload(0xc0)
 11803 |     |             m7 := mload(0xe0)
 11804 |     |             m8 := mload(0x100)
 11805 |     |             // Selector of `log(string,uint256,address,string)`.
 11806 |     |             mstore(0x00, 0x9ffb2f93)
 11807 |     |             mstore(0x20, 0x80)
 11808 |     |             mstore(0x40, p1)
 11809 |     |             mstore(0x60, p2)
 11810 |     |             mstore(0x80, 0xc0)
 11811 |     |             writeString(0xa0, p0)
 11812 |     |             writeString(0xe0, p3)
 11813 |     |         }
 11814 |     |         _sendLogPayload(0x1c, 0x104);
 11815 |     |         assembly {
 11816 |     |             mstore(0x00, m0)
 11817 |     |             mstore(0x20, m1)
 11818 |     |             mstore(0x40, m2)
 11819 |     |             mstore(0x60, m3)
 11820 |     |             mstore(0x80, m4)
 11821 |     |             mstore(0xa0, m5)
 11822 |     |             mstore(0xc0, m6)
 11823 |     |             mstore(0xe0, m7)
 11824 |     |             mstore(0x100, m8)
 11825 |     |         }
 11826 |     |     }
 11827 |     | 
 11828 |     |     function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {
 11829 |     |         bytes32 m0;
 11830 |     |         bytes32 m1;
 11831 |     |         bytes32 m2;
 11832 |     |         bytes32 m3;
 11833 |     |         bytes32 m4;
 11834 |     |         bytes32 m5;
 11835 |     |         bytes32 m6;
 11836 |     |         assembly {
 11837 |     |             function writeString(pos, w) {
 11838 |     |                 let length := 0
 11839 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11840 |     |                 mstore(pos, length)
 11841 |     |                 let shift := sub(256, shl(3, length))
 11842 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11843 |     |             }
 11844 |     |             m0 := mload(0x00)
 11845 |     |             m1 := mload(0x20)
 11846 |     |             m2 := mload(0x40)
 11847 |     |             m3 := mload(0x60)
 11848 |     |             m4 := mload(0x80)
 11849 |     |             m5 := mload(0xa0)
 11850 |     |             m6 := mload(0xc0)
 11851 |     |             // Selector of `log(string,uint256,bool,address)`.
 11852 |     |             mstore(0x00, 0xe0e95b98)
 11853 |     |             mstore(0x20, 0x80)
 11854 |     |             mstore(0x40, p1)
 11855 |     |             mstore(0x60, p2)
 11856 |     |             mstore(0x80, p3)
 11857 |     |             writeString(0xa0, p0)
 11858 |     |         }
 11859 |     |         _sendLogPayload(0x1c, 0xc4);
 11860 |     |         assembly {
 11861 |     |             mstore(0x00, m0)
 11862 |     |             mstore(0x20, m1)
 11863 |     |             mstore(0x40, m2)
 11864 |     |             mstore(0x60, m3)
 11865 |     |             mstore(0x80, m4)
 11866 |     |             mstore(0xa0, m5)
 11867 |     |             mstore(0xc0, m6)
 11868 |     |         }
 11869 |     |     }
 11870 |     | 
 11871 |     |     function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {
 11872 |     |         bytes32 m0;
 11873 |     |         bytes32 m1;
 11874 |     |         bytes32 m2;
 11875 |     |         bytes32 m3;
 11876 |     |         bytes32 m4;
 11877 |     |         bytes32 m5;
 11878 |     |         bytes32 m6;
 11879 |     |         assembly {
 11880 |     |             function writeString(pos, w) {
 11881 |     |                 let length := 0
 11882 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11883 |     |                 mstore(pos, length)
 11884 |     |                 let shift := sub(256, shl(3, length))
 11885 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11886 |     |             }
 11887 |     |             m0 := mload(0x00)
 11888 |     |             m1 := mload(0x20)
 11889 |     |             m2 := mload(0x40)
 11890 |     |             m3 := mload(0x60)
 11891 |     |             m4 := mload(0x80)
 11892 |     |             m5 := mload(0xa0)
 11893 |     |             m6 := mload(0xc0)
 11894 |     |             // Selector of `log(string,uint256,bool,bool)`.
 11895 |     |             mstore(0x00, 0x354c36d6)
 11896 |     |             mstore(0x20, 0x80)
 11897 |     |             mstore(0x40, p1)
 11898 |     |             mstore(0x60, p2)
 11899 |     |             mstore(0x80, p3)
 11900 |     |             writeString(0xa0, p0)
 11901 |     |         }
 11902 |     |         _sendLogPayload(0x1c, 0xc4);
 11903 |     |         assembly {
 11904 |     |             mstore(0x00, m0)
 11905 |     |             mstore(0x20, m1)
 11906 |     |             mstore(0x40, m2)
 11907 |     |             mstore(0x60, m3)
 11908 |     |             mstore(0x80, m4)
 11909 |     |             mstore(0xa0, m5)
 11910 |     |             mstore(0xc0, m6)
 11911 |     |         }
 11912 |     |     }
 11913 |     | 
 11914 |     |     function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {
 11915 |     |         bytes32 m0;
 11916 |     |         bytes32 m1;
 11917 |     |         bytes32 m2;
 11918 |     |         bytes32 m3;
 11919 |     |         bytes32 m4;
 11920 |     |         bytes32 m5;
 11921 |     |         bytes32 m6;
 11922 |     |         assembly {
 11923 |     |             function writeString(pos, w) {
 11924 |     |                 let length := 0
 11925 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11926 |     |                 mstore(pos, length)
 11927 |     |                 let shift := sub(256, shl(3, length))
 11928 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11929 |     |             }
 11930 |     |             m0 := mload(0x00)
 11931 |     |             m1 := mload(0x20)
 11932 |     |             m2 := mload(0x40)
 11933 |     |             m3 := mload(0x60)
 11934 |     |             m4 := mload(0x80)
 11935 |     |             m5 := mload(0xa0)
 11936 |     |             m6 := mload(0xc0)
 11937 |     |             // Selector of `log(string,uint256,bool,uint256)`.
 11938 |     |             mstore(0x00, 0xe41b6f6f)
 11939 |     |             mstore(0x20, 0x80)
 11940 |     |             mstore(0x40, p1)
 11941 |     |             mstore(0x60, p2)
 11942 |     |             mstore(0x80, p3)
 11943 |     |             writeString(0xa0, p0)
 11944 |     |         }
 11945 |     |         _sendLogPayload(0x1c, 0xc4);
 11946 |     |         assembly {
 11947 |     |             mstore(0x00, m0)
 11948 |     |             mstore(0x20, m1)
 11949 |     |             mstore(0x40, m2)
 11950 |     |             mstore(0x60, m3)
 11951 |     |             mstore(0x80, m4)
 11952 |     |             mstore(0xa0, m5)
 11953 |     |             mstore(0xc0, m6)
 11954 |     |         }
 11955 |     |     }
 11956 |     | 
 11957 |     |     function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
 11958 |     |         bytes32 m0;
 11959 |     |         bytes32 m1;
 11960 |     |         bytes32 m2;
 11961 |     |         bytes32 m3;
 11962 |     |         bytes32 m4;
 11963 |     |         bytes32 m5;
 11964 |     |         bytes32 m6;
 11965 |     |         bytes32 m7;
 11966 |     |         bytes32 m8;
 11967 |     |         assembly {
 11968 |     |             function writeString(pos, w) {
 11969 |     |                 let length := 0
 11970 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11971 |     |                 mstore(pos, length)
 11972 |     |                 let shift := sub(256, shl(3, length))
 11973 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11974 |     |             }
 11975 |     |             m0 := mload(0x00)
 11976 |     |             m1 := mload(0x20)
 11977 |     |             m2 := mload(0x40)
 11978 |     |             m3 := mload(0x60)
 11979 |     |             m4 := mload(0x80)
 11980 |     |             m5 := mload(0xa0)
 11981 |     |             m6 := mload(0xc0)
 11982 |     |             m7 := mload(0xe0)
 11983 |     |             m8 := mload(0x100)
 11984 |     |             // Selector of `log(string,uint256,bool,string)`.
 11985 |     |             mstore(0x00, 0xabf73a98)
 11986 |     |             mstore(0x20, 0x80)
 11987 |     |             mstore(0x40, p1)
 11988 |     |             mstore(0x60, p2)
 11989 |     |             mstore(0x80, 0xc0)
 11990 |     |             writeString(0xa0, p0)
 11991 |     |             writeString(0xe0, p3)
 11992 |     |         }
 11993 |     |         _sendLogPayload(0x1c, 0x104);
 11994 |     |         assembly {
 11995 |     |             mstore(0x00, m0)
 11996 |     |             mstore(0x20, m1)
 11997 |     |             mstore(0x40, m2)
 11998 |     |             mstore(0x60, m3)
 11999 |     |             mstore(0x80, m4)
 12000 |     |             mstore(0xa0, m5)
 12001 |     |             mstore(0xc0, m6)
 12002 |     |             mstore(0xe0, m7)
 12003 |     |             mstore(0x100, m8)
 12004 |     |         }
 12005 |     |     }
 12006 |     | 
 12007 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {
 12008 |     |         bytes32 m0;
 12009 |     |         bytes32 m1;
 12010 |     |         bytes32 m2;
 12011 |     |         bytes32 m3;
 12012 |     |         bytes32 m4;
 12013 |     |         bytes32 m5;
 12014 |     |         bytes32 m6;
 12015 |     |         assembly {
 12016 |     |             function writeString(pos, w) {
 12017 |     |                 let length := 0
 12018 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12019 |     |                 mstore(pos, length)
 12020 |     |                 let shift := sub(256, shl(3, length))
 12021 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12022 |     |             }
 12023 |     |             m0 := mload(0x00)
 12024 |     |             m1 := mload(0x20)
 12025 |     |             m2 := mload(0x40)
 12026 |     |             m3 := mload(0x60)
 12027 |     |             m4 := mload(0x80)
 12028 |     |             m5 := mload(0xa0)
 12029 |     |             m6 := mload(0xc0)
 12030 |     |             // Selector of `log(string,uint256,uint256,address)`.
 12031 |     |             mstore(0x00, 0xe21de278)
 12032 |     |             mstore(0x20, 0x80)
 12033 |     |             mstore(0x40, p1)
 12034 |     |             mstore(0x60, p2)
 12035 |     |             mstore(0x80, p3)
 12036 |     |             writeString(0xa0, p0)
 12037 |     |         }
 12038 |     |         _sendLogPayload(0x1c, 0xc4);
 12039 |     |         assembly {
 12040 |     |             mstore(0x00, m0)
 12041 |     |             mstore(0x20, m1)
 12042 |     |             mstore(0x40, m2)
 12043 |     |             mstore(0x60, m3)
 12044 |     |             mstore(0x80, m4)
 12045 |     |             mstore(0xa0, m5)
 12046 |     |             mstore(0xc0, m6)
 12047 |     |         }
 12048 |     |     }
 12049 |     | 
 12050 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {
 12051 |     |         bytes32 m0;
 12052 |     |         bytes32 m1;
 12053 |     |         bytes32 m2;
 12054 |     |         bytes32 m3;
 12055 |     |         bytes32 m4;
 12056 |     |         bytes32 m5;
 12057 |     |         bytes32 m6;
 12058 |     |         assembly {
 12059 |     |             function writeString(pos, w) {
 12060 |     |                 let length := 0
 12061 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12062 |     |                 mstore(pos, length)
 12063 |     |                 let shift := sub(256, shl(3, length))
 12064 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12065 |     |             }
 12066 |     |             m0 := mload(0x00)
 12067 |     |             m1 := mload(0x20)
 12068 |     |             m2 := mload(0x40)
 12069 |     |             m3 := mload(0x60)
 12070 |     |             m4 := mload(0x80)
 12071 |     |             m5 := mload(0xa0)
 12072 |     |             m6 := mload(0xc0)
 12073 |     |             // Selector of `log(string,uint256,uint256,bool)`.
 12074 |     |             mstore(0x00, 0x7626db92)
 12075 |     |             mstore(0x20, 0x80)
 12076 |     |             mstore(0x40, p1)
 12077 |     |             mstore(0x60, p2)
 12078 |     |             mstore(0x80, p3)
 12079 |     |             writeString(0xa0, p0)
 12080 |     |         }
 12081 |     |         _sendLogPayload(0x1c, 0xc4);
 12082 |     |         assembly {
 12083 |     |             mstore(0x00, m0)
 12084 |     |             mstore(0x20, m1)
 12085 |     |             mstore(0x40, m2)
 12086 |     |             mstore(0x60, m3)
 12087 |     |             mstore(0x80, m4)
 12088 |     |             mstore(0xa0, m5)
 12089 |     |             mstore(0xc0, m6)
 12090 |     |         }
 12091 |     |     }
 12092 |     | 
 12093 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 12094 |     |         bytes32 m0;
 12095 |     |         bytes32 m1;
 12096 |     |         bytes32 m2;
 12097 |     |         bytes32 m3;
 12098 |     |         bytes32 m4;
 12099 |     |         bytes32 m5;
 12100 |     |         bytes32 m6;
 12101 |     |         assembly {
 12102 |     |             function writeString(pos, w) {
 12103 |     |                 let length := 0
 12104 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12105 |     |                 mstore(pos, length)
 12106 |     |                 let shift := sub(256, shl(3, length))
 12107 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12108 |     |             }
 12109 |     |             m0 := mload(0x00)
 12110 |     |             m1 := mload(0x20)
 12111 |     |             m2 := mload(0x40)
 12112 |     |             m3 := mload(0x60)
 12113 |     |             m4 := mload(0x80)
 12114 |     |             m5 := mload(0xa0)
 12115 |     |             m6 := mload(0xc0)
 12116 |     |             // Selector of `log(string,uint256,uint256,uint256)`.
 12117 |     |             mstore(0x00, 0xa7a87853)
 12118 |     |             mstore(0x20, 0x80)
 12119 |     |             mstore(0x40, p1)
 12120 |     |             mstore(0x60, p2)
 12121 |     |             mstore(0x80, p3)
 12122 |     |             writeString(0xa0, p0)
 12123 |     |         }
 12124 |     |         _sendLogPayload(0x1c, 0xc4);
 12125 |     |         assembly {
 12126 |     |             mstore(0x00, m0)
 12127 |     |             mstore(0x20, m1)
 12128 |     |             mstore(0x40, m2)
 12129 |     |             mstore(0x60, m3)
 12130 |     |             mstore(0x80, m4)
 12131 |     |             mstore(0xa0, m5)
 12132 |     |             mstore(0xc0, m6)
 12133 |     |         }
 12134 |     |     }
 12135 |     | 
 12136 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
 12137 |     |         bytes32 m0;
 12138 |     |         bytes32 m1;
 12139 |     |         bytes32 m2;
 12140 |     |         bytes32 m3;
 12141 |     |         bytes32 m4;
 12142 |     |         bytes32 m5;
 12143 |     |         bytes32 m6;
 12144 |     |         bytes32 m7;
 12145 |     |         bytes32 m8;
 12146 |     |         assembly {
 12147 |     |             function writeString(pos, w) {
 12148 |     |                 let length := 0
 12149 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12150 |     |                 mstore(pos, length)
 12151 |     |                 let shift := sub(256, shl(3, length))
 12152 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12153 |     |             }
 12154 |     |             m0 := mload(0x00)
 12155 |     |             m1 := mload(0x20)
 12156 |     |             m2 := mload(0x40)
 12157 |     |             m3 := mload(0x60)
 12158 |     |             m4 := mload(0x80)
 12159 |     |             m5 := mload(0xa0)
 12160 |     |             m6 := mload(0xc0)
 12161 |     |             m7 := mload(0xe0)
 12162 |     |             m8 := mload(0x100)
 12163 |     |             // Selector of `log(string,uint256,uint256,string)`.
 12164 |     |             mstore(0x00, 0x854b3496)
 12165 |     |             mstore(0x20, 0x80)
 12166 |     |             mstore(0x40, p1)
 12167 |     |             mstore(0x60, p2)
 12168 |     |             mstore(0x80, 0xc0)
 12169 |     |             writeString(0xa0, p0)
 12170 |     |             writeString(0xe0, p3)
 12171 |     |         }
 12172 |     |         _sendLogPayload(0x1c, 0x104);
 12173 |     |         assembly {
 12174 |     |             mstore(0x00, m0)
 12175 |     |             mstore(0x20, m1)
 12176 |     |             mstore(0x40, m2)
 12177 |     |             mstore(0x60, m3)
 12178 |     |             mstore(0x80, m4)
 12179 |     |             mstore(0xa0, m5)
 12180 |     |             mstore(0xc0, m6)
 12181 |     |             mstore(0xe0, m7)
 12182 |     |             mstore(0x100, m8)
 12183 |     |         }
 12184 |     |     }
 12185 |     | 
 12186 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {
 12187 |     |         bytes32 m0;
 12188 |     |         bytes32 m1;
 12189 |     |         bytes32 m2;
 12190 |     |         bytes32 m3;
 12191 |     |         bytes32 m4;
 12192 |     |         bytes32 m5;
 12193 |     |         bytes32 m6;
 12194 |     |         bytes32 m7;
 12195 |     |         bytes32 m8;
 12196 |     |         assembly {
 12197 |     |             function writeString(pos, w) {
 12198 |     |                 let length := 0
 12199 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12200 |     |                 mstore(pos, length)
 12201 |     |                 let shift := sub(256, shl(3, length))
 12202 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12203 |     |             }
 12204 |     |             m0 := mload(0x00)
 12205 |     |             m1 := mload(0x20)
 12206 |     |             m2 := mload(0x40)
 12207 |     |             m3 := mload(0x60)
 12208 |     |             m4 := mload(0x80)
 12209 |     |             m5 := mload(0xa0)
 12210 |     |             m6 := mload(0xc0)
 12211 |     |             m7 := mload(0xe0)
 12212 |     |             m8 := mload(0x100)
 12213 |     |             // Selector of `log(string,uint256,string,address)`.
 12214 |     |             mstore(0x00, 0x7c4632a4)
 12215 |     |             mstore(0x20, 0x80)
 12216 |     |             mstore(0x40, p1)
 12217 |     |             mstore(0x60, 0xc0)
 12218 |     |             mstore(0x80, p3)
 12219 |     |             writeString(0xa0, p0)
 12220 |     |             writeString(0xe0, p2)
 12221 |     |         }
 12222 |     |         _sendLogPayload(0x1c, 0x104);
 12223 |     |         assembly {
 12224 |     |             mstore(0x00, m0)
 12225 |     |             mstore(0x20, m1)
 12226 |     |             mstore(0x40, m2)
 12227 |     |             mstore(0x60, m3)
 12228 |     |             mstore(0x80, m4)
 12229 |     |             mstore(0xa0, m5)
 12230 |     |             mstore(0xc0, m6)
 12231 |     |             mstore(0xe0, m7)
 12232 |     |             mstore(0x100, m8)
 12233 |     |         }
 12234 |     |     }
 12235 |     | 
 12236 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
 12237 |     |         bytes32 m0;
 12238 |     |         bytes32 m1;
 12239 |     |         bytes32 m2;
 12240 |     |         bytes32 m3;
 12241 |     |         bytes32 m4;
 12242 |     |         bytes32 m5;
 12243 |     |         bytes32 m6;
 12244 |     |         bytes32 m7;
 12245 |     |         bytes32 m8;
 12246 |     |         assembly {
 12247 |     |             function writeString(pos, w) {
 12248 |     |                 let length := 0
 12249 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12250 |     |                 mstore(pos, length)
 12251 |     |                 let shift := sub(256, shl(3, length))
 12252 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12253 |     |             }
 12254 |     |             m0 := mload(0x00)
 12255 |     |             m1 := mload(0x20)
 12256 |     |             m2 := mload(0x40)
 12257 |     |             m3 := mload(0x60)
 12258 |     |             m4 := mload(0x80)
 12259 |     |             m5 := mload(0xa0)
 12260 |     |             m6 := mload(0xc0)
 12261 |     |             m7 := mload(0xe0)
 12262 |     |             m8 := mload(0x100)
 12263 |     |             // Selector of `log(string,uint256,string,bool)`.
 12264 |     |             mstore(0x00, 0x7d24491d)
 12265 |     |             mstore(0x20, 0x80)
 12266 |     |             mstore(0x40, p1)
 12267 |     |             mstore(0x60, 0xc0)
 12268 |     |             mstore(0x80, p3)
 12269 |     |             writeString(0xa0, p0)
 12270 |     |             writeString(0xe0, p2)
 12271 |     |         }
 12272 |     |         _sendLogPayload(0x1c, 0x104);
 12273 |     |         assembly {
 12274 |     |             mstore(0x00, m0)
 12275 |     |             mstore(0x20, m1)
 12276 |     |             mstore(0x40, m2)
 12277 |     |             mstore(0x60, m3)
 12278 |     |             mstore(0x80, m4)
 12279 |     |             mstore(0xa0, m5)
 12280 |     |             mstore(0xc0, m6)
 12281 |     |             mstore(0xe0, m7)
 12282 |     |             mstore(0x100, m8)
 12283 |     |         }
 12284 |     |     }
 12285 |     | 
 12286 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
 12287 |     |         bytes32 m0;
 12288 |     |         bytes32 m1;
 12289 |     |         bytes32 m2;
 12290 |     |         bytes32 m3;
 12291 |     |         bytes32 m4;
 12292 |     |         bytes32 m5;
 12293 |     |         bytes32 m6;
 12294 |     |         bytes32 m7;
 12295 |     |         bytes32 m8;
 12296 |     |         assembly {
 12297 |     |             function writeString(pos, w) {
 12298 |     |                 let length := 0
 12299 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12300 |     |                 mstore(pos, length)
 12301 |     |                 let shift := sub(256, shl(3, length))
 12302 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12303 |     |             }
 12304 |     |             m0 := mload(0x00)
 12305 |     |             m1 := mload(0x20)
 12306 |     |             m2 := mload(0x40)
 12307 |     |             m3 := mload(0x60)
 12308 |     |             m4 := mload(0x80)
 12309 |     |             m5 := mload(0xa0)
 12310 |     |             m6 := mload(0xc0)
 12311 |     |             m7 := mload(0xe0)
 12312 |     |             m8 := mload(0x100)
 12313 |     |             // Selector of `log(string,uint256,string,uint256)`.
 12314 |     |             mstore(0x00, 0xc67ea9d1)
 12315 |     |             mstore(0x20, 0x80)
 12316 |     |             mstore(0x40, p1)
 12317 |     |             mstore(0x60, 0xc0)
 12318 |     |             mstore(0x80, p3)
 12319 |     |             writeString(0xa0, p0)
 12320 |     |             writeString(0xe0, p2)
 12321 |     |         }
 12322 |     |         _sendLogPayload(0x1c, 0x104);
 12323 |     |         assembly {
 12324 |     |             mstore(0x00, m0)
 12325 |     |             mstore(0x20, m1)
 12326 |     |             mstore(0x40, m2)
 12327 |     |             mstore(0x60, m3)
 12328 |     |             mstore(0x80, m4)
 12329 |     |             mstore(0xa0, m5)
 12330 |     |             mstore(0xc0, m6)
 12331 |     |             mstore(0xe0, m7)
 12332 |     |             mstore(0x100, m8)
 12333 |     |         }
 12334 |     |     }
 12335 |     | 
 12336 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
 12337 |     |         bytes32 m0;
 12338 |     |         bytes32 m1;
 12339 |     |         bytes32 m2;
 12340 |     |         bytes32 m3;
 12341 |     |         bytes32 m4;
 12342 |     |         bytes32 m5;
 12343 |     |         bytes32 m6;
 12344 |     |         bytes32 m7;
 12345 |     |         bytes32 m8;
 12346 |     |         bytes32 m9;
 12347 |     |         bytes32 m10;
 12348 |     |         assembly {
 12349 |     |             function writeString(pos, w) {
 12350 |     |                 let length := 0
 12351 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12352 |     |                 mstore(pos, length)
 12353 |     |                 let shift := sub(256, shl(3, length))
 12354 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12355 |     |             }
 12356 |     |             m0 := mload(0x00)
 12357 |     |             m1 := mload(0x20)
 12358 |     |             m2 := mload(0x40)
 12359 |     |             m3 := mload(0x60)
 12360 |     |             m4 := mload(0x80)
 12361 |     |             m5 := mload(0xa0)
 12362 |     |             m6 := mload(0xc0)
 12363 |     |             m7 := mload(0xe0)
 12364 |     |             m8 := mload(0x100)
 12365 |     |             m9 := mload(0x120)
 12366 |     |             m10 := mload(0x140)
 12367 |     |             // Selector of `log(string,uint256,string,string)`.
 12368 |     |             mstore(0x00, 0x5ab84e1f)
 12369 |     |             mstore(0x20, 0x80)
 12370 |     |             mstore(0x40, p1)
 12371 |     |             mstore(0x60, 0xc0)
 12372 |     |             mstore(0x80, 0x100)
 12373 |     |             writeString(0xa0, p0)
 12374 |     |             writeString(0xe0, p2)
 12375 |     |             writeString(0x120, p3)
 12376 |     |         }
 12377 |     |         _sendLogPayload(0x1c, 0x144);
 12378 |     |         assembly {
 12379 |     |             mstore(0x00, m0)
 12380 |     |             mstore(0x20, m1)
 12381 |     |             mstore(0x40, m2)
 12382 |     |             mstore(0x60, m3)
 12383 |     |             mstore(0x80, m4)
 12384 |     |             mstore(0xa0, m5)
 12385 |     |             mstore(0xc0, m6)
 12386 |     |             mstore(0xe0, m7)
 12387 |     |             mstore(0x100, m8)
 12388 |     |             mstore(0x120, m9)
 12389 |     |             mstore(0x140, m10)
 12390 |     |         }
 12391 |     |     }
 12392 |     | 
 12393 |     |     function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {
 12394 |     |         bytes32 m0;
 12395 |     |         bytes32 m1;
 12396 |     |         bytes32 m2;
 12397 |     |         bytes32 m3;
 12398 |     |         bytes32 m4;
 12399 |     |         bytes32 m5;
 12400 |     |         bytes32 m6;
 12401 |     |         bytes32 m7;
 12402 |     |         bytes32 m8;
 12403 |     |         assembly {
 12404 |     |             function writeString(pos, w) {
 12405 |     |                 let length := 0
 12406 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12407 |     |                 mstore(pos, length)
 12408 |     |                 let shift := sub(256, shl(3, length))
 12409 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12410 |     |             }
 12411 |     |             m0 := mload(0x00)
 12412 |     |             m1 := mload(0x20)
 12413 |     |             m2 := mload(0x40)
 12414 |     |             m3 := mload(0x60)
 12415 |     |             m4 := mload(0x80)
 12416 |     |             m5 := mload(0xa0)
 12417 |     |             m6 := mload(0xc0)
 12418 |     |             m7 := mload(0xe0)
 12419 |     |             m8 := mload(0x100)
 12420 |     |             // Selector of `log(string,string,address,address)`.
 12421 |     |             mstore(0x00, 0x439c7bef)
 12422 |     |             mstore(0x20, 0x80)
 12423 |     |             mstore(0x40, 0xc0)
 12424 |     |             mstore(0x60, p2)
 12425 |     |             mstore(0x80, p3)
 12426 |     |             writeString(0xa0, p0)
 12427 |     |             writeString(0xe0, p1)
 12428 |     |         }
 12429 |     |         _sendLogPayload(0x1c, 0x104);
 12430 |     |         assembly {
 12431 |     |             mstore(0x00, m0)
 12432 |     |             mstore(0x20, m1)
 12433 |     |             mstore(0x40, m2)
 12434 |     |             mstore(0x60, m3)
 12435 |     |             mstore(0x80, m4)
 12436 |     |             mstore(0xa0, m5)
 12437 |     |             mstore(0xc0, m6)
 12438 |     |             mstore(0xe0, m7)
 12439 |     |             mstore(0x100, m8)
 12440 |     |         }
 12441 |     |     }
 12442 |     | 
 12443 |     |     function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {
 12444 |     |         bytes32 m0;
 12445 |     |         bytes32 m1;
 12446 |     |         bytes32 m2;
 12447 |     |         bytes32 m3;
 12448 |     |         bytes32 m4;
 12449 |     |         bytes32 m5;
 12450 |     |         bytes32 m6;
 12451 |     |         bytes32 m7;
 12452 |     |         bytes32 m8;
 12453 |     |         assembly {
 12454 |     |             function writeString(pos, w) {
 12455 |     |                 let length := 0
 12456 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12457 |     |                 mstore(pos, length)
 12458 |     |                 let shift := sub(256, shl(3, length))
 12459 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12460 |     |             }
 12461 |     |             m0 := mload(0x00)
 12462 |     |             m1 := mload(0x20)
 12463 |     |             m2 := mload(0x40)
 12464 |     |             m3 := mload(0x60)
 12465 |     |             m4 := mload(0x80)
 12466 |     |             m5 := mload(0xa0)
 12467 |     |             m6 := mload(0xc0)
 12468 |     |             m7 := mload(0xe0)
 12469 |     |             m8 := mload(0x100)
 12470 |     |             // Selector of `log(string,string,address,bool)`.
 12471 |     |             mstore(0x00, 0x5ccd4e37)
 12472 |     |             mstore(0x20, 0x80)
 12473 |     |             mstore(0x40, 0xc0)
 12474 |     |             mstore(0x60, p2)
 12475 |     |             mstore(0x80, p3)
 12476 |     |             writeString(0xa0, p0)
 12477 |     |             writeString(0xe0, p1)
 12478 |     |         }
 12479 |     |         _sendLogPayload(0x1c, 0x104);
 12480 |     |         assembly {
 12481 |     |             mstore(0x00, m0)
 12482 |     |             mstore(0x20, m1)
 12483 |     |             mstore(0x40, m2)
 12484 |     |             mstore(0x60, m3)
 12485 |     |             mstore(0x80, m4)
 12486 |     |             mstore(0xa0, m5)
 12487 |     |             mstore(0xc0, m6)
 12488 |     |             mstore(0xe0, m7)
 12489 |     |             mstore(0x100, m8)
 12490 |     |         }
 12491 |     |     }
 12492 |     | 
 12493 |     |     function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {
 12494 |     |         bytes32 m0;
 12495 |     |         bytes32 m1;
 12496 |     |         bytes32 m2;
 12497 |     |         bytes32 m3;
 12498 |     |         bytes32 m4;
 12499 |     |         bytes32 m5;
 12500 |     |         bytes32 m6;
 12501 |     |         bytes32 m7;
 12502 |     |         bytes32 m8;
 12503 |     |         assembly {
 12504 |     |             function writeString(pos, w) {
 12505 |     |                 let length := 0
 12506 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12507 |     |                 mstore(pos, length)
 12508 |     |                 let shift := sub(256, shl(3, length))
 12509 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12510 |     |             }
 12511 |     |             m0 := mload(0x00)
 12512 |     |             m1 := mload(0x20)
 12513 |     |             m2 := mload(0x40)
 12514 |     |             m3 := mload(0x60)
 12515 |     |             m4 := mload(0x80)
 12516 |     |             m5 := mload(0xa0)
 12517 |     |             m6 := mload(0xc0)
 12518 |     |             m7 := mload(0xe0)
 12519 |     |             m8 := mload(0x100)
 12520 |     |             // Selector of `log(string,string,address,uint256)`.
 12521 |     |             mstore(0x00, 0x7cc3c607)
 12522 |     |             mstore(0x20, 0x80)
 12523 |     |             mstore(0x40, 0xc0)
 12524 |     |             mstore(0x60, p2)
 12525 |     |             mstore(0x80, p3)
 12526 |     |             writeString(0xa0, p0)
 12527 |     |             writeString(0xe0, p1)
 12528 |     |         }
 12529 |     |         _sendLogPayload(0x1c, 0x104);
 12530 |     |         assembly {
 12531 |     |             mstore(0x00, m0)
 12532 |     |             mstore(0x20, m1)
 12533 |     |             mstore(0x40, m2)
 12534 |     |             mstore(0x60, m3)
 12535 |     |             mstore(0x80, m4)
 12536 |     |             mstore(0xa0, m5)
 12537 |     |             mstore(0xc0, m6)
 12538 |     |             mstore(0xe0, m7)
 12539 |     |             mstore(0x100, m8)
 12540 |     |         }
 12541 |     |     }
 12542 |     | 
 12543 |     |     function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
 12544 |     |         bytes32 m0;
 12545 |     |         bytes32 m1;
 12546 |     |         bytes32 m2;
 12547 |     |         bytes32 m3;
 12548 |     |         bytes32 m4;
 12549 |     |         bytes32 m5;
 12550 |     |         bytes32 m6;
 12551 |     |         bytes32 m7;
 12552 |     |         bytes32 m8;
 12553 |     |         bytes32 m9;
 12554 |     |         bytes32 m10;
 12555 |     |         assembly {
 12556 |     |             function writeString(pos, w) {
 12557 |     |                 let length := 0
 12558 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12559 |     |                 mstore(pos, length)
 12560 |     |                 let shift := sub(256, shl(3, length))
 12561 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12562 |     |             }
 12563 |     |             m0 := mload(0x00)
 12564 |     |             m1 := mload(0x20)
 12565 |     |             m2 := mload(0x40)
 12566 |     |             m3 := mload(0x60)
 12567 |     |             m4 := mload(0x80)
 12568 |     |             m5 := mload(0xa0)
 12569 |     |             m6 := mload(0xc0)
 12570 |     |             m7 := mload(0xe0)
 12571 |     |             m8 := mload(0x100)
 12572 |     |             m9 := mload(0x120)
 12573 |     |             m10 := mload(0x140)
 12574 |     |             // Selector of `log(string,string,address,string)`.
 12575 |     |             mstore(0x00, 0xeb1bff80)
 12576 |     |             mstore(0x20, 0x80)
 12577 |     |             mstore(0x40, 0xc0)
 12578 |     |             mstore(0x60, p2)
 12579 |     |             mstore(0x80, 0x100)
 12580 |     |             writeString(0xa0, p0)
 12581 |     |             writeString(0xe0, p1)
 12582 |     |             writeString(0x120, p3)
 12583 |     |         }
 12584 |     |         _sendLogPayload(0x1c, 0x144);
 12585 |     |         assembly {
 12586 |     |             mstore(0x00, m0)
 12587 |     |             mstore(0x20, m1)
 12588 |     |             mstore(0x40, m2)
 12589 |     |             mstore(0x60, m3)
 12590 |     |             mstore(0x80, m4)
 12591 |     |             mstore(0xa0, m5)
 12592 |     |             mstore(0xc0, m6)
 12593 |     |             mstore(0xe0, m7)
 12594 |     |             mstore(0x100, m8)
 12595 |     |             mstore(0x120, m9)
 12596 |     |             mstore(0x140, m10)
 12597 |     |         }
 12598 |     |     }
 12599 |     | 
 12600 |     |     function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {
 12601 |     |         bytes32 m0;
 12602 |     |         bytes32 m1;
 12603 |     |         bytes32 m2;
 12604 |     |         bytes32 m3;
 12605 |     |         bytes32 m4;
 12606 |     |         bytes32 m5;
 12607 |     |         bytes32 m6;
 12608 |     |         bytes32 m7;
 12609 |     |         bytes32 m8;
 12610 |     |         assembly {
 12611 |     |             function writeString(pos, w) {
 12612 |     |                 let length := 0
 12613 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12614 |     |                 mstore(pos, length)
 12615 |     |                 let shift := sub(256, shl(3, length))
 12616 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12617 |     |             }
 12618 |     |             m0 := mload(0x00)
 12619 |     |             m1 := mload(0x20)
 12620 |     |             m2 := mload(0x40)
 12621 |     |             m3 := mload(0x60)
 12622 |     |             m4 := mload(0x80)
 12623 |     |             m5 := mload(0xa0)
 12624 |     |             m6 := mload(0xc0)
 12625 |     |             m7 := mload(0xe0)
 12626 |     |             m8 := mload(0x100)
 12627 |     |             // Selector of `log(string,string,bool,address)`.
 12628 |     |             mstore(0x00, 0xc371c7db)
 12629 |     |             mstore(0x20, 0x80)
 12630 |     |             mstore(0x40, 0xc0)
 12631 |     |             mstore(0x60, p2)
 12632 |     |             mstore(0x80, p3)
 12633 |     |             writeString(0xa0, p0)
 12634 |     |             writeString(0xe0, p1)
 12635 |     |         }
 12636 |     |         _sendLogPayload(0x1c, 0x104);
 12637 |     |         assembly {
 12638 |     |             mstore(0x00, m0)
 12639 |     |             mstore(0x20, m1)
 12640 |     |             mstore(0x40, m2)
 12641 |     |             mstore(0x60, m3)
 12642 |     |             mstore(0x80, m4)
 12643 |     |             mstore(0xa0, m5)
 12644 |     |             mstore(0xc0, m6)
 12645 |     |             mstore(0xe0, m7)
 12646 |     |             mstore(0x100, m8)
 12647 |     |         }
 12648 |     |     }
 12649 |     | 
 12650 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {
 12651 |     |         bytes32 m0;
 12652 |     |         bytes32 m1;
 12653 |     |         bytes32 m2;
 12654 |     |         bytes32 m3;
 12655 |     |         bytes32 m4;
 12656 |     |         bytes32 m5;
 12657 |     |         bytes32 m6;
 12658 |     |         bytes32 m7;
 12659 |     |         bytes32 m8;
 12660 |     |         assembly {
 12661 |     |             function writeString(pos, w) {
 12662 |     |                 let length := 0
 12663 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12664 |     |                 mstore(pos, length)
 12665 |     |                 let shift := sub(256, shl(3, length))
 12666 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12667 |     |             }
 12668 |     |             m0 := mload(0x00)
 12669 |     |             m1 := mload(0x20)
 12670 |     |             m2 := mload(0x40)
 12671 |     |             m3 := mload(0x60)
 12672 |     |             m4 := mload(0x80)
 12673 |     |             m5 := mload(0xa0)
 12674 |     |             m6 := mload(0xc0)
 12675 |     |             m7 := mload(0xe0)
 12676 |     |             m8 := mload(0x100)
 12677 |     |             // Selector of `log(string,string,bool,bool)`.
 12678 |     |             mstore(0x00, 0x40785869)
 12679 |     |             mstore(0x20, 0x80)
 12680 |     |             mstore(0x40, 0xc0)
 12681 |     |             mstore(0x60, p2)
 12682 |     |             mstore(0x80, p3)
 12683 |     |             writeString(0xa0, p0)
 12684 |     |             writeString(0xe0, p1)
 12685 |     |         }
 12686 |     |         _sendLogPayload(0x1c, 0x104);
 12687 |     |         assembly {
 12688 |     |             mstore(0x00, m0)
 12689 |     |             mstore(0x20, m1)
 12690 |     |             mstore(0x40, m2)
 12691 |     |             mstore(0x60, m3)
 12692 |     |             mstore(0x80, m4)
 12693 |     |             mstore(0xa0, m5)
 12694 |     |             mstore(0xc0, m6)
 12695 |     |             mstore(0xe0, m7)
 12696 |     |             mstore(0x100, m8)
 12697 |     |         }
 12698 |     |     }
 12699 |     | 
 12700 |     |     function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
 12701 |     |         bytes32 m0;
 12702 |     |         bytes32 m1;
 12703 |     |         bytes32 m2;
 12704 |     |         bytes32 m3;
 12705 |     |         bytes32 m4;
 12706 |     |         bytes32 m5;
 12707 |     |         bytes32 m6;
 12708 |     |         bytes32 m7;
 12709 |     |         bytes32 m8;
 12710 |     |         assembly {
 12711 |     |             function writeString(pos, w) {
 12712 |     |                 let length := 0
 12713 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12714 |     |                 mstore(pos, length)
 12715 |     |                 let shift := sub(256, shl(3, length))
 12716 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12717 |     |             }
 12718 |     |             m0 := mload(0x00)
 12719 |     |             m1 := mload(0x20)
 12720 |     |             m2 := mload(0x40)
 12721 |     |             m3 := mload(0x60)
 12722 |     |             m4 := mload(0x80)
 12723 |     |             m5 := mload(0xa0)
 12724 |     |             m6 := mload(0xc0)
 12725 |     |             m7 := mload(0xe0)
 12726 |     |             m8 := mload(0x100)
 12727 |     |             // Selector of `log(string,string,bool,uint256)`.
 12728 |     |             mstore(0x00, 0xd6aefad2)
 12729 |     |             mstore(0x20, 0x80)
 12730 |     |             mstore(0x40, 0xc0)
 12731 |     |             mstore(0x60, p2)
 12732 |     |             mstore(0x80, p3)
 12733 |     |             writeString(0xa0, p0)
 12734 |     |             writeString(0xe0, p1)
 12735 |     |         }
 12736 |     |         _sendLogPayload(0x1c, 0x104);
 12737 |     |         assembly {
 12738 |     |             mstore(0x00, m0)
 12739 |     |             mstore(0x20, m1)
 12740 |     |             mstore(0x40, m2)
 12741 |     |             mstore(0x60, m3)
 12742 |     |             mstore(0x80, m4)
 12743 |     |             mstore(0xa0, m5)
 12744 |     |             mstore(0xc0, m6)
 12745 |     |             mstore(0xe0, m7)
 12746 |     |             mstore(0x100, m8)
 12747 |     |         }
 12748 |     |     }
 12749 |     | 
 12750 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
 12751 |     |         bytes32 m0;
 12752 |     |         bytes32 m1;
 12753 |     |         bytes32 m2;
 12754 |     |         bytes32 m3;
 12755 |     |         bytes32 m4;
 12756 |     |         bytes32 m5;
 12757 |     |         bytes32 m6;
 12758 |     |         bytes32 m7;
 12759 |     |         bytes32 m8;
 12760 |     |         bytes32 m9;
 12761 |     |         bytes32 m10;
 12762 |     |         assembly {
 12763 |     |             function writeString(pos, w) {
 12764 |     |                 let length := 0
 12765 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12766 |     |                 mstore(pos, length)
 12767 |     |                 let shift := sub(256, shl(3, length))
 12768 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12769 |     |             }
 12770 |     |             m0 := mload(0x00)
 12771 |     |             m1 := mload(0x20)
 12772 |     |             m2 := mload(0x40)
 12773 |     |             m3 := mload(0x60)
 12774 |     |             m4 := mload(0x80)
 12775 |     |             m5 := mload(0xa0)
 12776 |     |             m6 := mload(0xc0)
 12777 |     |             m7 := mload(0xe0)
 12778 |     |             m8 := mload(0x100)
 12779 |     |             m9 := mload(0x120)
 12780 |     |             m10 := mload(0x140)
 12781 |     |             // Selector of `log(string,string,bool,string)`.
 12782 |     |             mstore(0x00, 0x5e84b0ea)
 12783 |     |             mstore(0x20, 0x80)
 12784 |     |             mstore(0x40, 0xc0)
 12785 |     |             mstore(0x60, p2)
 12786 |     |             mstore(0x80, 0x100)
 12787 |     |             writeString(0xa0, p0)
 12788 |     |             writeString(0xe0, p1)
 12789 |     |             writeString(0x120, p3)
 12790 |     |         }
 12791 |     |         _sendLogPayload(0x1c, 0x144);
 12792 |     |         assembly {
 12793 |     |             mstore(0x00, m0)
 12794 |     |             mstore(0x20, m1)
 12795 |     |             mstore(0x40, m2)
 12796 |     |             mstore(0x60, m3)
 12797 |     |             mstore(0x80, m4)
 12798 |     |             mstore(0xa0, m5)
 12799 |     |             mstore(0xc0, m6)
 12800 |     |             mstore(0xe0, m7)
 12801 |     |             mstore(0x100, m8)
 12802 |     |             mstore(0x120, m9)
 12803 |     |             mstore(0x140, m10)
 12804 |     |         }
 12805 |     |     }
 12806 |     | 
 12807 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {
 12808 |     |         bytes32 m0;
 12809 |     |         bytes32 m1;
 12810 |     |         bytes32 m2;
 12811 |     |         bytes32 m3;
 12812 |     |         bytes32 m4;
 12813 |     |         bytes32 m5;
 12814 |     |         bytes32 m6;
 12815 |     |         bytes32 m7;
 12816 |     |         bytes32 m8;
 12817 |     |         assembly {
 12818 |     |             function writeString(pos, w) {
 12819 |     |                 let length := 0
 12820 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12821 |     |                 mstore(pos, length)
 12822 |     |                 let shift := sub(256, shl(3, length))
 12823 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12824 |     |             }
 12825 |     |             m0 := mload(0x00)
 12826 |     |             m1 := mload(0x20)
 12827 |     |             m2 := mload(0x40)
 12828 |     |             m3 := mload(0x60)
 12829 |     |             m4 := mload(0x80)
 12830 |     |             m5 := mload(0xa0)
 12831 |     |             m6 := mload(0xc0)
 12832 |     |             m7 := mload(0xe0)
 12833 |     |             m8 := mload(0x100)
 12834 |     |             // Selector of `log(string,string,uint256,address)`.
 12835 |     |             mstore(0x00, 0x1023f7b2)
 12836 |     |             mstore(0x20, 0x80)
 12837 |     |             mstore(0x40, 0xc0)
 12838 |     |             mstore(0x60, p2)
 12839 |     |             mstore(0x80, p3)
 12840 |     |             writeString(0xa0, p0)
 12841 |     |             writeString(0xe0, p1)
 12842 |     |         }
 12843 |     |         _sendLogPayload(0x1c, 0x104);
 12844 |     |         assembly {
 12845 |     |             mstore(0x00, m0)
 12846 |     |             mstore(0x20, m1)
 12847 |     |             mstore(0x40, m2)
 12848 |     |             mstore(0x60, m3)
 12849 |     |             mstore(0x80, m4)
 12850 |     |             mstore(0xa0, m5)
 12851 |     |             mstore(0xc0, m6)
 12852 |     |             mstore(0xe0, m7)
 12853 |     |             mstore(0x100, m8)
 12854 |     |         }
 12855 |     |     }
 12856 |     | 
 12857 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
 12858 |     |         bytes32 m0;
 12859 |     |         bytes32 m1;
 12860 |     |         bytes32 m2;
 12861 |     |         bytes32 m3;
 12862 |     |         bytes32 m4;
 12863 |     |         bytes32 m5;
 12864 |     |         bytes32 m6;
 12865 |     |         bytes32 m7;
 12866 |     |         bytes32 m8;
 12867 |     |         assembly {
 12868 |     |             function writeString(pos, w) {
 12869 |     |                 let length := 0
 12870 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12871 |     |                 mstore(pos, length)
 12872 |     |                 let shift := sub(256, shl(3, length))
 12873 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12874 |     |             }
 12875 |     |             m0 := mload(0x00)
 12876 |     |             m1 := mload(0x20)
 12877 |     |             m2 := mload(0x40)
 12878 |     |             m3 := mload(0x60)
 12879 |     |             m4 := mload(0x80)
 12880 |     |             m5 := mload(0xa0)
 12881 |     |             m6 := mload(0xc0)
 12882 |     |             m7 := mload(0xe0)
 12883 |     |             m8 := mload(0x100)
 12884 |     |             // Selector of `log(string,string,uint256,bool)`.
 12885 |     |             mstore(0x00, 0xc3a8a654)
 12886 |     |             mstore(0x20, 0x80)
 12887 |     |             mstore(0x40, 0xc0)
 12888 |     |             mstore(0x60, p2)
 12889 |     |             mstore(0x80, p3)
 12890 |     |             writeString(0xa0, p0)
 12891 |     |             writeString(0xe0, p1)
 12892 |     |         }
 12893 |     |         _sendLogPayload(0x1c, 0x104);
 12894 |     |         assembly {
 12895 |     |             mstore(0x00, m0)
 12896 |     |             mstore(0x20, m1)
 12897 |     |             mstore(0x40, m2)
 12898 |     |             mstore(0x60, m3)
 12899 |     |             mstore(0x80, m4)
 12900 |     |             mstore(0xa0, m5)
 12901 |     |             mstore(0xc0, m6)
 12902 |     |             mstore(0xe0, m7)
 12903 |     |             mstore(0x100, m8)
 12904 |     |         }
 12905 |     |     }
 12906 |     | 
 12907 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
 12908 |     |         bytes32 m0;
 12909 |     |         bytes32 m1;
 12910 |     |         bytes32 m2;
 12911 |     |         bytes32 m3;
 12912 |     |         bytes32 m4;
 12913 |     |         bytes32 m5;
 12914 |     |         bytes32 m6;
 12915 |     |         bytes32 m7;
 12916 |     |         bytes32 m8;
 12917 |     |         assembly {
 12918 |     |             function writeString(pos, w) {
 12919 |     |                 let length := 0
 12920 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12921 |     |                 mstore(pos, length)
 12922 |     |                 let shift := sub(256, shl(3, length))
 12923 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12924 |     |             }
 12925 |     |             m0 := mload(0x00)
 12926 |     |             m1 := mload(0x20)
 12927 |     |             m2 := mload(0x40)
 12928 |     |             m3 := mload(0x60)
 12929 |     |             m4 := mload(0x80)
 12930 |     |             m5 := mload(0xa0)
 12931 |     |             m6 := mload(0xc0)
 12932 |     |             m7 := mload(0xe0)
 12933 |     |             m8 := mload(0x100)
 12934 |     |             // Selector of `log(string,string,uint256,uint256)`.
 12935 |     |             mstore(0x00, 0xf45d7d2c)
 12936 |     |             mstore(0x20, 0x80)
 12937 |     |             mstore(0x40, 0xc0)
 12938 |     |             mstore(0x60, p2)
 12939 |     |             mstore(0x80, p3)
 12940 |     |             writeString(0xa0, p0)
 12941 |     |             writeString(0xe0, p1)
 12942 |     |         }
 12943 |     |         _sendLogPayload(0x1c, 0x104);
 12944 |     |         assembly {
 12945 |     |             mstore(0x00, m0)
 12946 |     |             mstore(0x20, m1)
 12947 |     |             mstore(0x40, m2)
 12948 |     |             mstore(0x60, m3)
 12949 |     |             mstore(0x80, m4)
 12950 |     |             mstore(0xa0, m5)
 12951 |     |             mstore(0xc0, m6)
 12952 |     |             mstore(0xe0, m7)
 12953 |     |             mstore(0x100, m8)
 12954 |     |         }
 12955 |     |     }
 12956 |     | 
 12957 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
 12958 |     |         bytes32 m0;
 12959 |     |         bytes32 m1;
 12960 |     |         bytes32 m2;
 12961 |     |         bytes32 m3;
 12962 |     |         bytes32 m4;
 12963 |     |         bytes32 m5;
 12964 |     |         bytes32 m6;
 12965 |     |         bytes32 m7;
 12966 |     |         bytes32 m8;
 12967 |     |         bytes32 m9;
 12968 |     |         bytes32 m10;
 12969 |     |         assembly {
 12970 |     |             function writeString(pos, w) {
 12971 |     |                 let length := 0
 12972 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12973 |     |                 mstore(pos, length)
 12974 |     |                 let shift := sub(256, shl(3, length))
 12975 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12976 |     |             }
 12977 |     |             m0 := mload(0x00)
 12978 |     |             m1 := mload(0x20)
 12979 |     |             m2 := mload(0x40)
 12980 |     |             m3 := mload(0x60)
 12981 |     |             m4 := mload(0x80)
 12982 |     |             m5 := mload(0xa0)
 12983 |     |             m6 := mload(0xc0)
 12984 |     |             m7 := mload(0xe0)
 12985 |     |             m8 := mload(0x100)
 12986 |     |             m9 := mload(0x120)
 12987 |     |             m10 := mload(0x140)
 12988 |     |             // Selector of `log(string,string,uint256,string)`.
 12989 |     |             mstore(0x00, 0x5d1a971a)
 12990 |     |             mstore(0x20, 0x80)
 12991 |     |             mstore(0x40, 0xc0)
 12992 |     |             mstore(0x60, p2)
 12993 |     |             mstore(0x80, 0x100)
 12994 |     |             writeString(0xa0, p0)
 12995 |     |             writeString(0xe0, p1)
 12996 |     |             writeString(0x120, p3)
 12997 |     |         }
 12998 |     |         _sendLogPayload(0x1c, 0x144);
 12999 |     |         assembly {
 13000 |     |             mstore(0x00, m0)
 13001 |     |             mstore(0x20, m1)
 13002 |     |             mstore(0x40, m2)
 13003 |     |             mstore(0x60, m3)
 13004 |     |             mstore(0x80, m4)
 13005 |     |             mstore(0xa0, m5)
 13006 |     |             mstore(0xc0, m6)
 13007 |     |             mstore(0xe0, m7)
 13008 |     |             mstore(0x100, m8)
 13009 |     |             mstore(0x120, m9)
 13010 |     |             mstore(0x140, m10)
 13011 |     |         }
 13012 |     |     }
 13013 |     | 
 13014 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
 13015 |     |         bytes32 m0;
 13016 |     |         bytes32 m1;
 13017 |     |         bytes32 m2;
 13018 |     |         bytes32 m3;
 13019 |     |         bytes32 m4;
 13020 |     |         bytes32 m5;
 13021 |     |         bytes32 m6;
 13022 |     |         bytes32 m7;
 13023 |     |         bytes32 m8;
 13024 |     |         bytes32 m9;
 13025 |     |         bytes32 m10;
 13026 |     |         assembly {
 13027 |     |             function writeString(pos, w) {
 13028 |     |                 let length := 0
 13029 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13030 |     |                 mstore(pos, length)
 13031 |     |                 let shift := sub(256, shl(3, length))
 13032 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13033 |     |             }
 13034 |     |             m0 := mload(0x00)
 13035 |     |             m1 := mload(0x20)
 13036 |     |             m2 := mload(0x40)
 13037 |     |             m3 := mload(0x60)
 13038 |     |             m4 := mload(0x80)
 13039 |     |             m5 := mload(0xa0)
 13040 |     |             m6 := mload(0xc0)
 13041 |     |             m7 := mload(0xe0)
 13042 |     |             m8 := mload(0x100)
 13043 |     |             m9 := mload(0x120)
 13044 |     |             m10 := mload(0x140)
 13045 |     |             // Selector of `log(string,string,string,address)`.
 13046 |     |             mstore(0x00, 0x6d572f44)
 13047 |     |             mstore(0x20, 0x80)
 13048 |     |             mstore(0x40, 0xc0)
 13049 |     |             mstore(0x60, 0x100)
 13050 |     |             mstore(0x80, p3)
 13051 |     |             writeString(0xa0, p0)
 13052 |     |             writeString(0xe0, p1)
 13053 |     |             writeString(0x120, p2)
 13054 |     |         }
 13055 |     |         _sendLogPayload(0x1c, 0x144);
 13056 |     |         assembly {
 13057 |     |             mstore(0x00, m0)
 13058 |     |             mstore(0x20, m1)
 13059 |     |             mstore(0x40, m2)
 13060 |     |             mstore(0x60, m3)
 13061 |     |             mstore(0x80, m4)
 13062 |     |             mstore(0xa0, m5)
 13063 |     |             mstore(0xc0, m6)
 13064 |     |             mstore(0xe0, m7)
 13065 |     |             mstore(0x100, m8)
 13066 |     |             mstore(0x120, m9)
 13067 |     |             mstore(0x140, m10)
 13068 |     |         }
 13069 |     |     }
 13070 |     | 
 13071 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 13072 |     |         bytes32 m0;
 13073 |     |         bytes32 m1;
 13074 |     |         bytes32 m2;
 13075 |     |         bytes32 m3;
 13076 |     |         bytes32 m4;
 13077 |     |         bytes32 m5;
 13078 |     |         bytes32 m6;
 13079 |     |         bytes32 m7;
 13080 |     |         bytes32 m8;
 13081 |     |         bytes32 m9;
 13082 |     |         bytes32 m10;
 13083 |     |         assembly {
 13084 |     |             function writeString(pos, w) {
 13085 |     |                 let length := 0
 13086 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13087 |     |                 mstore(pos, length)
 13088 |     |                 let shift := sub(256, shl(3, length))
 13089 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13090 |     |             }
 13091 |     |             m0 := mload(0x00)
 13092 |     |             m1 := mload(0x20)
 13093 |     |             m2 := mload(0x40)
 13094 |     |             m3 := mload(0x60)
 13095 |     |             m4 := mload(0x80)
 13096 |     |             m5 := mload(0xa0)
 13097 |     |             m6 := mload(0xc0)
 13098 |     |             m7 := mload(0xe0)
 13099 |     |             m8 := mload(0x100)
 13100 |     |             m9 := mload(0x120)
 13101 |     |             m10 := mload(0x140)
 13102 |     |             // Selector of `log(string,string,string,bool)`.
 13103 |     |             mstore(0x00, 0x2c1754ed)
 13104 |     |             mstore(0x20, 0x80)
 13105 |     |             mstore(0x40, 0xc0)
 13106 |     |             mstore(0x60, 0x100)
 13107 |     |             mstore(0x80, p3)
 13108 |     |             writeString(0xa0, p0)
 13109 |     |             writeString(0xe0, p1)
 13110 |     |             writeString(0x120, p2)
 13111 |     |         }
 13112 |     |         _sendLogPayload(0x1c, 0x144);
 13113 |     |         assembly {
 13114 |     |             mstore(0x00, m0)
 13115 |     |             mstore(0x20, m1)
 13116 |     |             mstore(0x40, m2)
 13117 |     |             mstore(0x60, m3)
 13118 |     |             mstore(0x80, m4)
 13119 |     |             mstore(0xa0, m5)
 13120 |     |             mstore(0xc0, m6)
 13121 |     |             mstore(0xe0, m7)
 13122 |     |             mstore(0x100, m8)
 13123 |     |             mstore(0x120, m9)
 13124 |     |             mstore(0x140, m10)
 13125 |     |         }
 13126 |     |     }
 13127 |     | 
 13128 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 13129 |     |         bytes32 m0;
 13130 |     |         bytes32 m1;
 13131 |     |         bytes32 m2;
 13132 |     |         bytes32 m3;
 13133 |     |         bytes32 m4;
 13134 |     |         bytes32 m5;
 13135 |     |         bytes32 m6;
 13136 |     |         bytes32 m7;
 13137 |     |         bytes32 m8;
 13138 |     |         bytes32 m9;
 13139 |     |         bytes32 m10;
 13140 |     |         assembly {
 13141 |     |             function writeString(pos, w) {
 13142 |     |                 let length := 0
 13143 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13144 |     |                 mstore(pos, length)
 13145 |     |                 let shift := sub(256, shl(3, length))
 13146 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13147 |     |             }
 13148 |     |             m0 := mload(0x00)
 13149 |     |             m1 := mload(0x20)
 13150 |     |             m2 := mload(0x40)
 13151 |     |             m3 := mload(0x60)
 13152 |     |             m4 := mload(0x80)
 13153 |     |             m5 := mload(0xa0)
 13154 |     |             m6 := mload(0xc0)
 13155 |     |             m7 := mload(0xe0)
 13156 |     |             m8 := mload(0x100)
 13157 |     |             m9 := mload(0x120)
 13158 |     |             m10 := mload(0x140)
 13159 |     |             // Selector of `log(string,string,string,uint256)`.
 13160 |     |             mstore(0x00, 0x8eafb02b)
 13161 |     |             mstore(0x20, 0x80)
 13162 |     |             mstore(0x40, 0xc0)
 13163 |     |             mstore(0x60, 0x100)
 13164 |     |             mstore(0x80, p3)
 13165 |     |             writeString(0xa0, p0)
 13166 |     |             writeString(0xe0, p1)
 13167 |     |             writeString(0x120, p2)
 13168 |     |         }
 13169 |     |         _sendLogPayload(0x1c, 0x144);
 13170 |     |         assembly {
 13171 |     |             mstore(0x00, m0)
 13172 |     |             mstore(0x20, m1)
 13173 |     |             mstore(0x40, m2)
 13174 |     |             mstore(0x60, m3)
 13175 |     |             mstore(0x80, m4)
 13176 |     |             mstore(0xa0, m5)
 13177 |     |             mstore(0xc0, m6)
 13178 |     |             mstore(0xe0, m7)
 13179 |     |             mstore(0x100, m8)
 13180 |     |             mstore(0x120, m9)
 13181 |     |             mstore(0x140, m10)
 13182 |     |         }
 13183 |     |     }
 13184 |     | 
 13185 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 13186 |     |         bytes32 m0;
 13187 |     |         bytes32 m1;
 13188 |     |         bytes32 m2;
 13189 |     |         bytes32 m3;
 13190 |     |         bytes32 m4;
 13191 |     |         bytes32 m5;
 13192 |     |         bytes32 m6;
 13193 |     |         bytes32 m7;
 13194 |     |         bytes32 m8;
 13195 |     |         bytes32 m9;
 13196 |     |         bytes32 m10;
 13197 |     |         bytes32 m11;
 13198 |     |         bytes32 m12;
 13199 |     |         assembly {
 13200 |     |             function writeString(pos, w) {
 13201 |     |                 let length := 0
 13202 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13203 |     |                 mstore(pos, length)
 13204 |     |                 let shift := sub(256, shl(3, length))
 13205 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13206 |     |             }
 13207 |     |             m0 := mload(0x00)
 13208 |     |             m1 := mload(0x20)
 13209 |     |             m2 := mload(0x40)
 13210 |     |             m3 := mload(0x60)
 13211 |     |             m4 := mload(0x80)
 13212 |     |             m5 := mload(0xa0)
 13213 |     |             m6 := mload(0xc0)
 13214 |     |             m7 := mload(0xe0)
 13215 |     |             m8 := mload(0x100)
 13216 |     |             m9 := mload(0x120)
 13217 |     |             m10 := mload(0x140)
 13218 |     |             m11 := mload(0x160)
 13219 |     |             m12 := mload(0x180)
 13220 |     |             // Selector of `log(string,string,string,string)`.
 13221 |     |             mstore(0x00, 0xde68f20a)
 13222 |     |             mstore(0x20, 0x80)
 13223 |     |             mstore(0x40, 0xc0)
 13224 |     |             mstore(0x60, 0x100)
 13225 |     |             mstore(0x80, 0x140)
 13226 |     |             writeString(0xa0, p0)
 13227 |     |             writeString(0xe0, p1)
 13228 |     |             writeString(0x120, p2)
 13229 |     |             writeString(0x160, p3)
 13230 |     |         }
 13231 |     |         _sendLogPayload(0x1c, 0x184);
 13232 |     |         assembly {
 13233 |     |             mstore(0x00, m0)
 13234 |     |             mstore(0x20, m1)
 13235 |     |             mstore(0x40, m2)
 13236 |     |             mstore(0x60, m3)
 13237 |     |             mstore(0x80, m4)
 13238 |     |             mstore(0xa0, m5)
 13239 |     |             mstore(0xc0, m6)
 13240 |     |             mstore(0xe0, m7)
 13241 |     |             mstore(0x100, m8)
 13242 |     |             mstore(0x120, m9)
 13243 |     |             mstore(0x140, m10)
 13244 |     |             mstore(0x160, m11)
 13245 |     |             mstore(0x180, m12)
 13246 |     |         }
 13247 |     |     }
 13248 |     | }
 13249 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IAccessControlUpgradeable.sol";
   7 |     | import "../utils/ContextUpgradeable.sol";
   8 |     | import "../utils/StringsUpgradeable.sol";
   9 |     | import "../utils/introspection/ERC165Upgradeable.sol";
  10 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @dev Contract module that allows children to implement role-based access
  14 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  15 |     |  * members except through off-chain means by accessing the contract event logs. Some
  16 |     |  * applications may benefit from on-chain enumerability, for those cases see
  17 |     |  * {AccessControlEnumerable}.
  18 |     |  *
  19 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  20 |     |  * in the external API and be unique. The best way to achieve this is by
  21 |     |  * using `public constant` hash digests:
  22 |     |  *
  23 |     |  * ```solidity
  24 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  25 |     |  * ```
  26 |     |  *
  27 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  28 |     |  * function call, use {hasRole}:
  29 |     |  *
  30 |     |  * ```solidity
  31 |     |  * function foo() public {
  32 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  33 |     |  *     ...
  34 |     |  * }
  35 |     |  * ```
  36 |     |  *
  37 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  38 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  39 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  40 |     |  *
  41 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  42 |     |  * that only accounts with this role will be able to grant or revoke other
  43 |     |  * roles. More complex role relationships can be created by using
  44 |     |  * {_setRoleAdmin}.
  45 |     |  *
  46 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  47 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  48 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  49 |     |  * to enforce additional security measures for this role.
  50 |     |  */
  51 |     | abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {
  52 |     |     struct RoleData {
  53 |     |         mapping(address => bool) members;
  54 |     |         bytes32 adminRole;
  55 |     |     }
  56 |     | 
  57 |     |     mapping(bytes32 => RoleData) private _roles;
  58 |     | 
  59 |     |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  63 |     |      * with a standardized message including the required role.
  64 |     |      *
  65 |     |      * The format of the revert reason is given by the following regular expression:
  66 |     |      *
  67 |     |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
  68 |     |      *
  69 |     |      * _Available since v4.1._
  70 |     |      */
  71 |     |     modifier onlyRole(bytes32 role) {
  72 |     |         _checkRole(role);
  73 |     |         _;
  74 |     |     }
  75 |     | 
  76 |     |     function __AccessControl_init() internal onlyInitializing {
  77 |     |     }
  78 |     | 
  79 |     |     function __AccessControl_init_unchained() internal onlyInitializing {
  80 |     |     }
  81 |     |     /**
  82 |     |      * @dev See {IERC165-supportsInterface}.
  83 |     |      */
  84 | *   |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  85 | *   |         return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);
  86 |     |     }
  87 |     | 
  88 |     |     /**
  89 |     |      * @dev Returns `true` if `account` has been granted `role`.
  90 |     |      */
  91 |     |     function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
  92 |     |         return _roles[role].members[account];
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @dev Revert with a standard message if `_msgSender()` is missing `role`.
  97 |     |      * Overriding this function changes the behavior of the {onlyRole} modifier.
  98 |     |      *
  99 |     |      * Format of the revert message is described in {_checkRole}.
 100 |     |      *
 101 |     |      * _Available since v4.6._
 102 |     |      */
 103 |     |     function _checkRole(bytes32 role) internal view virtual {
 104 |     |         _checkRole(role, _msgSender());
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Revert with a standard message if `account` is missing `role`.
 109 |     |      *
 110 |     |      * The format of the revert reason is given by the following regular expression:
 111 |     |      *
 112 |     |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
 113 |     |      */
 114 |     |     function _checkRole(bytes32 role, address account) internal view virtual {
 115 |     |         if (!hasRole(role, account)) {
 116 |     |             revert(
 117 |     |                 string(
 118 |     |                     abi.encodePacked(
 119 |     |                         "AccessControl: account ",
 120 |     |                         StringsUpgradeable.toHexString(account),
 121 |     |                         " is missing role ",
 122 |     |                         StringsUpgradeable.toHexString(uint256(role), 32)
 123 |     |                     )
 124 |     |                 )
 125 |     |             );
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 131 |     |      * {revokeRole}.
 132 |     |      *
 133 |     |      * To change a role's admin, use {_setRoleAdmin}.
 134 |     |      */
 135 |     |     function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {
 136 |     |         return _roles[role].adminRole;
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Grants `role` to `account`.
 141 |     |      *
 142 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 143 |     |      * event.
 144 |     |      *
 145 |     |      * Requirements:
 146 |     |      *
 147 |     |      * - the caller must have ``role``'s admin role.
 148 |     |      *
 149 |     |      * May emit a {RoleGranted} event.
 150 |     |      */
 151 |     |     function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
 152 |     |         _grantRole(role, account);
 153 |     |     }
 154 |     | 
 155 |     |     /**
 156 |     |      * @dev Revokes `role` from `account`.
 157 |     |      *
 158 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 159 |     |      *
 160 |     |      * Requirements:
 161 |     |      *
 162 |     |      * - the caller must have ``role``'s admin role.
 163 |     |      *
 164 |     |      * May emit a {RoleRevoked} event.
 165 |     |      */
 166 |     |     function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
 167 |     |         _revokeRole(role, account);
 168 |     |     }
 169 |     | 
 170 |     |     /**
 171 |     |      * @dev Revokes `role` from the calling account.
 172 |     |      *
 173 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 174 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 175 |     |      * if they are compromised (such as when a trusted device is misplaced).
 176 |     |      *
 177 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 178 |     |      * event.
 179 |     |      *
 180 |     |      * Requirements:
 181 |     |      *
 182 |     |      * - the caller must be `account`.
 183 |     |      *
 184 |     |      * May emit a {RoleRevoked} event.
 185 |     |      */
 186 |     |     function renounceRole(bytes32 role, address account) public virtual override {
 187 |     |         require(account == _msgSender(), "AccessControl: can only renounce roles for self");
 188 |     | 
 189 |     |         _revokeRole(role, account);
 190 |     |     }
 191 |     | 
 192 |     |     /**
 193 |     |      * @dev Grants `role` to `account`.
 194 |     |      *
 195 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 196 |     |      * event. Note that unlike {grantRole}, this function doesn't perform any
 197 |     |      * checks on the calling account.
 198 |     |      *
 199 |     |      * May emit a {RoleGranted} event.
 200 |     |      *
 201 |     |      * [WARNING]
 202 |     |      * ====
 203 |     |      * This function should only be called from the constructor when setting
 204 |     |      * up the initial roles for the system.
 205 |     |      *
 206 |     |      * Using this function in any other way is effectively circumventing the admin
 207 |     |      * system imposed by {AccessControl}.
 208 |     |      * ====
 209 |     |      *
 210 |     |      * NOTE: This function is deprecated in favor of {_grantRole}.
 211 |     |      */
 212 |     |     function _setupRole(bytes32 role, address account) internal virtual {
 213 |     |         _grantRole(role, account);
 214 |     |     }
 215 |     | 
 216 |     |     /**
 217 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 218 |     |      *
 219 |     |      * Emits a {RoleAdminChanged} event.
 220 |     |      */
 221 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 222 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 223 |     |         _roles[role].adminRole = adminRole;
 224 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 225 |     |     }
 226 |     | 
 227 |     |     /**
 228 |     |      * @dev Grants `role` to `account`.
 229 |     |      *
 230 |     |      * Internal function without access restriction.
 231 |     |      *
 232 |     |      * May emit a {RoleGranted} event.
 233 |     |      */
 234 |     |     function _grantRole(bytes32 role, address account) internal virtual {
 235 |     |         if (!hasRole(role, account)) {
 236 |     |             _roles[role].members[account] = true;
 237 |     |             emit RoleGranted(role, account, _msgSender());
 238 |     |         }
 239 |     |     }
 240 |     | 
 241 |     |     /**
 242 |     |      * @dev Revokes `role` from `account`.
 243 |     |      *
 244 |     |      * Internal function without access restriction.
 245 |     |      *
 246 |     |      * May emit a {RoleRevoked} event.
 247 |     |      */
 248 |     |     function _revokeRole(bytes32 role, address account) internal virtual {
 249 |     |         if (hasRole(role, account)) {
 250 |     |             _roles[role].members[account] = false;
 251 |     |             emit RoleRevoked(role, account, _msgSender());
 252 |     |         }
 253 |     |     }
 254 |     | 
 255 |     |     /**
 256 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 257 |     |      * variables without shifting down storage in the inheritance chain.
 258 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 259 |     |      */
 260 |     |     uint256[49] private __gap;
 261 |     | }
 262 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev External interface of AccessControl declared to support ERC165 detection.
  8 |     |  */
  9 |     | interface IAccessControlUpgradeable {
 10 |     |     /**
 11 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
 12 |     |      *
 13 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
 14 |     |      * {RoleAdminChanged} not being emitted signaling this.
 15 |     |      *
 16 |     |      * _Available since v3.1._
 17 |     |      */
 18 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
 19 |     | 
 20 |     |     /**
 21 |     |      * @dev Emitted when `account` is granted `role`.
 22 |     |      *
 23 |     |      * `sender` is the account that originated the contract call, an admin role
 24 |     |      * bearer except when using {AccessControl-_setupRole}.
 25 |     |      */
 26 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Emitted when `account` is revoked `role`.
 30 |     |      *
 31 |     |      * `sender` is the account that originated the contract call:
 32 |     |      *   - if using `revokeRole`, it is the admin role bearer
 33 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
 34 |     |      */
 35 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
 36 |     | 
 37 |     |     /**
 38 |     |      * @dev Returns `true` if `account` has been granted `role`.
 39 |     |      */
 40 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 44 |     |      * {revokeRole}.
 45 |     |      *
 46 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
 47 |     |      */
 48 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
 49 |     | 
 50 |     |     /**
 51 |     |      * @dev Grants `role` to `account`.
 52 |     |      *
 53 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 54 |     |      * event.
 55 |     |      *
 56 |     |      * Requirements:
 57 |     |      *
 58 |     |      * - the caller must have ``role``'s admin role.
 59 |     |      */
 60 |     |     function grantRole(bytes32 role, address account) external;
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev Revokes `role` from `account`.
 64 |     |      *
 65 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 66 |     |      *
 67 |     |      * Requirements:
 68 |     |      *
 69 |     |      * - the caller must have ``role``'s admin role.
 70 |     |      */
 71 |     |     function revokeRole(bytes32 role, address account) external;
 72 |     | 
 73 |     |     /**
 74 |     |      * @dev Revokes `role` from the calling account.
 75 |     |      *
 76 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 77 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 78 |     |      * if they are compromised (such as when a trusted device is misplaced).
 79 |     |      *
 80 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
 81 |     |      * event.
 82 |     |      *
 83 |     |      * Requirements:
 84 |     |      *
 85 |     |      * - the caller must be `account`.
 86 |     |      */
 87 |     |     function renounceRole(bytes32 role, address account) external;
 88 |     | }
 89 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.2;
   5 |     | 
   6 |     | import "../../utils/AddressUpgradeable.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
  10 |     |  * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
  11 |     |  * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
  12 |     |  * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
  13 |     |  *
  14 |     |  * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
  15 |     |  * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
  16 |     |  * case an upgrade adds a module that needs to be initialized.
  17 |     |  *
  18 |     |  * For example:
  19 |     |  *
  20 |     |  * [.hljs-theme-light.nopadding]
  21 |     |  * ```solidity
  22 |     |  * contract MyToken is ERC20Upgradeable {
  23 |     |  *     function initialize() initializer public {
  24 |     |  *         __ERC20_init("MyToken", "MTK");
  25 |     |  *     }
  26 |     |  * }
  27 |     |  *
  28 |     |  * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
  29 |     |  *     function initializeV2() reinitializer(2) public {
  30 |     |  *         __ERC20Permit_init("MyToken");
  31 |     |  *     }
  32 |     |  * }
  33 |     |  * ```
  34 |     |  *
  35 |     |  * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
  36 |     |  * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
  37 |     |  *
  38 |     |  * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
  39 |     |  * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
  40 |     |  *
  41 |     |  * [CAUTION]
  42 |     |  * ====
  43 |     |  * Avoid leaving a contract uninitialized.
  44 |     |  *
  45 |     |  * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
  46 |     |  * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
  47 |     |  * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
  48 |     |  *
  49 |     |  * [.hljs-theme-light.nopadding]
  50 |     |  * ```
  51 |     |  * /// @custom:oz-upgrades-unsafe-allow constructor
  52 |     |  * constructor() {
  53 |     |  *     _disableInitializers();
  54 |     |  * }
  55 |     |  * ```
  56 |     |  * ====
  57 |     |  */
  58 |     | abstract contract Initializable {
  59 |     |     /**
  60 |     |      * @dev Indicates that the contract has been initialized.
  61 |     |      * @custom:oz-retyped-from bool
  62 |     |      */
  63 |     |     uint8 private _initialized;
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Indicates that the contract is in the process of being initialized.
  67 |     |      */
  68 |     |     bool private _initializing;
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Triggered when the contract has been initialized or reinitialized.
  72 |     |      */
  73 |     |     event Initialized(uint8 version);
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
  77 |     |      * `onlyInitializing` functions can be used to initialize parent contracts.
  78 |     |      *
  79 |     |      * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a
  80 |     |      * constructor.
  81 |     |      *
  82 |     |      * Emits an {Initialized} event.
  83 |     |      */
  84 |     |     modifier initializer() {
  85 |     |         bool isTopLevelCall = !_initializing;
  86 |     |         require(
  87 |     |             (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),
  88 |     |             "Initializable: contract is already initialized"
  89 |     |         );
  90 |     |         _initialized = 1;
  91 |     |         if (isTopLevelCall) {
  92 |     |             _initializing = true;
  93 |     |         }
  94 |     |         _;
  95 |     |         if (isTopLevelCall) {
  96 |     |             _initializing = false;
  97 |     |             emit Initialized(1);
  98 |     |         }
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
 103 |     |      * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
 104 |     |      * used to initialize parent contracts.
 105 |     |      *
 106 |     |      * A reinitializer may be used after the original initialization step. This is essential to configure modules that
 107 |     |      * are added through upgrades and that require initialization.
 108 |     |      *
 109 |     |      * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
 110 |     |      * cannot be nested. If one is invoked in the context of another, execution will revert.
 111 |     |      *
 112 |     |      * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
 113 |     |      * a contract, executing them in the right order is up to the developer or operator.
 114 |     |      *
 115 |     |      * WARNING: setting the version to 255 will prevent any future reinitialization.
 116 |     |      *
 117 |     |      * Emits an {Initialized} event.
 118 |     |      */
 119 |     |     modifier reinitializer(uint8 version) {
 120 |     |         require(!_initializing && _initialized < version, "Initializable: contract is already initialized");
 121 |     |         _initialized = version;
 122 |     |         _initializing = true;
 123 |     |         _;
 124 |     |         _initializing = false;
 125 |     |         emit Initialized(version);
 126 |     |     }
 127 |     | 
 128 |     |     /**
 129 |     |      * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
 130 |     |      * {initializer} and {reinitializer} modifiers, directly or indirectly.
 131 |     |      */
 132 |     |     modifier onlyInitializing() {
 133 |     |         require(_initializing, "Initializable: contract is not initializing");
 134 |     |         _;
 135 |     |     }
 136 |     | 
 137 |     |     /**
 138 |     |      * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
 139 |     |      * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
 140 |     |      * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
 141 |     |      * through proxies.
 142 |     |      *
 143 |     |      * Emits an {Initialized} event the first time it is successfully executed.
 144 |     |      */
 145 |     |     function _disableInitializers() internal virtual {
 146 |     |         require(!_initializing, "Initializable: contract is initializing");
 147 |     |         if (_initialized != type(uint8).max) {
 148 |     |             _initialized = type(uint8).max;
 149 |     |             emit Initialized(type(uint8).max);
 150 |     |         }
 151 |     |     }
 152 |     | 
 153 |     |     /**
 154 |     |      * @dev Returns the highest version that has been initialized. See {reinitializer}.
 155 |     |      */
 156 |     |     function _getInitializedVersion() internal view returns (uint8) {
 157 |     |         return _initialized;
 158 |     |     }
 159 |     | 
 160 |     |     /**
 161 |     |      * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
 162 |     |      */
 163 |     |     function _isInitializing() internal view returns (bool) {
 164 |     |         return _initializing;
 165 |     |     }
 166 |     | }
 167 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  9 |     |  *
 10 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 11 |     |  * available, which can be applied to functions to make sure there are no nested
 12 |     |  * (reentrant) calls to them.
 13 |     |  *
 14 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 15 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 16 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 17 |     |  * points to them.
 18 |     |  *
 19 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 20 |     |  * to protect against it, check out our blog post
 21 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 22 |     |  */
 23 |     | abstract contract ReentrancyGuardUpgradeable is Initializable {
 24 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 25 |     |     // word because each write operation emits an extra SLOAD to first read the
 26 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 27 |     |     // back. This is the compiler's defense against contract upgrades and
 28 |     |     // pointer aliasing, and it cannot be disabled.
 29 |     | 
 30 |     |     // The values being non-zero value makes deployment a bit more expensive,
 31 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 32 |     |     // amount. Since refunds are capped to a percentage of the total
 33 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 34 |     |     // increase the likelihood of the full refund coming into effect.
 35 |     |     uint256 private constant _NOT_ENTERED = 1;
 36 |     |     uint256 private constant _ENTERED = 2;
 37 |     | 
 38 |     |     uint256 private _status;
 39 |     | 
 40 |     |     function __ReentrancyGuard_init() internal onlyInitializing {
 41 |     |         __ReentrancyGuard_init_unchained();
 42 |     |     }
 43 |     | 
 44 |     |     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
 45 |     |         _status = _NOT_ENTERED;
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 50 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 51 |     |      * function is not supported. It is possible to prevent this from happening
 52 |     |      * by making the `nonReentrant` function external, and making it call a
 53 |     |      * `private` function that does the actual work.
 54 |     |      */
 55 |     |     modifier nonReentrant() {
 56 |     |         _nonReentrantBefore();
 57 |     |         _;
 58 |     |         _nonReentrantAfter();
 59 |     |     }
 60 |     | 
 61 |     |     function _nonReentrantBefore() private {
 62 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 63 |     |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
 64 |     | 
 65 |     |         // Any calls to nonReentrant after this point will fail
 66 |     |         _status = _ENTERED;
 67 |     |     }
 68 |     | 
 69 |     |     function _nonReentrantAfter() private {
 70 |     |         // By storing the original value once again, a refund is triggered (see
 71 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 72 |     |         _status = _NOT_ENTERED;
 73 |     |     }
 74 |     | 
 75 |     |     /**
 76 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 77 |     |      * `nonReentrant` function in the call stack.
 78 |     |      */
 79 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 80 |     |         return _status == _ENTERED;
 81 |     |     }
 82 |     | 
 83 |     |     /**
 84 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 85 |     |      * variables without shifting down storage in the inheritance chain.
 86 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 87 |     |      */
 88 |     |     uint256[49] private __gap;
 89 |     | }
 90 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20Upgradeable {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20PermitUpgradeable {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20Upgradeable.sol";
   7 |     | import "../extensions/IERC20PermitUpgradeable.sol";
   8 |     | import "../../../utils/AddressUpgradeable.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20Upgradeable {
  20 |     |     using AddressUpgradeable for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  24 |     |      * non-reverting calls are assumed to be successful.
  25 |     |      */
  26 |     |     function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {
  27 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  32 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  33 |     |      */
  34 |     |     function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {
  35 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  40 |     |      * {IERC20-approve}, and its usage is discouraged.
  41 |     |      *
  42 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  43 |     |      * {safeDecreaseAllowance} instead.
  44 |     |      */
  45 |     |     function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {
  46 |     |         // safeApprove should only be called when setting an initial allowance,
  47 |     |         // or when resetting it to zero. To increase and decrease it, use
  48 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  49 |     |         require(
  50 |     |             (value == 0) || (token.allowance(address(this), spender) == 0),
  51 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  52 |     |         );
  53 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  58 |     |      * non-reverting calls are assumed to be successful.
  59 |     |      */
  60 |     |     function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
  61 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  62 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  67 |     |      * non-reverting calls are assumed to be successful.
  68 |     |      */
  69 |     |     function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
  70 |     |         unchecked {
  71 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  72 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  73 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  79 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  80 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  81 |     |      */
  82 |     |     function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {
  83 |     |         bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);
  84 |     | 
  85 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  86 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
  87 |     |             _callOptionalReturn(token, approvalCall);
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
  93 |     |      * Revert on invalid signature.
  94 |     |      */
  95 |     |     function safePermit(
  96 |     |         IERC20PermitUpgradeable token,
  97 |     |         address owner,
  98 |     |         address spender,
  99 |     |         uint256 value,
 100 |     |         uint256 deadline,
 101 |     |         uint8 v,
 102 |     |         bytes32 r,
 103 |     |         bytes32 s
 104 |     |     ) internal {
 105 |     |         uint256 nonceBefore = token.nonces(owner);
 106 |     |         token.permit(owner, spender, value, deadline, v, r, s);
 107 |     |         uint256 nonceAfter = token.nonces(owner);
 108 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 113 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 114 |     |      * @param token The token targeted by the call.
 115 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 116 |     |      */
 117 |     |     function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
 118 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 119 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 120 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 121 |     | 
 122 |     |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 123 |     |         require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 128 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 129 |     |      * @param token The token targeted by the call.
 130 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 131 |     |      *
 132 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 133 |     |      */
 134 |     |     function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {
 135 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 136 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 137 |     |         // and not revert is the subcall reverts.
 138 |     | 
 139 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 140 |     |         return
 141 |     |             success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library AddressUpgradeable {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 |     |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 |     |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 |     |     ) internal returns (bytes memory) {
 104 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Provides information about the current execution context, including the
  9 |     |  * sender of the transaction and its data. While these are generally available
 10 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 11 |     |  * manner, since when dealing with meta-transactions the account sending and
 12 |     |  * paying for execution may not be the actual sender (as far as an application
 13 |     |  * is concerned).
 14 |     |  *
 15 |     |  * This contract is only required for intermediate, library-like contracts.
 16 |     |  */
 17 |     | abstract contract ContextUpgradeable is Initializable {
 18 |     |     function __Context_init() internal onlyInitializing {
 19 |     |     }
 20 |     | 
 21 |     |     function __Context_init_unchained() internal onlyInitializing {
 22 |     |     }
 23 |     |     function _msgSender() internal view virtual returns (address) {
 24 |     |         return msg.sender;
 25 |     |     }
 26 |     | 
 27 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 28 |     |         return msg.data;
 29 |     |     }
 30 |     | 
 31 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 32 |     |         return 0;
 33 |     |     }
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 37 |     |      * variables without shifting down storage in the inheritance chain.
 38 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 39 |     |      */
 40 |     |     uint256[50] private __gap;
 41 |     | }
 42 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/StringsUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./math/MathUpgradeable.sol";
  7 |     | import "./math/SignedMathUpgradeable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev String operations.
 11 |     |  */
 12 |     | library StringsUpgradeable {
 13 |     |     bytes16 private constant _SYMBOLS = "0123456789abcdef";
 14 |     |     uint8 private constant _ADDRESS_LENGTH = 20;
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 18 |     |      */
 19 |     |     function toString(uint256 value) internal pure returns (string memory) {
 20 |     |         unchecked {
 21 |     |             uint256 length = MathUpgradeable.log10(value) + 1;
 22 |     |             string memory buffer = new string(length);
 23 |     |             uint256 ptr;
 24 |     |             /// @solidity memory-safe-assembly
 25 |     |             assembly {
 26 |     |                 ptr := add(buffer, add(32, length))
 27 |     |             }
 28 |     |             while (true) {
 29 |     |                 ptr--;
 30 |     |                 /// @solidity memory-safe-assembly
 31 |     |                 assembly {
 32 |     |                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
 33 |     |                 }
 34 |     |                 value /= 10;
 35 |     |                 if (value == 0) break;
 36 |     |             }
 37 |     |             return buffer;
 38 |     |         }
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
 43 |     |      */
 44 |     |     function toString(int256 value) internal pure returns (string memory) {
 45 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 50 |     |      */
 51 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 52 |     |         unchecked {
 53 |     |             return toHexString(value, MathUpgradeable.log256(value) + 1);
 54 |     |         }
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 59 |     |      */
 60 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 61 |     |         bytes memory buffer = new bytes(2 * length + 2);
 62 |     |         buffer[0] = "0";
 63 |     |         buffer[1] = "x";
 64 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 65 |     |             buffer[i] = _SYMBOLS[value & 0xf];
 66 |     |             value >>= 4;
 67 |     |         }
 68 |     |         require(value == 0, "Strings: hex length insufficient");
 69 |     |         return string(buffer);
 70 |     |     }
 71 |     | 
 72 |     |     /**
 73 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
 74 |     |      */
 75 |     |     function toHexString(address addr) internal pure returns (string memory) {
 76 |     |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Returns true if the two strings are equal.
 81 |     |      */
 82 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 83 |     |         return keccak256(bytes(a)) == keccak256(bytes(b));
 84 |     |     }
 85 |     | }
 86 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165Upgradeable.sol";
  7 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Implementation of the {IERC165} interface.
 11 |     |  *
 12 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 13 |     |  * for the additional interface id that will be supported. For example:
 14 |     |  *
 15 |     |  * ```solidity
 16 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 17 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 18 |     |  * }
 19 |     |  * ```
 20 |     |  *
 21 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 22 |     |  */
 23 |     | abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
 24 |     |     function __ERC165_init() internal onlyInitializing {
 25 |     |     }
 26 |     | 
 27 |     |     function __ERC165_init_unchained() internal onlyInitializing {
 28 |     |     }
 29 |     |     /**
 30 |     |      * @dev See {IERC165-supportsInterface}.
 31 |     |      */
 32 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 33 |     |         return interfaceId == type(IERC165Upgradeable).interfaceId;
 34 |     |     }
 35 |     | 
 36 |     |     /**
 37 |     |      * @dev This empty reserved space is put in place to allow future versions to add new
 38 |     |      * variables without shifting down storage in the inheritance chain.
 39 |     |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
 40 |     |      */
 41 |     |     uint256[50] private __gap;
 42 |     | }
 43 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165Upgradeable {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library MathUpgradeable {
  10 |     |     enum Rounding {
  11 |     |         Down, // Toward negative infinity
  12 |     |         Up, // Toward infinity
  13 |     |         Zero // Toward zero
  14 |     |     }
  15 |     | 
  16 |     |     /**
  17 |     |      * @dev Returns the largest of two numbers.
  18 |     |      */
  19 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a > b ? a : b;
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Returns the smallest of two numbers.
  25 |     |      */
  26 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  27 |     |         return a < b ? a : b;
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  32 |     |      * zero.
  33 |     |      */
  34 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  35 |     |         // (a + b) / 2 can overflow.
  36 |     |         return (a & b) + (a ^ b) / 2;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Returns the ceiling of the division of two numbers.
  41 |     |      *
  42 |     |      * This differs from standard division with `/` in that it rounds up instead
  43 |     |      * of rounding down.
  44 |     |      */
  45 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  46 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
  47 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  52 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
  53 |     |      * with further edits by Uniswap Labs also under MIT license.
  54 |     |      */
  55 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
  56 |     |         unchecked {
  57 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
  58 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  59 |     |             // variables such that product = prod1 * 2^256 + prod0.
  60 |     |             uint256 prod0; // Least significant 256 bits of the product
  61 |     |             uint256 prod1; // Most significant 256 bits of the product
  62 |     |             assembly {
  63 |     |                 let mm := mulmod(x, y, not(0))
  64 |     |                 prod0 := mul(x, y)
  65 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  66 |     |             }
  67 |     | 
  68 |     |             // Handle non-overflow cases, 256 by 256 division.
  69 |     |             if (prod1 == 0) {
  70 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
  71 |     |                 // The surrounding unchecked block does not change this fact.
  72 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
  73 |     |                 return prod0 / denominator;
  74 |     |             }
  75 |     | 
  76 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
  77 |     |             require(denominator > prod1, "Math: mulDiv overflow");
  78 |     | 
  79 |     |             ///////////////////////////////////////////////
  80 |     |             // 512 by 256 division.
  81 |     |             ///////////////////////////////////////////////
  82 |     | 
  83 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
  84 |     |             uint256 remainder;
  85 |     |             assembly {
  86 |     |                 // Compute remainder using mulmod.
  87 |     |                 remainder := mulmod(x, y, denominator)
  88 |     | 
  89 |     |                 // Subtract 256 bit number from 512 bit number.
  90 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  91 |     |                 prod0 := sub(prod0, remainder)
  92 |     |             }
  93 |     | 
  94 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
  95 |     |             // See https://cs.stackexchange.com/q/138556/92363.
  96 |     | 
  97 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
  98 |     |             uint256 twos = denominator & (~denominator + 1);
  99 |     |             assembly {
 100 |     |                 // Divide denominator by twos.
 101 |     |                 denominator := div(denominator, twos)
 102 |     | 
 103 |     |                 // Divide [prod1 prod0] by twos.
 104 |     |                 prod0 := div(prod0, twos)
 105 |     | 
 106 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 107 |     |                 twos := add(div(sub(0, twos), twos), 1)
 108 |     |             }
 109 |     | 
 110 |     |             // Shift in bits from prod1 into prod0.
 111 |     |             prod0 |= prod1 * twos;
 112 |     | 
 113 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 114 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 115 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 116 |     |             uint256 inverse = (3 * denominator) ^ 2;
 117 |     | 
 118 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 119 |     |             // in modular arithmetic, doubling the correct bits in each step.
 120 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 121 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 122 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 123 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 124 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 125 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 126 |     | 
 127 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 128 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 129 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 130 |     |             // is no longer required.
 131 |     |             result = prod0 * inverse;
 132 |     |             return result;
 133 |     |         }
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 138 |     |      */
 139 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 140 |     |         uint256 result = mulDiv(x, y, denominator);
 141 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 142 |     |             result += 1;
 143 |     |         }
 144 |     |         return result;
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
 149 |     |      *
 150 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 151 |     |      */
 152 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 153 |     |         if (a == 0) {
 154 |     |             return 0;
 155 |     |         }
 156 |     | 
 157 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 158 |     |         //
 159 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 160 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 161 |     |         //
 162 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 163 |     |         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 164 |     |         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 165 |     |         //
 166 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 167 |     |         uint256 result = 1 << (log2(a) >> 1);
 168 |     | 
 169 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 170 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 171 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 172 |     |         // into the expected uint128 result.
 173 |     |         unchecked {
 174 |     |             result = (result + a / result) >> 1;
 175 |     |             result = (result + a / result) >> 1;
 176 |     |             result = (result + a / result) >> 1;
 177 |     |             result = (result + a / result) >> 1;
 178 |     |             result = (result + a / result) >> 1;
 179 |     |             result = (result + a / result) >> 1;
 180 |     |             result = (result + a / result) >> 1;
 181 |     |             return min(result, a / result);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 187 |     |      */
 188 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 189 |     |         unchecked {
 190 |     |             uint256 result = sqrt(a);
 191 |     |             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Return the log in base 2, rounded down, of a positive value.
 197 |     |      * Returns 0 if given 0.
 198 |     |      */
 199 |     |     function log2(uint256 value) internal pure returns (uint256) {
 200 |     |         uint256 result = 0;
 201 |     |         unchecked {
 202 |     |             if (value >> 128 > 0) {
 203 |     |                 value >>= 128;
 204 |     |                 result += 128;
 205 |     |             }
 206 |     |             if (value >> 64 > 0) {
 207 |     |                 value >>= 64;
 208 |     |                 result += 64;
 209 |     |             }
 210 |     |             if (value >> 32 > 0) {
 211 |     |                 value >>= 32;
 212 |     |                 result += 32;
 213 |     |             }
 214 |     |             if (value >> 16 > 0) {
 215 |     |                 value >>= 16;
 216 |     |                 result += 16;
 217 |     |             }
 218 |     |             if (value >> 8 > 0) {
 219 |     |                 value >>= 8;
 220 |     |                 result += 8;
 221 |     |             }
 222 |     |             if (value >> 4 > 0) {
 223 |     |                 value >>= 4;
 224 |     |                 result += 4;
 225 |     |             }
 226 |     |             if (value >> 2 > 0) {
 227 |     |                 value >>= 2;
 228 |     |                 result += 2;
 229 |     |             }
 230 |     |             if (value >> 1 > 0) {
 231 |     |                 result += 1;
 232 |     |             }
 233 |     |         }
 234 |     |         return result;
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 239 |     |      * Returns 0 if given 0.
 240 |     |      */
 241 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 242 |     |         unchecked {
 243 |     |             uint256 result = log2(value);
 244 |     |             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Return the log in base 10, rounded down, of a positive value.
 250 |     |      * Returns 0 if given 0.
 251 |     |      */
 252 |     |     function log10(uint256 value) internal pure returns (uint256) {
 253 |     |         uint256 result = 0;
 254 |     |         unchecked {
 255 |     |             if (value >= 10 ** 64) {
 256 |     |                 value /= 10 ** 64;
 257 |     |                 result += 64;
 258 |     |             }
 259 |     |             if (value >= 10 ** 32) {
 260 |     |                 value /= 10 ** 32;
 261 |     |                 result += 32;
 262 |     |             }
 263 |     |             if (value >= 10 ** 16) {
 264 |     |                 value /= 10 ** 16;
 265 |     |                 result += 16;
 266 |     |             }
 267 |     |             if (value >= 10 ** 8) {
 268 |     |                 value /= 10 ** 8;
 269 |     |                 result += 8;
 270 |     |             }
 271 |     |             if (value >= 10 ** 4) {
 272 |     |                 value /= 10 ** 4;
 273 |     |                 result += 4;
 274 |     |             }
 275 |     |             if (value >= 10 ** 2) {
 276 |     |                 value /= 10 ** 2;
 277 |     |                 result += 2;
 278 |     |             }
 279 |     |             if (value >= 10 ** 1) {
 280 |     |                 result += 1;
 281 |     |             }
 282 |     |         }
 283 |     |         return result;
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 288 |     |      * Returns 0 if given 0.
 289 |     |      */
 290 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 291 |     |         unchecked {
 292 |     |             uint256 result = log10(value);
 293 |     |             return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Return the log in base 256, rounded down, of a positive value.
 299 |     |      * Returns 0 if given 0.
 300 |     |      *
 301 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 302 |     |      */
 303 |     |     function log256(uint256 value) internal pure returns (uint256) {
 304 |     |         uint256 result = 0;
 305 |     |         unchecked {
 306 |     |             if (value >> 128 > 0) {
 307 |     |                 value >>= 128;
 308 |     |                 result += 16;
 309 |     |             }
 310 |     |             if (value >> 64 > 0) {
 311 |     |                 value >>= 64;
 312 |     |                 result += 8;
 313 |     |             }
 314 |     |             if (value >> 32 > 0) {
 315 |     |                 value >>= 32;
 316 |     |                 result += 4;
 317 |     |             }
 318 |     |             if (value >> 16 > 0) {
 319 |     |                 value >>= 16;
 320 |     |                 result += 2;
 321 |     |             }
 322 |     |             if (value >> 8 > 0) {
 323 |     |                 result += 1;
 324 |     |             }
 325 |     |         }
 326 |     |         return result;
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 331 |     |      * Returns 0 if given 0.
 332 |     |      */
 333 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 334 |     |         unchecked {
 335 |     |             uint256 result = log256(value);
 336 |     |             return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);
 337 |     |         }
 338 |     |     }
 339 |     | }
 340 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts-upgradeable/contracts/utils/math/SignedMathUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 |     | library SignedMathUpgradeable {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/access/AccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IAccessControl.sol";
   7 |     | import "../utils/Context.sol";
   8 |     | import "../utils/Strings.sol";
   9 |     | import "../utils/introspection/ERC165.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Contract module that allows children to implement role-based access
  13 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  14 |     |  * members except through off-chain means by accessing the contract event logs. Some
  15 |     |  * applications may benefit from on-chain enumerability, for those cases see
  16 |     |  * {AccessControlEnumerable}.
  17 |     |  *
  18 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  19 |     |  * in the external API and be unique. The best way to achieve this is by
  20 |     |  * using `public constant` hash digests:
  21 |     |  *
  22 |     |  * ```solidity
  23 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  24 |     |  * ```
  25 |     |  *
  26 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  27 |     |  * function call, use {hasRole}:
  28 |     |  *
  29 |     |  * ```solidity
  30 |     |  * function foo() public {
  31 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  32 |     |  *     ...
  33 |     |  * }
  34 |     |  * ```
  35 |     |  *
  36 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  37 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  38 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  39 |     |  *
  40 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  41 |     |  * that only accounts with this role will be able to grant or revoke other
  42 |     |  * roles. More complex role relationships can be created by using
  43 |     |  * {_setRoleAdmin}.
  44 |     |  *
  45 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  46 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  47 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  48 |     |  * to enforce additional security measures for this role.
  49 |     |  */
  50 |     | abstract contract AccessControl is Context, IAccessControl, ERC165 {
  51 |     |     struct RoleData {
  52 |     |         mapping(address => bool) members;
  53 |     |         bytes32 adminRole;
  54 |     |     }
  55 |     | 
  56 |     |     mapping(bytes32 => RoleData) private _roles;
  57 |     | 
  58 |     |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  62 |     |      * with a standardized message including the required role.
  63 |     |      *
  64 |     |      * The format of the revert reason is given by the following regular expression:
  65 |     |      *
  66 |     |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
  67 |     |      *
  68 |     |      * _Available since v4.1._
  69 |     |      */
  70 |     |     modifier onlyRole(bytes32 role) {
  71 |     |         _checkRole(role);
  72 |     |         _;
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev See {IERC165-supportsInterface}.
  77 |     |      */
  78 | *   |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  79 |     |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Returns `true` if `account` has been granted `role`.
  84 |     |      */
  85 |     |     function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
  86 |     |         return _roles[role].members[account];
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Revert with a standard message if `_msgSender()` is missing `role`.
  91 |     |      * Overriding this function changes the behavior of the {onlyRole} modifier.
  92 |     |      *
  93 |     |      * Format of the revert message is described in {_checkRole}.
  94 |     |      *
  95 |     |      * _Available since v4.6._
  96 |     |      */
  97 | *   |     function _checkRole(bytes32 role) internal view virtual {
  98 | *   |         _checkRole(role, _msgSender());
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Revert with a standard message if `account` is missing `role`.
 103 |     |      *
 104 |     |      * The format of the revert reason is given by the following regular expression:
 105 |     |      *
 106 |     |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
 107 |     |      */
 108 |     |     function _checkRole(bytes32 role, address account) internal view virtual {
 109 |     |         if (!hasRole(role, account)) {
 110 |     |             revert(
 111 |     |                 string(
 112 |     |                     abi.encodePacked(
 113 |     |                         "AccessControl: account ",
 114 |     |                         Strings.toHexString(account),
 115 |     |                         " is missing role ",
 116 |     |                         Strings.toHexString(uint256(role), 32)
 117 |     |                     )
 118 |     |                 )
 119 |     |             );
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 125 |     |      * {revokeRole}.
 126 |     |      *
 127 |     |      * To change a role's admin, use {_setRoleAdmin}.
 128 |     |      */
 129 |     |     function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {
 130 |     |         return _roles[role].adminRole;
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev Grants `role` to `account`.
 135 |     |      *
 136 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 137 |     |      * event.
 138 |     |      *
 139 |     |      * Requirements:
 140 |     |      *
 141 |     |      * - the caller must have ``role``'s admin role.
 142 |     |      *
 143 |     |      * May emit a {RoleGranted} event.
 144 |     |      */
 145 |     |     function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
 146 |     |         _grantRole(role, account);
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Revokes `role` from `account`.
 151 |     |      *
 152 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 153 |     |      *
 154 |     |      * Requirements:
 155 |     |      *
 156 |     |      * - the caller must have ``role``'s admin role.
 157 |     |      *
 158 |     |      * May emit a {RoleRevoked} event.
 159 |     |      */
 160 |     |     function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
 161 |     |         _revokeRole(role, account);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Revokes `role` from the calling account.
 166 |     |      *
 167 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 168 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 169 |     |      * if they are compromised (such as when a trusted device is misplaced).
 170 |     |      *
 171 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 172 |     |      * event.
 173 |     |      *
 174 |     |      * Requirements:
 175 |     |      *
 176 |     |      * - the caller must be `account`.
 177 |     |      *
 178 |     |      * May emit a {RoleRevoked} event.
 179 |     |      */
 180 |     |     function renounceRole(bytes32 role, address account) public virtual override {
 181 |     |         require(account == _msgSender(), "AccessControl: can only renounce roles for self");
 182 |     | 
 183 |     |         _revokeRole(role, account);
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @dev Grants `role` to `account`.
 188 |     |      *
 189 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 190 |     |      * event. Note that unlike {grantRole}, this function doesn't perform any
 191 |     |      * checks on the calling account.
 192 |     |      *
 193 |     |      * May emit a {RoleGranted} event.
 194 |     |      *
 195 |     |      * [WARNING]
 196 |     |      * ====
 197 |     |      * This function should only be called from the constructor when setting
 198 |     |      * up the initial roles for the system.
 199 |     |      *
 200 |     |      * Using this function in any other way is effectively circumventing the admin
 201 |     |      * system imposed by {AccessControl}.
 202 |     |      * ====
 203 |     |      *
 204 |     |      * NOTE: This function is deprecated in favor of {_grantRole}.
 205 |     |      */
 206 |     |     function _setupRole(bytes32 role, address account) internal virtual {
 207 |     |         _grantRole(role, account);
 208 |     |     }
 209 |     | 
 210 |     |     /**
 211 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 212 |     |      *
 213 |     |      * Emits a {RoleAdminChanged} event.
 214 |     |      */
 215 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 216 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 217 |     |         _roles[role].adminRole = adminRole;
 218 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 219 |     |     }
 220 |     | 
 221 |     |     /**
 222 |     |      * @dev Grants `role` to `account`.
 223 |     |      *
 224 |     |      * Internal function without access restriction.
 225 |     |      *
 226 |     |      * May emit a {RoleGranted} event.
 227 |     |      */
 228 |     |     function _grantRole(bytes32 role, address account) internal virtual {
 229 |     |         if (!hasRole(role, account)) {
 230 |     |             _roles[role].members[account] = true;
 231 |     |             emit RoleGranted(role, account, _msgSender());
 232 |     |         }
 233 |     |     }
 234 |     | 
 235 |     |     /**
 236 |     |      * @dev Revokes `role` from `account`.
 237 |     |      *
 238 |     |      * Internal function without access restriction.
 239 |     |      *
 240 |     |      * May emit a {RoleRevoked} event.
 241 |     |      */
 242 |     |     function _revokeRole(bytes32 role, address account) internal virtual {
 243 |     |         if (hasRole(role, account)) {
 244 |     |             _roles[role].members[account] = false;
 245 |     |             emit RoleRevoked(role, account, _msgSender());
 246 |     |         }
 247 |     |     }
 248 |     | }
 249 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev External interface of AccessControl declared to support ERC165 detection.
  8 |     |  */
  9 |     | interface IAccessControl {
 10 |     |     /**
 11 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
 12 |     |      *
 13 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
 14 |     |      * {RoleAdminChanged} not being emitted signaling this.
 15 |     |      *
 16 |     |      * _Available since v3.1._
 17 |     |      */
 18 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
 19 |     | 
 20 |     |     /**
 21 |     |      * @dev Emitted when `account` is granted `role`.
 22 |     |      *
 23 |     |      * `sender` is the account that originated the contract call, an admin role
 24 |     |      * bearer except when using {AccessControl-_setupRole}.
 25 |     |      */
 26 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Emitted when `account` is revoked `role`.
 30 |     |      *
 31 |     |      * `sender` is the account that originated the contract call:
 32 |     |      *   - if using `revokeRole`, it is the admin role bearer
 33 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
 34 |     |      */
 35 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
 36 |     | 
 37 |     |     /**
 38 |     |      * @dev Returns `true` if `account` has been granted `role`.
 39 |     |      */
 40 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 44 |     |      * {revokeRole}.
 45 |     |      *
 46 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
 47 |     |      */
 48 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
 49 |     | 
 50 |     |     /**
 51 |     |      * @dev Grants `role` to `account`.
 52 |     |      *
 53 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 54 |     |      * event.
 55 |     |      *
 56 |     |      * Requirements:
 57 |     |      *
 58 |     |      * - the caller must have ``role``'s admin role.
 59 |     |      */
 60 |     |     function grantRole(bytes32 role, address account) external;
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev Revokes `role` from `account`.
 64 |     |      *
 65 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 66 |     |      *
 67 |     |      * Requirements:
 68 |     |      *
 69 |     |      * - the caller must have ``role``'s admin role.
 70 |     |      */
 71 |     |     function revokeRole(bytes32 role, address account) external;
 72 |     | 
 73 |     |     /**
 74 |     |      * @dev Revokes `role` from the calling account.
 75 |     |      *
 76 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 77 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 78 |     |      * if they are compromised (such as when a trusted device is misplaced).
 79 |     |      *
 80 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
 81 |     |      * event.
 82 |     |      *
 83 |     |      * Requirements:
 84 |     |      *
 85 |     |      * - the caller must be `account`.
 86 |     |      */
 87 |     |     function renounceRole(bytes32 role, address account) external;
 88 |     | }
 89 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/access/Ownable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../utils/Context.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides a basic access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available the modifier
 17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 18 |     |  * the owner.
 19 |     |  */
 20 |     | abstract contract Ownable is Context {
 21 |     |     address private _owner;
 22 |     | 
 23 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 27 |     |      */
 28 |     |     constructor() {
 29 |     |         _transferOwnership(_msgSender());
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Throws if called by any account other than the owner.
 34 |     |      */
 35 |     |     modifier onlyOwner() {
 36 |     |         _checkOwner();
 37 |     |         _;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Returns the address of the current owner.
 42 |     |      */
 43 |     |     function owner() public view virtual returns (address) {
 44 |     |         return _owner;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Throws if the sender is not the owner.
 49 |     |      */
 50 |     |     function _checkOwner() internal view virtual {
 51 |     |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 56 |     |      * `onlyOwner` functions. Can only be called by the current owner.
 57 |     |      *
 58 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
 59 |     |      * thereby disabling any functionality that is only available to the owner.
 60 |     |      */
 61 |     |     function renounceOwnership() public virtual onlyOwner {
 62 |     |         _transferOwnership(address(0));
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 67 |     |      * Can only be called by the current owner.
 68 |     |      */
 69 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 70 |     |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 71 |     |         _transferOwnership(newOwner);
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 76 |     |      * Internal function without access restriction.
 77 |     |      */
 78 |     |     function _transferOwnership(address newOwner) internal virtual {
 79 |     |         address oldOwner = _owner;
 80 |     |         _owner = newOwner;
 81 |     |         emit OwnershipTransferred(oldOwner, newOwner);
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.
  8 |     |  *
  9 |     |  * _Available since v4.8.3._
 10 |     |  */
 11 |     | interface IERC1967 {
 12 |     |     /**
 13 |     |      * @dev Emitted when the implementation is upgraded.
 14 |     |      */
 15 |     |     event Upgraded(address indexed implementation);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Emitted when the admin account has changed.
 19 |     |      */
 20 |     |     event AdminChanged(address previousAdmin, address newAdmin);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Emitted when the beacon is changed.
 24 |     |      */
 25 |     |     event BeaconUpgraded(address indexed beacon);
 26 |     | }
 27 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified
  8 |     |  * proxy whose upgrades are fully controlled by the current implementation.
  9 |     |  */
 10 |     | interface IERC1822Proxiable {
 11 |     |     /**
 12 |     |      * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation
 13 |     |      * address.
 14 |     |      *
 15 |     |      * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks
 16 |     |      * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this
 17 |     |      * function revert if invoked through a proxy.
 18 |     |      */
 19 |     |     function proxiableUUID() external view returns (bytes32);
 20 |     | }
 21 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/proxy/Clones.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for
  8 |     |  * deploying minimal proxy contracts, also known as "clones".
  9 |     |  *
 10 |     |  * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies
 11 |     |  * > a minimal bytecode implementation that delegates all calls to a known, fixed address.
 12 |     |  *
 13 |     |  * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`
 14 |     |  * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the
 15 |     |  * deterministic method.
 16 |     |  *
 17 |     |  * _Available since v3.4._
 18 |     |  */
 19 |     | library Clones {
 20 |     |     /**
 21 |     |      * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.
 22 |     |      *
 23 |     |      * This function uses the create opcode, which should never revert.
 24 |     |      */
 25 |     |     function clone(address implementation) internal returns (address instance) {
 26 |     |         /// @solidity memory-safe-assembly
 27 |     |         assembly {
 28 |     |             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
 29 |     |             // of the `implementation` address with the bytecode before the address.
 30 |     |             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
 31 |     |             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
 32 |     |             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
 33 |     |             instance := create(0, 0x09, 0x37)
 34 |     |         }
 35 |     |         require(instance != address(0), "ERC1167: create failed");
 36 |     |     }
 37 |     | 
 38 |     |     /**
 39 |     |      * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.
 40 |     |      *
 41 |     |      * This function uses the create2 opcode and a `salt` to deterministically deploy
 42 |     |      * the clone. Using the same `implementation` and `salt` multiple time will revert, since
 43 |     |      * the clones cannot be deployed twice at the same address.
 44 |     |      */
 45 |     |     function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {
 46 |     |         /// @solidity memory-safe-assembly
 47 |     |         assembly {
 48 |     |             // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
 49 |     |             // of the `implementation` address with the bytecode before the address.
 50 |     |             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
 51 |     |             // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
 52 |     |             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
 53 |     |             instance := create2(0, 0x09, 0x37, salt)
 54 |     |         }
 55 |     |         require(instance != address(0), "ERC1167: create2 failed");
 56 |     |     }
 57 |     | 
 58 |     |     /**
 59 |     |      * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
 60 |     |      */
 61 |     |     function predictDeterministicAddress(
 62 |     |         address implementation,
 63 |     |         bytes32 salt,
 64 |     |         address deployer
 65 |     |     ) internal pure returns (address predicted) {
 66 |     |         /// @solidity memory-safe-assembly
 67 |     |         assembly {
 68 |     |             let ptr := mload(0x40)
 69 |     |             mstore(add(ptr, 0x38), deployer)
 70 |     |             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
 71 |     |             mstore(add(ptr, 0x14), implementation)
 72 |     |             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
 73 |     |             mstore(add(ptr, 0x58), salt)
 74 |     |             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
 75 |     |             predicted := keccak256(add(ptr, 0x43), 0x55)
 76 |     |         }
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
 81 |     |      */
 82 |     |     function predictDeterministicAddress(
 83 |     |         address implementation,
 84 |     |         bytes32 salt
 85 |     |     ) internal view returns (address predicted) {
 86 |     |         return predictDeterministicAddress(implementation, salt, address(this));
 87 |     |     }
 88 |     | }
 89 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../Proxy.sol";
  7 |     | import "./ERC1967Upgrade.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an
 11 |     |  * implementation address that can be changed. This address is stored in storage in the location specified by
 12 |     |  * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the
 13 |     |  * implementation behind the proxy.
 14 |     |  */
 15 |     | contract ERC1967Proxy is Proxy, ERC1967Upgrade {
 16 |     |     /**
 17 |     |      * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.
 18 |     |      *
 19 |     |      * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded
 20 |     |      * function call, and allows initializing the storage of the proxy like a Solidity constructor.
 21 |     |      */
 22 |     |     constructor(address _logic, bytes memory _data) payable {
 23 |     |         _upgradeToAndCall(_logic, _data, false);
 24 |     |     }
 25 |     | 
 26 |     |     /**
 27 |     |      * @dev Returns the current implementation address.
 28 |     |      */
 29 | *   |     function _implementation() internal view virtual override returns (address impl) {
 30 | *   |         return ERC1967Upgrade._getImplementation();
 31 |     |     }
 32 |     | }
 33 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.2;
   5 |     | 
   6 |     | import "../beacon/IBeacon.sol";
   7 |     | import "../../interfaces/IERC1967.sol";
   8 |     | import "../../interfaces/draft-IERC1822.sol";
   9 |     | import "../../utils/Address.sol";
  10 |     | import "../../utils/StorageSlot.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @dev This abstract contract provides getters and event emitting update functions for
  14 |     |  * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.
  15 |     |  *
  16 |     |  * _Available since v4.1._
  17 |     |  */
  18 |     | abstract contract ERC1967Upgrade is IERC1967 {
  19 |     |     // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1
  20 |     |     bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Storage slot with the address of the current implementation.
  24 |     |      * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is
  25 |     |      * validated in the constructor.
  26 |     |      */
  27 | *   |     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  28 |     | 
  29 |     |     /**
  30 |     |      * @dev Returns the current implementation address.
  31 |     |      */
  32 | *   |     function _getImplementation() internal view returns (address) {
  33 | *   |         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
  34 |     |     }
  35 |     | 
  36 |     |     /**
  37 |     |      * @dev Stores a new address in the EIP1967 implementation slot.
  38 |     |      */
  39 |     |     function _setImplementation(address newImplementation) private {
  40 |     |         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
  41 |     |         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Perform implementation upgrade
  46 |     |      *
  47 |     |      * Emits an {Upgraded} event.
  48 |     |      */
  49 |     |     function _upgradeTo(address newImplementation) internal {
  50 |     |         _setImplementation(newImplementation);
  51 |     |         emit Upgraded(newImplementation);
  52 |     |     }
  53 |     | 
  54 |     |     /**
  55 |     |      * @dev Perform implementation upgrade with additional setup call.
  56 |     |      *
  57 |     |      * Emits an {Upgraded} event.
  58 |     |      */
  59 |     |     function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {
  60 |     |         _upgradeTo(newImplementation);
  61 |     |         if (data.length > 0 || forceCall) {
  62 |     |             Address.functionDelegateCall(newImplementation, data);
  63 |     |         }
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
  68 |     |      *
  69 |     |      * Emits an {Upgraded} event.
  70 |     |      */
  71 |     |     function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {
  72 |     |         // Upgrades from old implementations will perform a rollback test. This test requires the new
  73 |     |         // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing
  74 |     |         // this special case will break upgrade paths from old UUPS implementation to new ones.
  75 |     |         if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {
  76 |     |             _setImplementation(newImplementation);
  77 |     |         } else {
  78 |     |             try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {
  79 |     |                 require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");
  80 |     |             } catch {
  81 |     |                 revert("ERC1967Upgrade: new implementation is not UUPS");
  82 |     |             }
  83 |     |             _upgradeToAndCall(newImplementation, data, forceCall);
  84 |     |         }
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev Storage slot with the admin of the contract.
  89 |     |      * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is
  90 |     |      * validated in the constructor.
  91 |     |      */
  92 | *   |     bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Returns the current admin.
  96 |     |      */
  97 | *   |     function _getAdmin() internal view returns (address) {
  98 | *   |         return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Stores a new address in the EIP1967 admin slot.
 103 |     |      */
 104 |     |     function _setAdmin(address newAdmin) private {
 105 |     |         require(newAdmin != address(0), "ERC1967: new admin is the zero address");
 106 |     |         StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Changes the admin of the proxy.
 111 |     |      *
 112 |     |      * Emits an {AdminChanged} event.
 113 |     |      */
 114 |     |     function _changeAdmin(address newAdmin) internal {
 115 |     |         emit AdminChanged(_getAdmin(), newAdmin);
 116 |     |         _setAdmin(newAdmin);
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
 121 |     |      * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.
 122 |     |      */
 123 |     |     bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
 124 |     | 
 125 |     |     /**
 126 |     |      * @dev Returns the current beacon.
 127 |     |      */
 128 |     |     function _getBeacon() internal view returns (address) {
 129 |     |         return StorageSlot.getAddressSlot(_BEACON_SLOT).value;
 130 |     |     }
 131 |     | 
 132 |     |     /**
 133 |     |      * @dev Stores a new beacon in the EIP1967 beacon slot.
 134 |     |      */
 135 |     |     function _setBeacon(address newBeacon) private {
 136 |     |         require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract");
 137 |     |         require(
 138 |     |             Address.isContract(IBeacon(newBeacon).implementation()),
 139 |     |             "ERC1967: beacon implementation is not a contract"
 140 |     |         );
 141 |     |         StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;
 142 |     |     }
 143 |     | 
 144 |     |     /**
 145 |     |      * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does
 146 |     |      * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).
 147 |     |      *
 148 |     |      * Emits a {BeaconUpgraded} event.
 149 |     |      */
 150 |     |     function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {
 151 |     |         _setBeacon(newBeacon);
 152 |     |         emit BeaconUpgraded(newBeacon);
 153 |     |         if (data.length > 0 || forceCall) {
 154 |     |             Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);
 155 |     |         }
 156 |     |     }
 157 |     | }
 158 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/proxy/Proxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
  8 |     |  * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
  9 |     |  * be specified by overriding the virtual {_implementation} function.
 10 |     |  *
 11 |     |  * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 12 |     |  * different contract through the {_delegate} function.
 13 |     |  *
 14 |     |  * The success and return data of the delegated call will be returned back to the caller of the proxy.
 15 |     |  */
 16 |     | abstract contract Proxy {
 17 |     |     /**
 18 |     |      * @dev Delegates the current call to `implementation`.
 19 |     |      *
 20 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 21 |     |      */
 22 | *   |     function _delegate(address implementation) internal virtual {
 23 |     |         assembly {
 24 |     |             // Copy msg.data. We take full control of memory in this inline assembly
 25 |     |             // block because it will not return to Solidity code. We overwrite the
 26 |     |             // Solidity scratch pad at memory position 0.
 27 | *   |             calldatacopy(0, 0, calldatasize())
 28 |     | 
 29 |     |             // Call the implementation.
 30 |     |             // out and outsize are 0 because we don't know the size yet.
 31 | *   |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
 32 |     | 
 33 |     |             // Copy the returned data.
 34 | *   |             returndatacopy(0, 0, returndatasize())
 35 |     | 
 36 | *   |             switch result
 37 |     |             // delegatecall returns 0 on error.
 38 | *   |             case 0 {
 39 |     |                 revert(0, returndatasize())
 40 |     |             }
 41 |     |             default {
 42 | *   |                 return(0, returndatasize())
 43 |     |             }
 44 |     |         }
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function
 49 |     |      * and {_fallback} should delegate.
 50 |     |      */
 51 |     |     function _implementation() internal view virtual returns (address);
 52 |     | 
 53 |     |     /**
 54 |     |      * @dev Delegates the current call to the address returned by `_implementation()`.
 55 |     |      *
 56 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 57 |     |      */
 58 | *   |     function _fallback() internal virtual {
 59 |     |         _beforeFallback();
 60 | *   |         _delegate(_implementation());
 61 |     |     }
 62 |     | 
 63 |     |     /**
 64 |     |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
 65 |     |      * function in the contract matches the call data.
 66 |     |      */
 67 |     |     fallback() external payable virtual {
 68 | *   |         _fallback();
 69 |     |     }
 70 |     | 
 71 |     |     /**
 72 |     |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data
 73 |     |      * is empty.
 74 |     |      */
 75 |     |     receive() external payable virtual {
 76 |     |         _fallback();
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`
 81 |     |      * call, or as part of the Solidity `fallback` or `receive` functions.
 82 |     |      *
 83 |     |      * If overridden should call `super._beforeFallback()`.
 84 |     |      */
 85 |     |     function _beforeFallback() internal virtual {}
 86 |     | }
 87 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This is the interface that {BeaconProxy} expects of its beacon.
  8 |     |  */
  9 |     | interface IBeacon {
 10 |     |     /**
 11 |     |      * @dev Must return an address that can be used as a delegate call target.
 12 |     |      *
 13 |     |      * {BeaconProxy} will check that this address is a contract.
 14 |     |      */
 15 |     |     function implementation() external view returns (address);
 16 |     | }
 17 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./TransparentUpgradeableProxy.sol";
  7 |     | import "../../access/Ownable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an
 11 |     |  * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.
 12 |     |  */
 13 |     | contract ProxyAdmin is Ownable {
 14 |     |     /**
 15 |     |      * @dev Returns the current implementation of `proxy`.
 16 |     |      *
 17 |     |      * Requirements:
 18 |     |      *
 19 |     |      * - This contract must be the admin of `proxy`.
 20 |     |      */
 21 |     |     function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {
 22 |     |         // We need to manually run the static call since the getter cannot be flagged as view
 23 |     |         // bytes4(keccak256("implementation()")) == 0x5c60da1b
 24 |     |         (bool success, bytes memory returndata) = address(proxy).staticcall(hex"5c60da1b");
 25 |     |         require(success);
 26 |     |         return abi.decode(returndata, (address));
 27 |     |     }
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the current admin of `proxy`.
 31 |     |      *
 32 |     |      * Requirements:
 33 |     |      *
 34 |     |      * - This contract must be the admin of `proxy`.
 35 |     |      */
 36 |     |     function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {
 37 |     |         // We need to manually run the static call since the getter cannot be flagged as view
 38 |     |         // bytes4(keccak256("admin()")) == 0xf851a440
 39 |     |         (bool success, bytes memory returndata) = address(proxy).staticcall(hex"f851a440");
 40 |     |         require(success);
 41 |     |         return abi.decode(returndata, (address));
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Changes the admin of `proxy` to `newAdmin`.
 46 |     |      *
 47 |     |      * Requirements:
 48 |     |      *
 49 |     |      * - This contract must be the current admin of `proxy`.
 50 |     |      */
 51 |     |     function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {
 52 |     |         proxy.changeAdmin(newAdmin);
 53 |     |     }
 54 |     | 
 55 |     |     /**
 56 |     |      * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.
 57 |     |      *
 58 |     |      * Requirements:
 59 |     |      *
 60 |     |      * - This contract must be the admin of `proxy`.
 61 |     |      */
 62 |     |     function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {
 63 |     |         proxy.upgradeTo(implementation);
 64 |     |     }
 65 |     | 
 66 |     |     /**
 67 |     |      * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See
 68 |     |      * {TransparentUpgradeableProxy-upgradeToAndCall}.
 69 |     |      *
 70 |     |      * Requirements:
 71 |     |      *
 72 |     |      * - This contract must be the admin of `proxy`.
 73 |     |      */
 74 |     |     function upgradeAndCall(
 75 |     |         ITransparentUpgradeableProxy proxy,
 76 |     |         address implementation,
 77 |     |         bytes memory data
 78 |     |     ) public payable virtual onlyOwner {
 79 |     |         proxy.upgradeToAndCall{value: msg.value}(implementation, data);
 80 |     |     }
 81 |     | }
 82 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../ERC1967/ERC1967Proxy.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}
  10 |     |  * does not implement this interface directly, and some of its functions are implemented by an internal dispatch
  11 |     |  * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not
  12 |     |  * include them in the ABI so this interface must be used to interact with it.
  13 |     |  */
  14 |     | interface ITransparentUpgradeableProxy is IERC1967 {
  15 |     |     function admin() external view returns (address);
  16 |     | 
  17 |     |     function implementation() external view returns (address);
  18 |     | 
  19 |     |     function changeAdmin(address) external;
  20 |     | 
  21 |     |     function upgradeTo(address) external;
  22 |     | 
  23 |     |     function upgradeToAndCall(address, bytes memory) external payable;
  24 |     | }
  25 |     | 
  26 |     | /**
  27 |     |  * @dev This contract implements a proxy that is upgradeable by an admin.
  28 |     |  *
  29 |     |  * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector
  30 |     |  * clashing], which can potentially be used in an attack, this contract uses the
  31 |     |  * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two
  32 |     |  * things that go hand in hand:
  33 |     |  *
  34 |     |  * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if
  35 |     |  * that call matches one of the admin functions exposed by the proxy itself.
  36 |     |  * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the
  37 |     |  * implementation. If the admin tries to call a function on the implementation it will fail with an error that says
  38 |     |  * "admin cannot fallback to proxy target".
  39 |     |  *
  40 |     |  * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing
  41 |     |  * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due
  42 |     |  * to sudden errors when trying to call a function from the proxy implementation.
  43 |     |  *
  44 |     |  * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,
  45 |     |  * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.
  46 |     |  *
  47 |     |  * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not
  48 |     |  * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch
  49 |     |  * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to
  50 |     |  * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the
  51 |     |  * implementation.
  52 |     |  *
  53 |     |  * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler
  54 |     |  * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function
  55 |     |  * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could
  56 |     |  * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.
  57 |     |  */
  58 | *   | contract TransparentUpgradeableProxy is ERC1967Proxy {
  59 |     |     /**
  60 |     |      * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and
  61 |     |      * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.
  62 |     |      */
  63 |     |     constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {
  64 |     |         _changeAdmin(admin_);
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.
  69 |     |      *
  70 |     |      * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the
  71 |     |      * implementation provides a function with the same selector.
  72 |     |      */
  73 |     |     modifier ifAdmin() {
  74 |     |         if (msg.sender == _getAdmin()) {
  75 |     |             _;
  76 |     |         } else {
  77 |     |             _fallback();
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior
  83 |     |      */
  84 | *   |     function _fallback() internal virtual override {
  85 | *   |         if (msg.sender == _getAdmin()) {
  86 |     |             bytes memory ret;
  87 |     |             bytes4 selector = msg.sig;
  88 |     |             if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {
  89 |     |                 ret = _dispatchUpgradeTo();
  90 |     |             } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {
  91 |     |                 ret = _dispatchUpgradeToAndCall();
  92 |     |             } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {
  93 |     |                 ret = _dispatchChangeAdmin();
  94 |     |             } else if (selector == ITransparentUpgradeableProxy.admin.selector) {
  95 |     |                 ret = _dispatchAdmin();
  96 |     |             } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {
  97 |     |                 ret = _dispatchImplementation();
  98 |     |             } else {
  99 |     |                 revert("TransparentUpgradeableProxy: admin cannot fallback to proxy target");
 100 |     |             }
 101 |     |             assembly {
 102 |     |                 return(add(ret, 0x20), mload(ret))
 103 |     |             }
 104 |     |         } else {
 105 | *   |             super._fallback();
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Returns the current admin.
 111 |     |      *
 112 |     |      * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the
 113 |     |      * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
 114 |     |      * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`
 115 |     |      */
 116 |     |     function _dispatchAdmin() private returns (bytes memory) {
 117 |     |         _requireZeroValue();
 118 |     | 
 119 |     |         address admin = _getAdmin();
 120 |     |         return abi.encode(admin);
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Returns the current implementation.
 125 |     |      *
 126 |     |      * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the
 127 |     |      * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
 128 |     |      * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`
 129 |     |      */
 130 |     |     function _dispatchImplementation() private returns (bytes memory) {
 131 |     |         _requireZeroValue();
 132 |     | 
 133 |     |         address implementation = _implementation();
 134 |     |         return abi.encode(implementation);
 135 |     |     }
 136 |     | 
 137 |     |     /**
 138 |     |      * @dev Changes the admin of the proxy.
 139 |     |      *
 140 |     |      * Emits an {AdminChanged} event.
 141 |     |      */
 142 |     |     function _dispatchChangeAdmin() private returns (bytes memory) {
 143 |     |         _requireZeroValue();
 144 |     | 
 145 |     |         address newAdmin = abi.decode(msg.data[4:], (address));
 146 |     |         _changeAdmin(newAdmin);
 147 |     | 
 148 |     |         return "";
 149 |     |     }
 150 |     | 
 151 |     |     /**
 152 |     |      * @dev Upgrade the implementation of the proxy.
 153 |     |      */
 154 |     |     function _dispatchUpgradeTo() private returns (bytes memory) {
 155 |     |         _requireZeroValue();
 156 |     | 
 157 |     |         address newImplementation = abi.decode(msg.data[4:], (address));
 158 |     |         _upgradeToAndCall(newImplementation, bytes(""), false);
 159 |     | 
 160 |     |         return "";
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified
 165 |     |      * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the
 166 |     |      * proxied contract.
 167 |     |      */
 168 |     |     function _dispatchUpgradeToAndCall() private returns (bytes memory) {
 169 |     |         (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));
 170 |     |         _upgradeToAndCall(newImplementation, data, true);
 171 |     | 
 172 |     |         return "";
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @dev Returns the current admin.
 177 |     |      *
 178 |     |      * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.
 179 |     |      */
 180 |     |     function _admin() internal view virtual returns (address) {
 181 |     |         return _getAdmin();
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to
 186 |     |      * emulate some proxy functions being non-payable while still allowing value to pass through.
 187 |     |      */
 188 |     |     function _requireZeroValue() private {
 189 |     |         require(msg.value == 0);
 190 |     |     }
 191 |     | }
 192 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 19 |     |  * to protect against it, check out our blog post
 20 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 21 |     |  */
 22 |     | abstract contract ReentrancyGuard {
 23 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 24 |     |     // word because each write operation emits an extra SLOAD to first read the
 25 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 26 |     |     // back. This is the compiler's defense against contract upgrades and
 27 |     |     // pointer aliasing, and it cannot be disabled.
 28 |     | 
 29 |     |     // The values being non-zero value makes deployment a bit more expensive,
 30 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 31 |     |     // amount. Since refunds are capped to a percentage of the total
 32 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 33 |     |     // increase the likelihood of the full refund coming into effect.
 34 |     |     uint256 private constant _NOT_ENTERED = 1;
 35 |     |     uint256 private constant _ENTERED = 2;
 36 |     | 
 37 |     |     uint256 private _status;
 38 |     | 
 39 |     |     constructor() {
 40 |     |         _status = _NOT_ENTERED;
 41 |     |     }
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 45 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 46 |     |      * function is not supported. It is possible to prevent this from happening
 47 |     |      * by making the `nonReentrant` function external, and making it call a
 48 |     |      * `private` function that does the actual work.
 49 |     |      */
 50 |     |     modifier nonReentrant() {
 51 |     |         _nonReentrantBefore();
 52 |     |         _;
 53 |     |         _nonReentrantAfter();
 54 |     |     }
 55 |     | 
 56 |     |     function _nonReentrantBefore() private {
 57 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 58 |     |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
 59 |     | 
 60 |     |         // Any calls to nonReentrant after this point will fail
 61 |     |         _status = _ENTERED;
 62 |     |     }
 63 |     | 
 64 |     |     function _nonReentrantAfter() private {
 65 |     |         // By storing the original value once again, a refund is triggered (see
 66 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 67 |     |         _status = _NOT_ENTERED;
 68 |     |     }
 69 |     | 
 70 |     |     /**
 71 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 72 |     |      * `nonReentrant` function in the call stack.
 73 |     |      */
 74 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 75 |     |         return _status == _ENTERED;
 76 |     |     }
 77 |     | }
 78 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  *
  34 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  35 |     |  * functions have been added to mitigate the well-known issues around setting
  36 |     |  * allowances. See {IERC20-approve}.
  37 |     |  */
  38 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  39 |     |     mapping(address => uint256) private _balances;
  40 |     | 
  41 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  42 |     | 
  43 |     |     uint256 private _totalSupply;
  44 |     | 
  45 |     |     string private _name;
  46 |     |     string private _symbol;
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sets the values for {name} and {symbol}.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 | *   |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the default value returned by this function, unless
  81 |     |      * it's overridden.
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 | *   |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 | *   |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 | *   |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 159 |     |         address spender = _msgSender();
 160 | *   |         _spendAllowance(from, spender, amount);
 161 | *   |         _transfer(from, to, amount);
 162 | *   |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 |     |         address owner = _msgSender();
 179 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 180 |     |         return true;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 185 |     |      *
 186 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 187 |     |      * problems described in {IERC20-approve}.
 188 |     |      *
 189 |     |      * Emits an {Approval} event indicating the updated allowance.
 190 |     |      *
 191 |     |      * Requirements:
 192 |     |      *
 193 |     |      * - `spender` cannot be the zero address.
 194 |     |      * - `spender` must have allowance for the caller of at least
 195 |     |      * `subtractedValue`.
 196 |     |      */
 197 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 198 |     |         address owner = _msgSender();
 199 |     |         uint256 currentAllowance = allowance(owner, spender);
 200 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 201 |     |         unchecked {
 202 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 203 |     |         }
 204 |     | 
 205 |     |         return true;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 210 |     |      *
 211 |     |      * This internal function is equivalent to {transfer}, and can be used to
 212 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 213 |     |      *
 214 |     |      * Emits a {Transfer} event.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - `from` cannot be the zero address.
 219 |     |      * - `to` cannot be the zero address.
 220 |     |      * - `from` must have a balance of at least `amount`.
 221 |     |      */
 222 | *   |     function _transfer(address from, address to, uint256 amount) internal virtual {
 223 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 224 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 225 |     | 
 226 |     |         _beforeTokenTransfer(from, to, amount);
 227 |     | 
 228 | *   |         uint256 fromBalance = _balances[from];
 229 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 230 |     |         unchecked {
 231 | *   |             _balances[from] = fromBalance - amount;
 232 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 233 |     |             // decrementing then incrementing.
 234 | *   |             _balances[to] += amount;
 235 |     |         }
 236 |     | 
 237 | *   |         emit Transfer(from, to, amount);
 238 |     | 
 239 | *   |         _afterTokenTransfer(from, to, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 | *   |     function _mint(address account, uint256 amount) internal virtual {
 252 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 |     |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 | *   |         _totalSupply += amount;
 257 |     |         unchecked {
 258 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 259 | *   |             _balances[account] += amount;
 260 |     |         }
 261 | *   |         emit Transfer(address(0), account, amount);
 262 |     | 
 263 |     |         _afterTokenTransfer(address(0), account, amount);
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 268 |     |      * total supply.
 269 |     |      *
 270 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 271 |     |      *
 272 |     |      * Requirements:
 273 |     |      *
 274 |     |      * - `account` cannot be the zero address.
 275 |     |      * - `account` must have at least `amount` tokens.
 276 |     |      */
 277 |     |     function _burn(address account, uint256 amount) internal virtual {
 278 |     |         require(account != address(0), "ERC20: burn from the zero address");
 279 |     | 
 280 |     |         _beforeTokenTransfer(account, address(0), amount);
 281 |     | 
 282 |     |         uint256 accountBalance = _balances[account];
 283 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 284 |     |         unchecked {
 285 |     |             _balances[account] = accountBalance - amount;
 286 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 287 |     |             _totalSupply -= amount;
 288 |     |         }
 289 |     | 
 290 |     |         emit Transfer(account, address(0), amount);
 291 |     | 
 292 |     |         _afterTokenTransfer(account, address(0), amount);
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 297 |     |      *
 298 |     |      * This internal function is equivalent to `approve`, and can be used to
 299 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 300 |     |      *
 301 |     |      * Emits an {Approval} event.
 302 |     |      *
 303 |     |      * Requirements:
 304 |     |      *
 305 |     |      * - `owner` cannot be the zero address.
 306 |     |      * - `spender` cannot be the zero address.
 307 |     |      */
 308 | *   |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 309 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 310 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 | *   |         _allowances[owner][spender] = amount;
 313 | *   |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 318 |     |      *
 319 |     |      * Does not update the allowance amount in case of infinite allowance.
 320 |     |      * Revert if not enough allowance is available.
 321 |     |      *
 322 |     |      * Might emit an {Approval} event.
 323 |     |      */
 324 | *   |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 325 | *   |         uint256 currentAllowance = allowance(owner, spender);
 326 | *   |         if (currentAllowance != type(uint256).max) {
 327 | *   |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 328 |     |             unchecked {
 329 | *   |                 _approve(owner, spender, currentAllowance - amount);
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 336 |     |      * minting and burning.
 337 |     |      *
 338 |     |      * Calling conditions:
 339 |     |      *
 340 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 341 |     |      * will be transferred to `to`.
 342 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 343 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 344 |     |      * - `from` and `to` are never both zero.
 345 |     |      *
 346 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 347 |     |      */
 348 | *   |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * has been transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 |     |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 365 |     | }
 366 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20Permit {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20.sol";
   7 |     | import "../extensions/IERC20Permit.sol";
   8 |     | import "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  24 |     |      * non-reverting calls are assumed to be successful.
  25 |     |      */
  26 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  27 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  32 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  33 |     |      */
  34 |     |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  35 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  40 |     |      * {IERC20-approve}, and its usage is discouraged.
  41 |     |      *
  42 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  43 |     |      * {safeDecreaseAllowance} instead.
  44 |     |      */
  45 |     |     function safeApprove(IERC20 token, address spender, uint256 value) internal {
  46 |     |         // safeApprove should only be called when setting an initial allowance,
  47 |     |         // or when resetting it to zero. To increase and decrease it, use
  48 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  49 |     |         require(
  50 |     |             (value == 0) || (token.allowance(address(this), spender) == 0),
  51 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  52 |     |         );
  53 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  58 |     |      * non-reverting calls are assumed to be successful.
  59 |     |      */
  60 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  61 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  62 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  67 |     |      * non-reverting calls are assumed to be successful.
  68 |     |      */
  69 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  70 |     |         unchecked {
  71 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  72 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  73 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  79 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  80 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  81 |     |      */
  82 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  83 |     |         bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);
  84 |     | 
  85 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  86 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
  87 |     |             _callOptionalReturn(token, approvalCall);
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
  93 |     |      * Revert on invalid signature.
  94 |     |      */
  95 |     |     function safePermit(
  96 |     |         IERC20Permit token,
  97 |     |         address owner,
  98 |     |         address spender,
  99 |     |         uint256 value,
 100 |     |         uint256 deadline,
 101 |     |         uint8 v,
 102 |     |         bytes32 r,
 103 |     |         bytes32 s
 104 |     |     ) internal {
 105 |     |         uint256 nonceBefore = token.nonces(owner);
 106 |     |         token.permit(owner, spender, value, deadline, v, r, s);
 107 |     |         uint256 nonceAfter = token.nonces(owner);
 108 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 113 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 114 |     |      * @param token The token targeted by the call.
 115 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 116 |     |      */
 117 |     |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 118 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 119 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 120 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 121 |     | 
 122 |     |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 123 |     |         require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 128 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 129 |     |      * @param token The token targeted by the call.
 130 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 131 |     |      *
 132 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 133 |     |      */
 134 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 135 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 136 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 137 |     |         // and not revert is the subcall reverts.
 138 |     | 
 139 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 140 |     |         return
 141 |     |             success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 |     |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 |     |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 |     |     ) internal returns (bytes memory) {
 104 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/StorageSlot.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.0;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for reading and writing primitive types to specific storage slots.
   9 |     |  *
  10 |     |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
  11 |     |  * This library helps with reading and writing to such slots without the need for inline assembly.
  12 |     |  *
  13 |     |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
  14 |     |  *
  15 |     |  * Example usage to set ERC1967 implementation slot:
  16 |     |  * ```solidity
  17 |     |  * contract ERC1967 {
  18 |     |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  19 |     |  *
  20 |     |  *     function _getImplementation() internal view returns (address) {
  21 |     |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
  22 |     |  *     }
  23 |     |  *
  24 |     |  *     function _setImplementation(address newImplementation) internal {
  25 |     |  *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
  26 |     |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
  27 |     |  *     }
  28 |     |  * }
  29 |     |  * ```
  30 |     |  *
  31 |     |  * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._
  32 |     |  * _Available since v4.9 for `string`, `bytes`._
  33 |     |  */
  34 |     | library StorageSlot {
  35 |     |     struct AddressSlot {
  36 |     |         address value;
  37 |     |     }
  38 |     | 
  39 |     |     struct BooleanSlot {
  40 |     |         bool value;
  41 |     |     }
  42 |     | 
  43 |     |     struct Bytes32Slot {
  44 |     |         bytes32 value;
  45 |     |     }
  46 |     | 
  47 |     |     struct Uint256Slot {
  48 |     |         uint256 value;
  49 |     |     }
  50 |     | 
  51 |     |     struct StringSlot {
  52 |     |         string value;
  53 |     |     }
  54 |     | 
  55 |     |     struct BytesSlot {
  56 |     |         bytes value;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
  61 |     |      */
  62 | *   |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
  63 |     |         /// @solidity memory-safe-assembly
  64 |     |         assembly {
  65 |     |             r.slot := slot
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
  71 |     |      */
  72 |     |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
  73 |     |         /// @solidity memory-safe-assembly
  74 |     |         assembly {
  75 |     |             r.slot := slot
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
  81 |     |      */
  82 |     |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
  83 |     |         /// @solidity memory-safe-assembly
  84 |     |         assembly {
  85 |     |             r.slot := slot
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
  91 |     |      */
  92 |     |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
  93 |     |         /// @solidity memory-safe-assembly
  94 |     |         assembly {
  95 |     |             r.slot := slot
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns an `StringSlot` with member `value` located at `slot`.
 101 |     |      */
 102 |     |     function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {
 103 |     |         /// @solidity memory-safe-assembly
 104 |     |         assembly {
 105 |     |             r.slot := slot
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Returns an `StringSlot` representation of the string storage pointer `store`.
 111 |     |      */
 112 |     |     function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {
 113 |     |         /// @solidity memory-safe-assembly
 114 |     |         assembly {
 115 |     |             r.slot := store.slot
 116 |     |         }
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev Returns an `BytesSlot` with member `value` located at `slot`.
 121 |     |      */
 122 |     |     function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {
 123 |     |         /// @solidity memory-safe-assembly
 124 |     |         assembly {
 125 |     |             r.slot := slot
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.
 131 |     |      */
 132 |     |     function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {
 133 |     |         /// @solidity memory-safe-assembly
 134 |     |         assembly {
 135 |     |             r.slot := store.slot
 136 |     |         }
 137 |     |     }
 138 |     | }
 139 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./math/Math.sol";
  7 |     | import "./math/SignedMath.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev String operations.
 11 |     |  */
 12 |     | library Strings {
 13 |     |     bytes16 private constant _SYMBOLS = "0123456789abcdef";
 14 |     |     uint8 private constant _ADDRESS_LENGTH = 20;
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 18 |     |      */
 19 |     |     function toString(uint256 value) internal pure returns (string memory) {
 20 |     |         unchecked {
 21 |     |             uint256 length = Math.log10(value) + 1;
 22 |     |             string memory buffer = new string(length);
 23 |     |             uint256 ptr;
 24 |     |             /// @solidity memory-safe-assembly
 25 |     |             assembly {
 26 |     |                 ptr := add(buffer, add(32, length))
 27 |     |             }
 28 |     |             while (true) {
 29 |     |                 ptr--;
 30 |     |                 /// @solidity memory-safe-assembly
 31 |     |                 assembly {
 32 |     |                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
 33 |     |                 }
 34 |     |                 value /= 10;
 35 |     |                 if (value == 0) break;
 36 |     |             }
 37 |     |             return buffer;
 38 |     |         }
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
 43 |     |      */
 44 |     |     function toString(int256 value) internal pure returns (string memory) {
 45 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 50 |     |      */
 51 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 52 |     |         unchecked {
 53 |     |             return toHexString(value, Math.log256(value) + 1);
 54 |     |         }
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 59 |     |      */
 60 | *   |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 61 |     |         bytes memory buffer = new bytes(2 * length + 2);
 62 |     |         buffer[0] = "0";
 63 |     |         buffer[1] = "x";
 64 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 65 |     |             buffer[i] = _SYMBOLS[value & 0xf];
 66 |     |             value >>= 4;
 67 |     |         }
 68 | *   |         require(value == 0, "Strings: hex length insufficient");
 69 | *   |         return string(buffer);
 70 |     |     }
 71 |     | 
 72 |     |     /**
 73 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
 74 |     |      */
 75 |     |     function toHexString(address addr) internal pure returns (string memory) {
 76 |     |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Returns true if the two strings are equal.
 81 |     |      */
 82 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 83 |     |         return keccak256(bytes(a)) == keccak256(bytes(b));
 84 |     |     }
 85 |     | }
 86 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 |     |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library Math {
  10 |     |     enum Rounding {
  11 |     |         Down, // Toward negative infinity
  12 |     |         Up, // Toward infinity
  13 |     |         Zero // Toward zero
  14 |     |     }
  15 |     | 
  16 |     |     /**
  17 |     |      * @dev Returns the largest of two numbers.
  18 |     |      */
  19 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a > b ? a : b;
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Returns the smallest of two numbers.
  25 |     |      */
  26 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  27 |     |         return a < b ? a : b;
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  32 |     |      * zero.
  33 |     |      */
  34 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  35 |     |         // (a + b) / 2 can overflow.
  36 |     |         return (a & b) + (a ^ b) / 2;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Returns the ceiling of the division of two numbers.
  41 |     |      *
  42 |     |      * This differs from standard division with `/` in that it rounds up instead
  43 |     |      * of rounding down.
  44 |     |      */
  45 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  46 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
  47 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  52 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
  53 |     |      * with further edits by Uniswap Labs also under MIT license.
  54 |     |      */
  55 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
  56 |     |         unchecked {
  57 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
  58 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  59 |     |             // variables such that product = prod1 * 2^256 + prod0.
  60 |     |             uint256 prod0; // Least significant 256 bits of the product
  61 |     |             uint256 prod1; // Most significant 256 bits of the product
  62 |     |             assembly {
  63 |     |                 let mm := mulmod(x, y, not(0))
  64 |     |                 prod0 := mul(x, y)
  65 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  66 |     |             }
  67 |     | 
  68 |     |             // Handle non-overflow cases, 256 by 256 division.
  69 |     |             if (prod1 == 0) {
  70 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
  71 |     |                 // The surrounding unchecked block does not change this fact.
  72 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
  73 |     |                 return prod0 / denominator;
  74 |     |             }
  75 |     | 
  76 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
  77 |     |             require(denominator > prod1, "Math: mulDiv overflow");
  78 |     | 
  79 |     |             ///////////////////////////////////////////////
  80 |     |             // 512 by 256 division.
  81 |     |             ///////////////////////////////////////////////
  82 |     | 
  83 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
  84 |     |             uint256 remainder;
  85 |     |             assembly {
  86 |     |                 // Compute remainder using mulmod.
  87 |     |                 remainder := mulmod(x, y, denominator)
  88 |     | 
  89 |     |                 // Subtract 256 bit number from 512 bit number.
  90 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  91 |     |                 prod0 := sub(prod0, remainder)
  92 |     |             }
  93 |     | 
  94 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
  95 |     |             // See https://cs.stackexchange.com/q/138556/92363.
  96 |     | 
  97 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
  98 |     |             uint256 twos = denominator & (~denominator + 1);
  99 |     |             assembly {
 100 |     |                 // Divide denominator by twos.
 101 |     |                 denominator := div(denominator, twos)
 102 |     | 
 103 |     |                 // Divide [prod1 prod0] by twos.
 104 |     |                 prod0 := div(prod0, twos)
 105 |     | 
 106 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 107 |     |                 twos := add(div(sub(0, twos), twos), 1)
 108 |     |             }
 109 |     | 
 110 |     |             // Shift in bits from prod1 into prod0.
 111 |     |             prod0 |= prod1 * twos;
 112 |     | 
 113 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 114 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 115 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 116 |     |             uint256 inverse = (3 * denominator) ^ 2;
 117 |     | 
 118 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 119 |     |             // in modular arithmetic, doubling the correct bits in each step.
 120 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 121 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 122 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 123 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 124 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 125 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 126 |     | 
 127 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 128 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 129 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 130 |     |             // is no longer required.
 131 |     |             result = prod0 * inverse;
 132 |     |             return result;
 133 |     |         }
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 138 |     |      */
 139 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 140 |     |         uint256 result = mulDiv(x, y, denominator);
 141 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 142 |     |             result += 1;
 143 |     |         }
 144 |     |         return result;
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
 149 |     |      *
 150 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 151 |     |      */
 152 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 153 |     |         if (a == 0) {
 154 |     |             return 0;
 155 |     |         }
 156 |     | 
 157 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 158 |     |         //
 159 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 160 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 161 |     |         //
 162 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 163 |     |         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 164 |     |         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 165 |     |         //
 166 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 167 |     |         uint256 result = 1 << (log2(a) >> 1);
 168 |     | 
 169 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 170 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 171 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 172 |     |         // into the expected uint128 result.
 173 |     |         unchecked {
 174 |     |             result = (result + a / result) >> 1;
 175 |     |             result = (result + a / result) >> 1;
 176 |     |             result = (result + a / result) >> 1;
 177 |     |             result = (result + a / result) >> 1;
 178 |     |             result = (result + a / result) >> 1;
 179 |     |             result = (result + a / result) >> 1;
 180 |     |             result = (result + a / result) >> 1;
 181 |     |             return min(result, a / result);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 187 |     |      */
 188 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 189 |     |         unchecked {
 190 |     |             uint256 result = sqrt(a);
 191 |     |             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Return the log in base 2, rounded down, of a positive value.
 197 |     |      * Returns 0 if given 0.
 198 |     |      */
 199 |     |     function log2(uint256 value) internal pure returns (uint256) {
 200 |     |         uint256 result = 0;
 201 |     |         unchecked {
 202 |     |             if (value >> 128 > 0) {
 203 |     |                 value >>= 128;
 204 |     |                 result += 128;
 205 |     |             }
 206 |     |             if (value >> 64 > 0) {
 207 |     |                 value >>= 64;
 208 |     |                 result += 64;
 209 |     |             }
 210 |     |             if (value >> 32 > 0) {
 211 |     |                 value >>= 32;
 212 |     |                 result += 32;
 213 |     |             }
 214 |     |             if (value >> 16 > 0) {
 215 |     |                 value >>= 16;
 216 |     |                 result += 16;
 217 |     |             }
 218 |     |             if (value >> 8 > 0) {
 219 |     |                 value >>= 8;
 220 |     |                 result += 8;
 221 |     |             }
 222 |     |             if (value >> 4 > 0) {
 223 |     |                 value >>= 4;
 224 |     |                 result += 4;
 225 |     |             }
 226 |     |             if (value >> 2 > 0) {
 227 |     |                 value >>= 2;
 228 |     |                 result += 2;
 229 |     |             }
 230 |     |             if (value >> 1 > 0) {
 231 |     |                 result += 1;
 232 |     |             }
 233 |     |         }
 234 |     |         return result;
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 239 |     |      * Returns 0 if given 0.
 240 |     |      */
 241 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 242 |     |         unchecked {
 243 |     |             uint256 result = log2(value);
 244 |     |             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Return the log in base 10, rounded down, of a positive value.
 250 |     |      * Returns 0 if given 0.
 251 |     |      */
 252 |     |     function log10(uint256 value) internal pure returns (uint256) {
 253 |     |         uint256 result = 0;
 254 |     |         unchecked {
 255 |     |             if (value >= 10 ** 64) {
 256 |     |                 value /= 10 ** 64;
 257 |     |                 result += 64;
 258 |     |             }
 259 |     |             if (value >= 10 ** 32) {
 260 |     |                 value /= 10 ** 32;
 261 |     |                 result += 32;
 262 |     |             }
 263 |     |             if (value >= 10 ** 16) {
 264 |     |                 value /= 10 ** 16;
 265 |     |                 result += 16;
 266 |     |             }
 267 |     |             if (value >= 10 ** 8) {
 268 |     |                 value /= 10 ** 8;
 269 |     |                 result += 8;
 270 |     |             }
 271 |     |             if (value >= 10 ** 4) {
 272 |     |                 value /= 10 ** 4;
 273 |     |                 result += 4;
 274 |     |             }
 275 |     |             if (value >= 10 ** 2) {
 276 |     |                 value /= 10 ** 2;
 277 |     |                 result += 2;
 278 |     |             }
 279 |     |             if (value >= 10 ** 1) {
 280 |     |                 result += 1;
 281 |     |             }
 282 |     |         }
 283 |     |         return result;
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 288 |     |      * Returns 0 if given 0.
 289 |     |      */
 290 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 291 |     |         unchecked {
 292 |     |             uint256 result = log10(value);
 293 |     |             return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Return the log in base 256, rounded down, of a positive value.
 299 |     |      * Returns 0 if given 0.
 300 |     |      *
 301 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 302 |     |      */
 303 |     |     function log256(uint256 value) internal pure returns (uint256) {
 304 |     |         uint256 result = 0;
 305 |     |         unchecked {
 306 |     |             if (value >> 128 > 0) {
 307 |     |                 value >>= 128;
 308 |     |                 result += 16;
 309 |     |             }
 310 |     |             if (value >> 64 > 0) {
 311 |     |                 value >>= 64;
 312 |     |                 result += 8;
 313 |     |             }
 314 |     |             if (value >> 32 > 0) {
 315 |     |                 value >>= 32;
 316 |     |                 result += 4;
 317 |     |             }
 318 |     |             if (value >> 16 > 0) {
 319 |     |                 value >>= 16;
 320 |     |                 result += 2;
 321 |     |             }
 322 |     |             if (value >> 8 > 0) {
 323 |     |                 result += 1;
 324 |     |             }
 325 |     |         }
 326 |     |         return result;
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 331 |     |      * Returns 0 if given 0.
 332 |     |      */
 333 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 334 |     |         unchecked {
 335 |     |             uint256 result = log256(value);
 336 |     |             return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);
 337 |     |         }
 338 |     |     }
 339 |     | }
 340 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 |     | library SignedMath {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/properties/contracts/util/Hevm.sol
  1 |     | // SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IHevm {
  5 |     |     // Set block.timestamp to newTimestamp
  6 |     |     function warp(uint256 newTimestamp) external;
  7 |     | 
  8 |     |     // Set block.number to newNumber
  9 |     |     function roll(uint256 newNumber) external;
 10 |     | 
 11 |     |     // Loads a storage slot from an address
 12 |     |     function load(address where, bytes32 slot) external returns (bytes32);
 13 |     | 
 14 |     |     // Stores a value to an address' storage slot
 15 |     |     function store(address where, bytes32 slot, bytes32 value) external;
 16 |     | 
 17 |     |     // Signs data (privateKey, digest) => (r, v, s)
 18 |     |     function sign(uint256 privateKey, bytes32 digest) external returns (uint8 r, bytes32 v, bytes32 s);
 19 |     | 
 20 |     |     // Gets address for a given private key
 21 |     |     function addr(uint256 privateKey) external returns (address addr);
 22 |     | 
 23 |     |     // Performs a foreign function call via terminal
 24 |     |     function ffi(string[] calldata inputs) external returns (bytes memory result);
 25 |     |     
 26 |     |     // Performs the next smart contract call with specified `msg.sender`
 27 |     |     function prank(address newSender) external;
 28 |     | }
 29 |     | 
 30 | *   | IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/lib/properties/contracts/util/PropertiesHelper.sol
   1 |     | pragma solidity ^0.8.0;
   2 |     | 
   3 |     | abstract contract PropertiesAsserts {
   4 |     |     event LogUint256(string,uint256);
   5 |     |     event LogAddress(string, address);
   6 |     |     event LogString(string);
   7 |     | 
   8 |     |     event AssertFail(string);
   9 |     |     event AssertEqFail(string);
  10 |     |     event AssertNeqFail(string);
  11 |     |     event AssertGteFail(string);
  12 |     |     event AssertGtFail(string);
  13 |     |     event AssertLteFail(string);
  14 |     |     event AssertLtFail(string);
  15 |     | 
  16 | *   |     function assertWithMsg(bool b, string memory reason) internal {
  17 | *   |         if(!b){
  18 |     |             emit AssertFail(reason);
  19 |     |             assert(false);
  20 |     |         }
  21 |     |     }
  22 |     | 
  23 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  24 |     |     function assertEq(uint256 a, uint256 b, string memory reason) internal {
  25 |     |         if(a != b){
  26 |     |             string memory aStr = PropertiesLibString.toString(a);
  27 |     |             string memory bStr = PropertiesLibString.toString(b);
  28 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,"!=",bStr,", reason: ", reason);
  29 |     |             emit AssertEqFail(string(assertMsg));
  30 |     |             assert(false);
  31 |     |         }
  32 |     |     }
  33 |     | 
  34 |     |     /// @notice int256 version of assertEq
  35 |     |     function assertEq(int256 a, int256 b, string memory reason) internal {
  36 |     |         if(a != b){
  37 |     |             string memory aStr = PropertiesLibString.toString(a);
  38 |     |             string memory bStr = PropertiesLibString.toString(b);
  39 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,"!=",bStr,", reason: ", reason);
  40 |     |             emit AssertEqFail(string(assertMsg));
  41 |     |             assert(false);
  42 |     |         }
  43 |     |     }
  44 |     | 
  45 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
  46 |     |     function assertNeq(uint256 a, uint256 b, string memory reason) internal {
  47 |     |         if(a == b){
  48 |     |             string memory aStr = PropertiesLibString.toString(a);
  49 |     |             string memory bStr = PropertiesLibString.toString(b);
  50 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,"==",bStr,", reason: ", reason);
  51 |     |             emit AssertNeqFail(string(assertMsg));
  52 |     |             assert(false);
  53 |     |         }
  54 |     |     }
  55 |     | 
  56 |     |     /// @notice int256 version of assertNeq
  57 |     |     function assertNeq(int256 a, int256 b, string memory reason) internal {
  58 |     |         if(a == b){
  59 |     |             string memory aStr = PropertiesLibString.toString(a);
  60 |     |             string memory bStr = PropertiesLibString.toString(b);
  61 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,"==",bStr,", reason: ", reason);
  62 |     |             emit AssertNeqFail(string(assertMsg));
  63 |     |             assert(false);
  64 |     |         }
  65 |     |     }
  66 |     | 
  67 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
  68 |     |     function assertGte(uint256 a, uint256 b, string memory reason) internal {
  69 |     |         if(!(a >= b)) {
  70 |     |             string memory aStr = PropertiesLibString.toString(a);
  71 |     |             string memory bStr = PropertiesLibString.toString(b);
  72 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,"<",bStr," failed, reason: ", reason);
  73 |     |             emit AssertGteFail(string(assertMsg));
  74 |     |             assert(false);
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     /// @notice int256 version of assertGte
  79 |     |     function assertGte(int256 a, int256 b, string memory reason) internal {
  80 |     |         if(!(a >= b)) {
  81 |     |             string memory aStr = PropertiesLibString.toString(a);
  82 |     |             string memory bStr = PropertiesLibString.toString(b);
  83 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,"<",bStr," failed, reason: ", reason);
  84 |     |             emit AssertGteFail(string(assertMsg));
  85 |     |             assert(false);
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
  90 |     |     function assertGt(uint256 a, uint256 b, string memory reason) internal {
  91 |     |         if(!(a > b)) {
  92 |     |             string memory aStr = PropertiesLibString.toString(a);
  93 |     |             string memory bStr = PropertiesLibString.toString(b);
  94 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,"<=", bStr," failed, reason: ", reason);
  95 |     |             emit AssertGtFail(string(assertMsg));
  96 |     |             assert(false);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice int256 version of assertGt
 101 |     |     function assertGt(int256 a, int256 b, string memory reason) internal {
 102 |     |         if(!(a > b)) {
 103 |     |             string memory aStr = PropertiesLibString.toString(a);
 104 |     |             string memory bStr = PropertiesLibString.toString(b);
 105 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,"<=", bStr," failed, reason: ", reason);
 106 |     |             emit AssertGtFail(string(assertMsg));
 107 |     |             assert(false);
 108 |     |         }
 109 |     |     }
 110 |     | 
 111 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 112 |     |     function assertLte(uint256 a, uint256 b, string memory reason) internal {
 113 |     |         if(!(a <= b)) {
 114 |     |             string memory aStr = PropertiesLibString.toString(a);
 115 |     |             string memory bStr = PropertiesLibString.toString(b);
 116 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,">", bStr," failed, reason: ", reason);
 117 |     |             emit AssertLteFail(string(assertMsg));
 118 |     |             assert(false);
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     /// @notice int256 version of assertLte
 123 |     |     function assertLte(int256 a, int256 b, string memory reason) internal {
 124 |     |         if(!(a <= b)) {
 125 |     |             string memory aStr = PropertiesLibString.toString(a);
 126 |     |             string memory bStr = PropertiesLibString.toString(b);
 127 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,">", bStr," failed, reason: ", reason);
 128 |     |             emit AssertLteFail(string(assertMsg));
 129 |     |             assert(false);
 130 |     |         }
 131 |     |     }
 132 |     | 
 133 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 134 |     |     function assertLt(uint256 a, uint256 b, string memory reason) internal {
 135 |     |         if(!(a < b)) {
 136 |     |             string memory aStr = PropertiesLibString.toString(a);
 137 |     |             string memory bStr = PropertiesLibString.toString(b);
 138 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,">=",bStr," failed, reason: ", reason);
 139 |     |             emit AssertLtFail(string(assertMsg));
 140 |     |             assert(false);
 141 |     |         }
 142 |     |     }
 143 |     | 
 144 |     |     /// @notice int256 version of assertLt
 145 |     |     function assertLt(int256 a, int256 b, string memory reason) internal {
 146 |     |         if(!(a < b)) {
 147 |     |             string memory aStr = PropertiesLibString.toString(a);
 148 |     |             string memory bStr = PropertiesLibString.toString(b);
 149 |     |             bytes memory assertMsg = abi.encodePacked("Invalid: ", aStr,">=",bStr," failed, reason: ", reason);
 150 |     |             emit AssertLtFail(string(assertMsg));
 151 |     |             assert(false);
 152 |     |         }
 153 |     |     }
 154 |     | 
 155 |     |     /// @notice Clamps value to be between low and high, both inclusive
 156 | *   |     function clampBetween(uint256 value, uint256 low, uint256 high) internal returns (uint256) {
 157 | *   |         if(value < low || value > high) {
 158 | *   |             uint ans = low + (value % (high - low + 1));
 159 | *   |             string memory valueStr = PropertiesLibString.toString(value);
 160 | *   |             string memory ansStr = PropertiesLibString.toString(ans);
 161 | *   |             bytes memory message = abi.encodePacked("Clamping value ", valueStr, " to ", ansStr);
 162 | *   |             emit LogString(string(message));
 163 | *   |             return ans;
 164 |     |         }
 165 | *   |         return value;
 166 |     |     }
 167 |     | 
 168 |     |     /// @notice int256 version of clampBetween
 169 |     |     function clampBetween(int256 value, int256 low, int256 high) internal returns (int256) {
 170 |     |         if(value < low || value > high) {
 171 |     |             int range = high - low + 1;
 172 |     |             int clamped = (value - low) % (range);
 173 |     |             if (clamped < 0) clamped += range;
 174 |     |             int ans = low + clamped;
 175 |     |             string memory valueStr = PropertiesLibString.toString(value);
 176 |     |             string memory ansStr = PropertiesLibString.toString(ans);
 177 |     |             bytes memory message = abi.encodePacked("Clamping value ", valueStr, " to ", ansStr);
 178 |     |             emit LogString(string(message));
 179 |     |             return ans;
 180 |     |         }
 181 |     |         return value;
 182 |     |     }
 183 |     | 
 184 |     |     /// @notice clamps a to be less than b
 185 |     |     function clampLt(uint256 a, uint256 b) internal returns (uint256){
 186 |     |         if ( !(a < b)) {
 187 |     |             assertNeq(b, 0, "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions.");
 188 |     |             uint256 value = a % b;
 189 |     |             string memory aStr = PropertiesLibString.toString(a);
 190 |     |             string memory valueStr = PropertiesLibString.toString(value);
 191 |     |             bytes memory message = abi.encodePacked("Clamping value ", aStr, " to ", valueStr);
 192 |     |             emit LogString(string(message));
 193 |     |             return value;
 194 |     |         }
 195 |     |         return a;
 196 |     |     }
 197 |     | 
 198 |     |     /// @notice int256 version of clampLt
 199 |     |     function clampLt(int256 a, int256 b) internal returns (int256){
 200 |     |         if ( !(a < b)) {
 201 |     |             int256 value = b-1;
 202 |     |             string memory aStr = PropertiesLibString.toString(a);
 203 |     |             string memory valueStr = PropertiesLibString.toString(value);
 204 |     |             bytes memory message = abi.encodePacked("Clamping value ", aStr, " to ", valueStr);
 205 |     |             emit LogString(string(message));
 206 |     |             return value;
 207 |     |         }
 208 |     |         return a;
 209 |     |     }
 210 |     | 
 211 |     |     /// @notice clamps a to be less than or equal to b
 212 |     |     function clampLte(uint256 a, uint256 b) internal returns (uint256) {
 213 |     |         if(!(a <= b)) {
 214 |     |             uint256 value = a % (b+1);
 215 |     |             string memory aStr = PropertiesLibString.toString(a);
 216 |     |             string memory valueStr = PropertiesLibString.toString(value);
 217 |     |             bytes memory message = abi.encodePacked("Clamping value ", aStr, " to ", valueStr);
 218 |     |             emit LogString(string(message));
 219 |     |             return value;
 220 |     |         }
 221 |     |         return a;
 222 |     |     }
 223 |     | 
 224 |     |     /// @notice int256 version of clampLte
 225 |     |     function clampLte(int256 a, int256 b) internal returns (int256) {
 226 |     |         if(!(a <= b)) {
 227 |     |             int256 value = b;
 228 |     |             string memory aStr = PropertiesLibString.toString(a);
 229 |     |             string memory valueStr = PropertiesLibString.toString(value);
 230 |     |             bytes memory message = abi.encodePacked("Clamping value ", aStr, " to ", valueStr);
 231 |     |             emit LogString(string(message));
 232 |     |             return value;
 233 |     |         }
 234 |     |         return a;
 235 |     |     }
 236 |     | 
 237 |     |     /// @notice clamps a to be greater than b
 238 |     |     function clampGt(uint256 a, uint256 b) internal returns (uint256) {
 239 |     |         if(!(a > b)){
 240 |     |             assertNeq(b, type(uint256).max, "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions.");
 241 |     |             uint256 value = b+1;
 242 |     |             string memory aStr = PropertiesLibString.toString(a);
 243 |     |             string memory valueStr = PropertiesLibString.toString(value);
 244 |     |             bytes memory message = abi.encodePacked("Clamping value ", aStr, " to ", valueStr);
 245 |     |             emit LogString(string(message));
 246 |     |             return value;
 247 |     |         } else {
 248 |     |             return a;
 249 |     |         }
 250 |     |     }
 251 |     | 
 252 |     |     /// @notice int256 version of clampGt
 253 |     |     function clampGt(int256 a, int256 b) internal returns (int256) {
 254 |     |         if(!(a > b)){
 255 |     |             int256 value = b+1;
 256 |     |             string memory aStr = PropertiesLibString.toString(a);
 257 |     |             string memory valueStr = PropertiesLibString.toString(value);
 258 |     |             bytes memory message = abi.encodePacked("Clamping value ", aStr, " to ", valueStr);
 259 |     |             emit LogString(string(message));
 260 |     |             return value;
 261 |     |         } else {
 262 |     |             return a;
 263 |     |         }
 264 |     |     }
 265 |     | 
 266 |     |     /// @notice clamps a to be greater than or equal to b
 267 |     |     function clampGte(uint256 a, uint256 b) internal returns (uint256) {
 268 |     |         if(!(a > b)){
 269 |     |             uint256 value = b;
 270 |     |             string memory aStr = PropertiesLibString.toString(a);
 271 |     |             string memory valueStr = PropertiesLibString.toString(value);
 272 |     |             bytes memory message = abi.encodePacked("Clamping value ", aStr, " to ", valueStr);
 273 |     |             emit LogString(string(message));
 274 |     |             return value;
 275 |     |         }
 276 |     |         return a;
 277 |     |     }
 278 |     | 
 279 |     |     /// @notice int256 version of clampGte
 280 |     |     function clampGte(int256 a, int256 b) internal returns (int256) {
 281 |     |         if(!(a > b)){
 282 |     |             int256 value = b;
 283 |     |             string memory aStr = PropertiesLibString.toString(a);
 284 |     |             string memory valueStr = PropertiesLibString.toString(value);
 285 |     |             bytes memory message = abi.encodePacked("Clamping value ", aStr, " to ", valueStr);
 286 |     |             emit LogString(string(message));
 287 |     |             return value;
 288 |     |         }
 289 |     |         return a;
 290 |     |     }
 291 |     | }
 292 |     | 
 293 |     | /// @notice Efficient library for creating string representations of integers.
 294 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
 295 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
 296 |     | /// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString
 297 |     | library PropertiesLibString {
 298 |     | 
 299 |     |     function toString(int256 value) internal pure returns (string memory str) {
 300 |     |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
 301 |     |         str = toString(absValue);
 302 |     | 
 303 |     |         if(value < 0) {
 304 |     |             str = string(abi.encodePacked("-", str));
 305 |     |         }
 306 |     |     }
 307 |     | 
 308 | *   |     function toString(uint256 value) internal pure returns (string memory str) {
 309 |     |         /// @solidity memory-safe-assembly
 310 |     |         assembly {
 311 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
 312 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
 313 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
 314 | *   |             let newFreeMemoryPointer := add(mload(0x40), 160)
 315 |     | 
 316 |     |             // Update the free memory pointer to avoid overriding our string.
 317 | *   |             mstore(0x40, newFreeMemoryPointer)
 318 |     | 
 319 |     |             // Assign str to the end of the zone of newly allocated memory.
 320 | *   |             str := sub(newFreeMemoryPointer, 32)
 321 |     | 
 322 |     |             // Clean the last word of memory it may not be overwritten.
 323 | *   |             mstore(str, 0)
 324 |     | 
 325 |     |             // Cache the end of the memory to calculate the length later.
 326 | *   |             let end := str
 327 |     | 
 328 |     |             // We write the string from rightmost digit to leftmost digit.
 329 |     |             // The following is essentially a do-while loop that also handles the zero case.
 330 |     |             // prettier-ignore
 331 | *   |             for { let temp := value } 1 {} {
 332 |     |                 // Move the pointer 1 byte to the left.
 333 | *   |                 str := sub(str, 1)
 334 |     | 
 335 |     |                 // Write the character to the pointer.
 336 |     |                 // The ASCII index of the '0' character is 48.
 337 | *   |                 mstore8(str, add(48, mod(temp, 10)))
 338 |     | 
 339 |     |                 // Keep dividing temp until zero.
 340 | *   |                 temp := div(temp, 10)
 341 |     | 
 342 |     |                  // prettier-ignore
 343 | *   |                 if iszero(temp) { break }
 344 |     |             }
 345 |     | 
 346 |     |             // Compute and cache the final total length of the string.
 347 | *   |             let length := sub(end, str)
 348 |     | 
 349 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
 350 | *   |             str := sub(str, 32)
 351 |     | 
 352 |     |             // Store the string's length at the start of memory allocated for our string.
 353 | *   |             mstore(str, length)
 354 |     |         }
 355 |     |     }
 356 |     | 
 357 |     |     function toString(address value) internal pure returns (string memory str){
 358 |     |         bytes memory s = new bytes(40);
 359 |     |         for (uint i = 0; i < 20; i++) {
 360 |     |             bytes1 b = bytes1(uint8(uint(uint160(value)) / (2**(8*(19 - i)))));
 361 |     |             bytes1 hi = bytes1(uint8(b) / 16);
 362 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
 363 |     |             s[2*i] = char(hi);
 364 |     |             s[2*i+1] = char(lo);            
 365 |     |         }
 366 |     |         return string(s);
 367 |     |     }
 368 |     | 
 369 |     |     function char(bytes1 b) internal pure returns (bytes1 c) {
 370 |     |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
 371 |     |         else return bytes1(uint8(b) + 0x57);
 372 |     |     }
 373 |     | }
 374 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/deploy-Platform.s.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.19;
   3 |     | 
   4 |     | import "forge-std/Script.sol";
   5 |     | 
   6 |     | /* OpenZeppelin Interfaces */
   7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   8 |     | 
   9 |     | /* OpenZeppelin Contract */
  10 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; 
  11 |     | import {TransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
  12 |     | import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
  13 |     | 
  14 |     | 
  15 |     | /* DeGaming Contracts */
  16 |     | import {Bankroll} from "src/Bankroll.sol";
  17 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  18 |     | import {DGBankrollFactory} from "src/DGBankrollFactory.sol";
  19 |     | import {DGEscrow} from "src/DGEscrow.sol";
  20 |     | 
  21 |     | /* DeGaming Libraries */
  22 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
  23 |     | 
  24 |     | contract DeployPlatform is Script {
  25 |     |     /// @dev Using SafeERC20 for safer token interaction
  26 |     |     using SafeERC20 for IERC20;
  27 |     | 
  28 |     |     // TransparentUpgradeableProxy public bankrollProxy;
  29 |     |     TransparentUpgradeableProxy public bankrollFactoryProxy;
  30 |     |     TransparentUpgradeableProxy public bankrollProxy;
  31 |     | 
  32 |     |     ProxyAdmin public proxyAdmin; 
  33 |     | 
  34 |     |     DGBankrollFactory public dgBankrollFactory;
  35 |     |     DGBankrollManager public dgBankrollManager;
  36 |     |     DGEscrow public dgEscrow;
  37 |     |     Bankroll public bankroll;
  38 |     | 
  39 |     |     uint256 deployerPrivateKey = vm.envUint("DEPLOYER_PRIVATE_KEY");
  40 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
  41 |     |     uint256 managerPrivateKey = vm.envUint("MANAGER_PRIVATE_KEY");
  42 |     | 
  43 |     |     address deployerPubKey = vm.addr(deployerPrivateKey);
  44 |     | 
  45 |     |     address deGaming = 0x1d424382e8e09CC6F8425c9F32D2c695E7698db7;
  46 |     | 
  47 |     |     // Addresses
  48 |     |     address public admin = vm.addr(adminPrivateKey);
  49 |     |     address public deployer = vm.addr(deployerPrivateKey);
  50 |     |     address public operator = vm.addr(managerPrivateKey);
  51 |     |     address public token = vm.envAddress("TOKEN_ADDRESS");
  52 |     | 
  53 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
  54 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
  55 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
  56 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
  57 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
  58 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
  59 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
  60 |     | 
  61 |     |     uint256 maxRisk = 10_000;
  62 |     |     uint256 threshold = 10_000;
  63 |     | 
  64 |     |     function run() public {
  65 |     |         vm.startBroadcast(deployerPrivateKey);
  66 |     | 
  67 |     |         console.log("#######################################################");
  68 |     |         console.log("ADDRESSES:");
  69 |     |         console.log("deployer: ", vm.addr(deployerPrivateKey));
  70 |     |         console.log("admin:    ", admin);
  71 |     |         console.log("Operator: ", vm.addr(managerPrivateKey));
  72 |     |         console.log("token:    ", token);
  73 |     |         console.log("#######################################################");
  74 |     |         console.log("PATHS:");
  75 |     |         console.log(PROXY_ADMIN_PATH);
  76 |     |         console.log(BANKROLL_IMPL_PATH);
  77 |     |         console.log(BANKROLL_MANAGER_PATH);
  78 |     |         console.log(FACTORY_PATH);
  79 |     |         console.log(ESCROW_PATH);
  80 |     |         console.log(BANKROLL_PATH);
  81 |     |         console.log("#######################################################");
  82 |     | 
  83 |     |         dgBankrollManager = new DGBankrollManager(admin);
  84 |     | 
  85 |     |         vm.writeFile(BANKROLL_MANAGER_PATH, vm.toString(address(dgBankrollManager)));
  86 |     | 
  87 |     |         dgEscrow = new DGEscrow(1 weeks, address(dgBankrollManager));
  88 |     | 
  89 |     |         vm.writeFile(ESCROW_PATH, vm.toString(address(dgEscrow)));
  90 |     | 
  91 |     |         proxyAdmin = new ProxyAdmin();
  92 |     | 
  93 |     |         vm.writeFile(PROXY_ADMIN_PATH, vm.toString(address(proxyAdmin)));
  94 |     | 
  95 |     |         bankroll = new Bankroll();
  96 |     | 
  97 |     |         vm.writeFile(BANKROLL_IMPL_PATH, vm.toString(address(bankroll)));
  98 |     | 
  99 |     |         bankrollFactoryProxy = new TransparentUpgradeableProxy(
 100 |     |             address(new DGBankrollFactory()),
 101 |     |             address(proxyAdmin),
 102 |     |             abi.encodeWithSelector(
 103 |     |                 DGBankrollFactory.initialize.selector,
 104 |     |                 address(bankroll),
 105 |     |                 address(dgBankrollManager),
 106 |     |                 address(dgEscrow),
 107 |     |                 admin,
 108 |     |                 deGaming
 109 |     |             )
 110 |     |         );
 111 |     | 
 112 |     |         vm.writeFile(FACTORY_PATH, vm.toString(address(bankrollFactoryProxy)));
 113 |     | 
 114 |     |         dgBankrollFactory = DGBankrollFactory(address(bankrollFactoryProxy));
 115 |     | 
 116 |     |         dgBankrollManager.grantRole(keccak256("ADMIN"), address(dgBankrollFactory));
 117 |     | 
 118 |     |         dgBankrollManager.grantRole(keccak256("ADMIN"), deployer);
 119 |     |         
 120 |     |         dgBankrollManager.grantRole(keccak256("ADMIN"), admin);
 121 |     |         
 122 |     |         dgEscrow.grantRole(keccak256("ADMIN"), admin);
 123 |     | 
 124 |     |         vm.stopBroadcast();
 125 |     |     }
 126 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/Bankroll/credit.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | import {Bankroll} from "src/Bankroll.sol";
  6 |     | 
  7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | contract Credit is Script {
 10 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 11 |     | 
 12 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 13 |     | 
 14 |     |     uint256 operatorPrivateKey = vm.envUint("MANAGER_PRIVATE_KEY");
 15 |     | 
 16 |     |     address operator = vm.addr(operatorPrivateKey);
 17 |     | 
 18 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 19 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 20 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 21 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 22 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 23 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 24 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 25 |     | 
 26 |     |     Bankroll bankroll = Bankroll(vm.parseAddress(vm.readFile(BANKROLL_PATH)));
 27 |     | 
 28 |     |     uint256 constant amount = 10_000e18;
 29 |     | 
 30 |     |     function run() external {
 31 |     |         vm.startBroadcast(adminPrivateKey);
 32 |     | 
 33 |     |         IERC20(token).approve(address(bankroll), amount);
 34 |     | 
 35 |     |         bankroll.credit(amount, operator);
 36 |     | 
 37 |     |         vm.stopBroadcast();
 38 |     |     }
 39 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/Bankroll/debit.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import "forge-std/Script.sol";
  5 |     | import {Bankroll} from "src/Bankroll.sol";
  6 |     | 
  7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | contract Debit is Script {
 10 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 11 |     | 
 12 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 13 |     | 
 14 |     |     uint256 operatorPrivateKey = vm.envUint("MANAGER_PRIVATE_KEY");
 15 |     | 
 16 |     |     address operator = vm.addr(operatorPrivateKey);
 17 |     | 
 18 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 19 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 20 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 21 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 22 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 23 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 24 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 25 |     |     string public ID_PATH = string.concat(PATH_PREFIX, "/EscrowId/bytes");
 26 |     | 
 27 |     |     Bankroll bankroll = Bankroll(vm.parseAddress(vm.readFile(BANKROLL_PATH)));
 28 |     | 
 29 |     |     uint256 constant amount = 10_000e18;
 30 |     | 
 31 |     |     function run() external {
 32 |     |         vm.startBroadcast(adminPrivateKey);
 33 |     | 
 34 |     |         bankroll.debit(0xDef28f7d7F3700e30F403B6350Fb54a358469874, amount, operator);
 35 |     | 
 36 |     |         vm.stopBroadcast();
 37 |     |     }
 38 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/Bankroll/deposit-funds.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | //import {Script} from "forge-std/Script.sol";
  5 |     | 
  6 |     | import "forge-std/Script.sol";
  7 |     | 
  8 |     | import {Bankroll} from "src/Bankroll.sol";
  9 |     | 
 10 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 11 |     | 
 12 |     | contract DepositFunds is Script {
 13 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 14 |     | 
 15 |     |     address tokenAddr = vm.envAddress("TOKEN_ADDRESS");
 16 |     | 
 17 |     |     uint256 operatorPrivateKey = vm.envUint("MANAGER_PRIVATE_KEY");
 18 |     | 
 19 |     |     address operator = vm.addr(operatorPrivateKey);
 20 |     | 
 21 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 22 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 23 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 24 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 25 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 26 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 27 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 28 |     | 
 29 |     |     Bankroll bankroll = Bankroll(vm.parseAddress(vm.readFile(BANKROLL_PATH)));
 30 |     | 
 31 |     |     uint256 constant amount = 1_000e18;
 32 |     | 
 33 |     |     function run() external {
 34 |     | 
 35 |     |         vm.startBroadcast(adminPrivateKey);
 36 |     | 
 37 |     |         IERC20(tokenAddr).approve(address(bankroll), amount);
 38 |     | 
 39 |     |         bankroll.depositFunds(amount);
 40 |     | 
 41 |     |         vm.stopBroadcast();
 42 |     |     }
 43 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/Bankroll/withdrawal-stage1.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | import {Bankroll} from "src/Bankroll.sol";
  6 |     | 
  7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | contract WithdrawFunds is Script {
 10 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 11 |     | 
 12 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 13 |     | 
 14 |     |     uint256 operatorPrivateKey = vm.envUint("MANAGER_PRIVATE_KEY");
 15 |     | 
 16 |     |     address operator = vm.addr(operatorPrivateKey);
 17 |     | 
 18 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 19 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 20 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 21 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 22 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 23 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 24 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 25 |     | 
 26 |     |     Bankroll bankroll = Bankroll(vm.parseAddress(vm.readFile(BANKROLL_PATH)));
 27 |     | 
 28 |     |     uint256 constant amount = 100e18;
 29 |     | 
 30 |     |     function run() external {
 31 |     |         vm.startBroadcast(adminPrivateKey);
 32 |     | 
 33 |     |         bankroll.withdrawalStageOne(amount);
 34 |     | 
 35 |     |         vm.stopBroadcast();
 36 |     |     }
 37 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/Bankroll/withdrawal-stage2.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | import {Bankroll} from "src/Bankroll.sol";
  6 |     | 
  7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | contract WithdrawFunds is Script {
 10 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 11 |     | 
 12 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 13 |     | 
 14 |     |     uint256 operatorPrivateKey = vm.envUint("MANAGER_PRIVATE_KEY");
 15 |     | 
 16 |     |     address operator = vm.addr(operatorPrivateKey);
 17 |     | 
 18 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 19 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 20 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 21 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 22 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 23 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 24 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 25 |     | 
 26 |     |     Bankroll bankroll = Bankroll(vm.parseAddress(vm.readFile(BANKROLL_PATH)));
 27 |     | 
 28 |     |     uint256 constant amount = 100e18;
 29 |     | 
 30 |     |     function run() external {
 31 |     |         vm.startBroadcast(adminPrivateKey);
 32 |     | 
 33 |     |         bankroll.withdrawalStageTwo();
 34 |     | 
 35 |     |         vm.stopBroadcast();
 36 |     |     }
 37 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/DGBankrollManager/add-bankroll.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  6 |     | 
  7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | contract AddBankroll is Script {
 10 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 11 |     | 
 12 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 13 |     | 
 14 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 15 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 16 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 17 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 18 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 19 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 20 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 21 |     | 
 22 |     |     DGBankrollManager bankrollManager = DGBankrollManager(vm.parseAddress(vm.readFile(BANKROLL_MANAGER_PATH)));
 23 |     | 
 24 |     |     function run(address bankroll, uint256 lpFee) external {
 25 |     | 
 26 |     |         vm.startBroadcast(adminPrivateKey);
 27 |     | 
 28 |     |         bankrollManager.approveBankroll(bankroll, lpFee);
 29 |     | 
 30 |     |         vm.stopBroadcast();
 31 |     |     }
 32 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/DGBankrollManager/add-operator.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.18;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  6 |     | 
  7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | contract AddOperator is Script {
 10 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 11 |     | 
 12 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 13 |     | 
 14 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 15 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 16 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 17 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 18 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 19 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 20 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 21 |     | 
 22 |     |     DGBankrollManager bankrollManager = DGBankrollManager(vm.parseAddress(vm.readFile(BANKROLL_MANAGER_PATH)));
 23 |     | 
 24 |     |     address bankroll = vm.parseAddress(vm.readFile(BANKROLL_PATH));
 25 |     | 
 26 |     |     function run(address operatorBlock) external {
 27 |     | 
 28 |     |         vm.startBroadcast(adminPrivateKey);
 29 |     | 
 30 |     |         bankrollManager.addOperator(operatorBlock);
 31 |     | 
 32 |     |         vm.stopBroadcast();
 33 |     |     }
 34 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/DGBankrollManager/block-bankroll.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  6 |     | 
  7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | contract BlockBankroll is Script {
 10 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 11 |     | 
 12 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 13 |     | 
 14 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 15 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 16 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 17 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 18 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 19 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 20 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 21 |     | 
 22 |     |     DGBankrollManager bankrollManager = DGBankrollManager(vm.parseAddress(vm.readFile(BANKROLL_MANAGER_PATH)));
 23 |     | 
 24 |     |     function run(address bankroll) external {
 25 |     |         vm.startBroadcast(adminPrivateKey);
 26 |     | 
 27 |     |         bankrollManager.blockBankroll(bankroll);
 28 |     | 
 29 |     |         vm.stopBroadcast();
 30 |     |     }
 31 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/DGBankrollManager/block-operator.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  6 |     | 
  7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | contract BlockOperator is Script {
 10 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 11 |     | 
 12 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 13 |     | 
 14 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 15 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 16 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 17 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 18 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 19 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 20 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 21 |     | 
 22 |     |     DGBankrollManager bankrollManager = DGBankrollManager(vm.parseAddress(vm.readFile(BANKROLL_MANAGER_PATH)));
 23 |     | 
 24 |     |     address bankroll = vm.parseAddress(vm.readFile(BANKROLL_PATH));
 25 |     | 
 26 |     |     function run(address operatorBlock) external {
 27 |     | 
 28 |     |         vm.startBroadcast(adminPrivateKey);
 29 |     | 
 30 |     |         bankrollManager.blockOperator(operatorBlock);
 31 |     | 
 32 |     |         vm.stopBroadcast();
 33 |     |     }
 34 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/DGBankrollManager/claim-profit.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  6 |     | import {Bankroll} from "src/Bankroll.sol";
  7 |     | 
  8 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  9 |     | 
 10 |     | contract ClaimProfit is Script {
 11 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 12 |     | 
 13 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 14 |     | 
 15 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 16 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 17 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 18 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 19 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 20 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 21 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 22 |     | 
 23 |     |     DGBankrollManager bankrollManager = DGBankrollManager(vm.parseAddress(vm.readFile(BANKROLL_MANAGER_PATH)));
 24 |     | 
 25 |     |     Bankroll bankroll = Bankroll(vm.parseAddress(vm.readFile(BANKROLL_PATH)));
 26 |     | 
 27 |     |     function run() external {
 28 |     |         vm.startBroadcast(adminPrivateKey);
 29 |     | 
 30 |     |         bankroll.maxContractsApprove();
 31 |     | 
 32 |     |         bankrollManager.claimProfit(address(bankroll));
 33 |     | 
 34 |     |         vm.stopBroadcast();
 35 |     |     }
 36 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/DGEscrow/release-funds.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | //import {DGBankrollManager} from "src/DGBankrollManager.sol";
  6 |     | import {DGEscrow} from "src/DGEscrow.sol";
  7 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
  8 |     | 
  9 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 10 |     | 
 11 |     | contract ClaimProfit is Script {
 12 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 13 |     | 
 14 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 15 |     | 
 16 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 17 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 18 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 19 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 20 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 21 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 22 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 23 |     |     string public ID_PATH = string.concat(PATH_PREFIX, "/EscrowId/bytes");
 24 |     | 
 25 |     |     DGEscrow escrow = DGEscrow(vm.parseAddress(vm.readFile(ESCROW_PATH)));
 26 |     | 
 27 |     |     function run() public {
 28 |     |         vm.startBroadcast(adminPrivateKey);
 29 |     | 
 30 |     |         // PASTE ID HERE
 31 |     |         //escrow.releaseFunds(vm.parseBytes(vm.readFile(ID_PATH))); 
 32 |     | 
 33 |     |         DGDataTypes.EscrowEntry memory entry = DGDataTypes.EscrowEntry(
 34 |     |             0x242f2d72f6B9F534B6182d911e719b7be7a81861,
 35 |     |             0x312BA46064e1fe5904362BfB0C52c38F20d3Ef44,
 36 |     |             0xDef28f7d7F3700e30F403B6350Fb54a358469874,
 37 |     |             0xc6ADeA8722C2DB1EFF810f429C3C09BA00E1F25C,
 38 |     |             1711105908
 39 |     |         );
 40 |     | 
 41 |     |         bytes memory id = abi.encode(entry);
 42 |     | 
 43 |     |         escrow.releaseFunds(id);
 44 |     | 
 45 |     |         vm.stopBroadcast();
 46 |     |     }
 47 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/DGEscrow/revert-funds.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | //import {DGBankrollManager} from "src/DGBankrollManager.sol";
  6 |     | import {DGEscrow} from "src/DGEscrow.sol";
  7 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
  8 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  9 |     | 
 10 |     | contract ClaimProfit is Script {
 11 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 12 |     | 
 13 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 14 |     | 
 15 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 16 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 17 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 18 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 19 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 20 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 21 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 22 |     |     string public ID_PATH = string.concat(PATH_PREFIX, "/EscrowId/bytes");
 23 |     | 
 24 |     |     DGEscrow escrow = DGEscrow(vm.parseAddress(vm.readFile(ESCROW_PATH)));
 25 |     | 
 26 |     |     function run() public {
 27 |     |         vm.startBroadcast(adminPrivateKey);
 28 |     | 
 29 |     |         DGDataTypes.EscrowEntry memory entry = DGDataTypes.EscrowEntry(
 30 |     |             0x242f2d72f6B9F534B6182d911e719b7be7a81861,
 31 |     |             0x312BA46064e1fe5904362BfB0C52c38F20d3Ef44,
 32 |     |             0xDef28f7d7F3700e30F403B6350Fb54a358469874,
 33 |     |             0xc6ADeA8722C2DB1EFF810f429C3C09BA00E1F25C,
 34 |     |             1711104158
 35 |     |         );
 36 |     | 
 37 |     |         bytes memory id = abi.encode(entry);
 38 |     | 
 39 |     |         // PASTE ID HERE
 40 |     |         escrow.revertFunds(id);
 41 |     | 
 42 |     |         vm.stopBroadcast();
 43 |     |     }
 44 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/MockToken/mint-token.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Script} from "forge-std/Script.sol";
  5 |     | 
  6 |     | import {MockToken} from "test/mock/MockToken.sol";
  7 |     | 
  8 |     | contract MintTokens is Script {
  9 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 10 |     | 
 11 |     |     address token = vm.envAddress("TOKEN_ADDRESS");
 12 |     | 
 13 |     |     uint256 constant amount = 100;
 14 |     | 
 15 |     |     MockToken USDT = MockToken(token);
 16 |     | 
 17 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 18 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 19 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 20 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 21 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 22 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 23 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 24 |     | 
 25 |     |     address bankroll = vm.parseAddress(vm.readFile(BANKROLL_PATH));
 26 |     | 
 27 |     |     function run() public {
 28 |     | 
 29 |     |         vm.startBroadcast(adminPrivateKey);
 30 |     | 
 31 |     |         USDT.mint(vm.addr(adminPrivateKey), 1_000_000_000_000_000_000_000_000);
 32 |     | 
 33 |     |         USDT.approve(bankroll, 1_000_000_000_000_000_000_000_000);
 34 |     |     }
 35 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/script/utils/create-Bankroll.s.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import "forge-std/Script.sol";
  5 |     | 
  6 |     | /* OpenZeppelin Interfaces */
  7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | /* OpenZeppelin Contract */
 10 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; 
 11 |     | import {TransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
 12 |     | import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
 13 |     | 
 14 |     | 
 15 |     | /* DeGaming Contracts */
 16 |     | import {Bankroll} from "src/Bankroll.sol";
 17 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
 18 |     | import {DGBankrollFactory} from "src/DGBankrollFactory.sol";
 19 |     | import {DGEscrow} from "src/DGEscrow.sol";
 20 |     | 
 21 |     | /* DeGaming Libraries */
 22 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
 23 |     | 
 24 |     | contract CreateBankroll is Script {
 25 |     |     /// @dev Using SafeERC20 for safer token interaction
 26 |     |     using SafeERC20 for IERC20;
 27 |     | 
 28 |     |     // TransparentUpgradeableProxy public bankrollProxy;
 29 |     |     TransparentUpgradeableProxy public bankrollFactoryProxy;
 30 |     |     TransparentUpgradeableProxy public bankrollProxy;
 31 |     | 
 32 |     |     ProxyAdmin public proxyAdmin; 
 33 |     | 
 34 |     |     DGBankrollFactory public dgBankrollFactory;
 35 |     |     DGBankrollManager public dgBankrollManager;
 36 |     |     DGEscrow public dgEscrow;
 37 |     |     Bankroll public bankroll;
 38 |     | 
 39 |     |     uint256 deployerPrivateKey = vm.envUint("DEPLOYER_PRIVATE_KEY");
 40 |     |     uint256 adminPrivateKey = vm.envUint("ADMIN_PRIVATE_KEY");
 41 |     |     uint256 managerPrivateKey = vm.envUint("MANAGER_PRIVATE_KEY");
 42 |     | 
 43 |     |     address deployerPubKey = vm.addr(deployerPrivateKey);
 44 |     | 
 45 |     |     address deGaming = 0x1d424382e8e09CC6F8425c9F32D2c695E7698db7;
 46 |     | 
 47 |     |     // Addresses
 48 |     |     address public admin = vm.addr(adminPrivateKey);
 49 |     |     address public deployer = vm.addr(deployerPrivateKey);
 50 |     |     address public operator = vm.addr(managerPrivateKey);
 51 |     |     address public token = vm.envAddress("TOKEN_ADDRESS");
 52 |     | 
 53 |     |     string public PATH_PREFIX = string.concat("deployment/", vm.toString(block.chainid));
 54 |     |     string public PROXY_ADMIN_PATH = string.concat(PATH_PREFIX, "/ProxyAdmin/address");
 55 |     |     string public BANKROLL_IMPL_PATH = string.concat(PATH_PREFIX, "/BankrollImpl/address");
 56 |     |     string public BANKROLL_MANAGER_PATH = string.concat(PATH_PREFIX, "/DGBankrollManager/address");
 57 |     |     string public FACTORY_PATH = string.concat(PATH_PREFIX, "/DGBankrollFactory/address");
 58 |     |     string public ESCROW_PATH = string.concat(PATH_PREFIX, "/DGEscrow/address");
 59 |     |     string public BANKROLL_PATH = string.concat(PATH_PREFIX, "/Bankroll/address");
 60 |     | 
 61 |     |     uint256 maxRisk = 8_000;
 62 |     |     uint256 threshold = 5_000;
 63 |     | 
 64 |     |     function run() public {
 65 |     |         vm.startBroadcast(deployerPrivateKey);
 66 |     | 
 67 |     |         proxyAdmin = ProxyAdmin(vm.parseAddress(vm.readFile(PROXY_ADMIN_PATH)));
 68 |     |         //bankrollProxy = TransparentUpgradeableProxy(vm.parseAddress(vm.readFile(BANKROLL_IMPL_PATH)));
 69 |     |         dgBankrollManager = DGBankrollManager(vm.parseAddress(vm.readFile(BANKROLL_MANAGER_PATH)));
 70 |     |         dgBankrollFactory = DGBankrollFactory(vm.parseAddress(vm.readFile(FACTORY_PATH)));
 71 |     |         dgEscrow = DGEscrow(vm.parseAddress(vm.readFile(ESCROW_PATH)));
 72 |     |         //bankroll = Bankroll(vm.parseAddress(vm.readFile(BANKROLL_PATH)));
 73 |     | 
 74 |     |         dgBankrollFactory.deployBankroll(token, maxRisk, threshold, "0x0");
 75 |     |         address bankrollAddress = dgBankrollFactory.bankrolls(dgBankrollFactory.bankrollCount() - 1);
 76 |     |         dgBankrollManager.addOperator(operator);
 77 |     |         dgBankrollManager.approveBankroll(bankrollAddress, 650);
 78 |     |         dgBankrollManager.setOperatorToBankroll(bankrollAddress, operator);
 79 |     |         vm.writeFile(BANKROLL_PATH, vm.toString(bankrollAddress));
 80 |     |         bankroll = Bankroll(bankrollAddress);
 81 |     |         vm.stopBroadcast();
 82 |     |         vm.startBroadcast(adminPrivateKey);
 83 |     |         bankroll.maxContractsApprove();
 84 |     |         vm.stopBroadcast();
 85 |     |     }
 86 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/Bankroll.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.19;
   3 |     | 
   4 |     | /* Openzeppelin Interfaces */
   5 |     | import {IERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
   6 |     | 
   7 |     | /* Openzeppelin Contracts */
   8 |     | import {SafeERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
   9 |     | import {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
  10 |     | import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
  11 |     | 
  12 |     | /* DeGaming Interfaces */
  13 |     | import {IBankroll} from "src/interfaces/IBankroll.sol";
  14 |     | import {IDGBankrollManager} from "src/interfaces/IDGBankrollManager.sol";
  15 |     | import {IDGEscrow} from "src/interfaces/IDGEscrow.sol";
  16 |     | 
  17 |     | /* DeGaming Libraries */
  18 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
  19 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
  20 |     | import {DGEvents} from "src/libraries/DGEvents.sol";
  21 |     | 
  22 |     | /**
  23 |     |  * @title Bankroll V2
  24 |     |  * @author DeGaming Technical Team
  25 |     |  * @notice Operator and Game Bankroll Contract
  26 |     |  *
  27 |     |  */
  28 | *   | contract Bankroll is IBankroll, AccessControlUpgradeable, ReentrancyGuardUpgradeable {
  29 |     |     /// @dev Using SafeERC20 for safer token interaction
  30 |     |     using SafeERC20Upgradeable for IERC20Upgradeable;
  31 |     | 
  32 |     |     /// @dev the current aggregated profit of the bankroll balance
  33 | *   |     int256 public GGR;
  34 |     | 
  35 |     |     /// @dev total amount of shares
  36 | *   |     uint256 public totalSupply;
  37 |     | 
  38 |     |     /// @dev used to calculate percentages
  39 |     |     uint256 public constant DENOMINATOR = 10_000;
  40 |     | 
  41 |     |     /// @dev Max percentage of liquidity risked
  42 |     |     uint256 public maxRiskPercentage;
  43 |     | 
  44 |     |     /// @dev Escrow threshold percentage
  45 |     |     uint256 public escrowTreshold;
  46 |     | 
  47 |     |     /// @dev amount for minimum pool in case it exists
  48 |     |     uint256 public minimumLp;
  49 |     | 
  50 |     |     // @dev Withdrawal delay
  51 |     |     uint256 public withdrawalDelay;
  52 |     | 
  53 |     |     /// @dev WithdrawalWindow length
  54 |     |     uint256 public withdrawalWindowLength;
  55 |     | 
  56 |     |     /// @dev Minimum time between withdrawal step one
  57 |     |     uint256 public withdrawalEventPeriod;
  58 |     | 
  59 |     |     /// @dev ADMIN role
  60 |     |     bytes32 public constant ADMIN = keccak256("ADMIN");
  61 |     | 
  62 |     |     /// @dev BANKROLL_MANAGER role
  63 |     |     bytes32 public constant BANKROLL_MANAGER = keccak256("BANKROLL_MANAGER");
  64 |     | 
  65 |     |     /// @dev The GGR of a certain operator
  66 | *   |     mapping(address operator => int256 operatorGGR) public ggrOf;
  67 |     | 
  68 |     |     /// @dev Withdrawal window per lp
  69 |     |     mapping(address lp => DGDataTypes.WithdrawalInfo info) withdrawalInfoOf;
  70 |     | 
  71 |     |     /// @dev Withdrawal stage one limit
  72 |     |     mapping(address lp => uint256 timestamp) public withdrawalLimitOf;
  73 |     | 
  74 |     |     /// @dev amount of shares per lp
  75 | *   |     mapping(address lp => uint256 shares) public sharesOf;
  76 |     | 
  77 |     |     /// @dev allowed LP addresses
  78 |     |     mapping(address lp => bool authorized) public lpWhitelist;
  79 |     | 
  80 |     |     /// @dev bankroll liquidity token
  81 |     |     IERC20Upgradeable public token;
  82 |     | 
  83 |     |     /// @dev Bankroll manager instance
  84 |     |     IDGBankrollManager dgBankrollManager;
  85 |     | 
  86 |     |     /// @dev Escrow instance
  87 |     |     IDGEscrow escrow;
  88 |     | 
  89 |     |     /// @dev set status regarding if LP is open or whitelisted
  90 |     |     DGDataTypes.LpIs public lpIs = DGDataTypes.LpIs.OPEN;
  91 |     | 
  92 |     |     //     ______                 __                  __
  93 |     |     //    / ____/___  ____  _____/ /________  _______/ /_____  _____
  94 |     |     //   / /   / __ \/ __ \/ ___/ __/ ___/ / / / ___/ __/ __ \/ ___/
  95 |     |     //  / /___/ /_/ / / / (__  ) /_/ /  / /_/ / /__/ /_/ /_/ / /
  96 |     |     //  \____/\____/_/ /_/____/\__/_/   \__,_/\___/\__/\____/_/
  97 |     |     /**
  98 |     |      * @notice
  99 |     |      *  Contract Constructor
 100 |     |      */
 101 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
 102 |     |     constructor() {
 103 |     |         _disableInitializers();
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @notice Bankroll constructor
 108 |     |      *
 109 |     |      * @param _admin Admin address
 110 |     |      * @param _token Bankroll liquidity token address
 111 |     |      * @param _bankrollManager address of bankroll manager
 112 |     |      * @param _escrow address of escrow contract
 113 |     |      * @param _owner address of contract owner
 114 |     |      * @param _maxRiskPercentage the max risk that the bankroll balance is risking for each game
 115 |     |      *
 116 |     |      */
 117 |     |     function initialize(
 118 |     |         address _admin,
 119 |     |         address _token,
 120 |     |         address _bankrollManager,
 121 |     |         address _escrow,
 122 |     |         address _owner,
 123 |     |         uint256 _maxRiskPercentage,
 124 |     |         uint256 _escrowThreshold
 125 |     |     ) external initializer {
 126 |     |         // Check so that both bankroll manager,token and escrow are contracts
 127 |     |         if (!_isContract(_bankrollManager) || !_isContract(_token) || !_isContract(_escrow)) {
 128 |     |             revert DGErrors.ADDRESS_NOT_A_CONTRACT();
 129 |     |         }
 130 |     | 
 131 |     |         // Check so that owner is not a contract
 132 |     |         if (_isContract(_owner)) revert DGErrors.ADDRESS_NOT_A_WALLET();
 133 |     | 
 134 |     |         // Check so that maxRiskPercentage isnt larger than denominator
 135 |     |         if (_maxRiskPercentage > DENOMINATOR) revert DGErrors.MAXRISK_TOO_HIGH();
 136 |     | 
 137 |     |         // Check so that maxrisk doestn't exceed 100%
 138 |     |         if (_escrowThreshold > DENOMINATOR) revert DGErrors.ESCROW_THRESHOLD_TOO_HIGH();
 139 |     | 
 140 |     |         __AccessControl_init();
 141 |     | 
 142 |     |         // Initializing erc20 token associated with bankroll
 143 |     |         token = IERC20Upgradeable(_token);
 144 |     | 
 145 |     |         // Set the max risk percentage
 146 |     |         maxRiskPercentage = _maxRiskPercentage;
 147 |     | 
 148 |     |         // Set escrow threshold
 149 |     |         escrowTreshold = _escrowThreshold;
 150 |     | 
 151 |     |         // Set default withdrawal delay in seconfs
 152 |     |         withdrawalDelay = 1;
 153 |     | 
 154 |     |         // Set default withdrawal window
 155 |     |         withdrawalWindowLength = 5 minutes;
 156 |     | 
 157 |     |         // Set default staging period
 158 |     |         withdrawalEventPeriod = 1 hours;
 159 |     | 
 160 |     |         // Setup bankroll manager
 161 |     |         dgBankrollManager = IDGBankrollManager(_bankrollManager);
 162 |     | 
 163 |     |         // Setup escrow
 164 |     |         escrow = IDGEscrow(_escrow);
 165 |     | 
 166 |     |         // grant owner default admin role
 167 |     |         _grantRole(DEFAULT_ADMIN_ROLE, _owner);
 168 |     | 
 169 |     |         // grant Admin role to escrow contract
 170 |     |         _grantRole(ADMIN, _escrow);
 171 |     | 
 172 |     |         // Grant Admin role
 173 |     |         _grantRole(ADMIN, _admin);
 174 |     | 
 175 |     |         // Grant Bankroll manager role
 176 |     |         _grantRole(BANKROLL_MANAGER, _bankrollManager);
 177 |     |     }
 178 |     | 
 179 |     |     //      ______     __                        __   ______                 __  _
 180 |     |     //     / ____/  __/ /____  _________  ____ _/ /  / ____/_  ______  _____/ /_(_)___  ____  _____
 181 |     |     //    / __/ | |/_/ __/ _ \/ ___/ __ \/ __ `/ /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 182 |     |     //   / /____>  </ /_/  __/ /  / / / / /_/ / /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 183 |     |     //  /_____/_/|_|\__/\___/_/  /_/ /_/\__,_/_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 184 |     | 
 185 |     |     /**
 186 |     |      * @notice Deposit ERC20 tokens to the bankroll
 187 |     |      *  Called by Liquidity Providers
 188 |     |      *
 189 |     |      * @param _amount Amount of ERC20 tokens to deposit
 190 |     |      *
 191 |     |      */
 192 | *   |     function depositFunds(uint256 _amount) external {
 193 |     |         // check if the user is allowed to deposit if the bankroll is not public
 194 |     |         if (lpIs == DGDataTypes.LpIs.WHITELISTED && !lpWhitelist[msg.sender]) revert DGErrors.LP_IS_NOT_WHITELISTED();
 195 |     | 
 196 |     |         // Check if the bankroll has a minimum lp and if so that the deposition exceeds it
 197 |     |         if (_amount < minimumLp) revert DGErrors.DEPOSITION_TO_LOW();
 198 |     | 
 199 |     |         // store liquidity variable to calculate amounts of shares minted, since
 200 |     |         // the liquidity() result will change before we have the amount variable
 201 |     |         uint256 liq = liquidity();
 202 |     | 
 203 |     |         // fetch balance before
 204 |     |         uint256 balanceBefore = token.balanceOf(address(this));
 205 |     | 
 206 |     |         // transfer ERC20 from the user to the vault
 207 |     |         token.safeTransferFrom(msg.sender, address(this), _amount);
 208 |     | 
 209 |     |         // fetch balance aftrer
 210 |     |         uint256 balanceAfter = token.balanceOf(address(this));
 211 |     | 
 212 |     |         // amount variable calculated from recieved balances
 213 |     |         uint256 amount = balanceAfter - balanceBefore;
 214 |     | 
 215 |     |         // calculate the amount of shares to mint
 216 |     |         uint256 shares;
 217 |     |         if (totalSupply < 1) {
 218 |     |             shares = amount;
 219 |     |         } else {
 220 |     |             shares = (amount * totalSupply) / liq;
 221 |     |         }
 222 |     | 
 223 |     |         // mint shares to the user
 224 |     |         _mint(msg.sender, shares);
 225 |     | 
 226 |     |         // Emit a funds deposited event
 227 |     |         emit DGEvents.FundsDeposited(msg.sender, amount);
 228 |     |     }
 229 |     | 
 230 |     |     /**
 231 |     |      * @notice Stage one of withdrawal process
 232 |     |      *
 233 |     |      * @param _amount Amount of shares to withdraw
 234 |     |      *
 235 |     |      */
 236 | *   |     function withdrawalStageOne(uint256 _amount) external {
 237 |     |         // Make sure that LPs don't try to withdraw more than they have
 238 |     |         if (_amount > sharesOf[msg.sender]) revert DGErrors.LP_REQUESTED_AMOUNT_OVERFLOW();
 239 |     | 
 240 |     |         // Fetch withdrawal info
 241 |     |         DGDataTypes.WithdrawalInfo memory withdrawalInfo = withdrawalInfoOf[msg.sender];
 242 |     | 
 243 |     |         // Make sure that previous withdrawal is either fullfilled or window has passed
 244 |     |         if (
 245 |     |             withdrawalInfo.stage == DGDataTypes.WithdrawalIs.STAGED
 246 |     |                 && block.timestamp < withdrawalInfo.timestamp + withdrawalWindowLength
 247 |     |         ) revert DGErrors.WITHDRAWAL_PROCESS_IN_STAGING();
 248 |     | 
 249 |     |         // Check so that event period timestamp has passed
 250 |     |         if (block.timestamp < withdrawalLimitOf[msg.sender]) revert DGErrors.WITHDRAWAL_TIMESTAMP_HASNT_PASSED();
 251 |     | 
 252 |     |         // Update withdrawalInfo of LP
 253 |     |         withdrawalInfoOf[msg.sender] =
 254 |     |             DGDataTypes.WithdrawalInfo(block.timestamp, _amount, DGDataTypes.WithdrawalIs.STAGED);
 255 |     | 
 256 |     |         // Set new withdrawal Limit of LP
 257 |     |         withdrawalLimitOf[msg.sender] = block.timestamp + withdrawalEventPeriod;
 258 |     | 
 259 |     |         // Emit withdrawal staged event
 260 |     |         emit DGEvents.WithdrawalStaged(
 261 |     |             msg.sender, block.timestamp + withdrawalDelay, block.timestamp + withdrawalWindowLength
 262 |     |         );
 263 |     |     }
 264 |     | 
 265 |     |     /**
 266 |     |      * @notice Stage two of withdrawal process
 267 |     |      *
 268 |     |      */
 269 | *   |     function withdrawalStageTwo() external nonReentrant {
 270 |     |         // Fetch withdrawal info of sender
 271 |     |         DGDataTypes.WithdrawalInfo memory withdrawalInfo = withdrawalInfoOf[msg.sender];
 272 |     | 
 273 |     |         // make sure that withdrawal is in staging
 274 |     |         if (withdrawalInfo.stage == DGDataTypes.WithdrawalIs.FULLFILLED) {
 275 |     |             revert DGErrors.WITHDRAWAL_ALREADY_FULLFILLED();
 276 |     |         }
 277 |     | 
 278 |     |         // Make sure it is within withdrawal window
 279 |     |         if (
 280 |     |             block.timestamp < withdrawalInfo.timestamp + withdrawalDelay
 281 |     |                 || block.timestamp > withdrawalInfo.timestamp + withdrawalWindowLength
 282 |     |         ) revert DGErrors.OUTSIDE_WITHDRAWAL_WINDOW();
 283 |     | 
 284 |     |         // Call internal withdrawal function
 285 |     |         _withdraw(withdrawalInfo.amountToClaim, msg.sender);
 286 |     | 
 287 |     |         // Set stage status ti FULLFILLED
 288 |     |         withdrawalInfoOf[msg.sender].stage = DGDataTypes.WithdrawalIs.FULLFILLED;
 289 |     |     }
 290 |     | 
 291 |     |     /**
 292 |     |      * @notice Pay player amount in ERC20 tokens from the bankroll
 293 |     |      *  Called by Admin
 294 |     |      *
 295 |     |      * @param _player Player wallet
 296 |     |      * @param _amount Prize money amount
 297 |     |      * @param _operator The operator from which the call comes from
 298 |     |      *
 299 |     |      */
 300 | *   |     function debit(address _player, uint256 _amount, address _operator) external onlyRole(ADMIN) {
 301 |     |         // Check that operator is approved
 302 |     |         if (!dgBankrollManager.isApproved(_operator)) revert DGErrors.NOT_AN_OPERATOR();
 303 |     | 
 304 |     |         // Check so that operator is associated with this bankroll
 305 |     |         if (!dgBankrollManager.operatorOfBankroll(address(this), _operator)) {
 306 |     |             revert DGErrors.OPERATOR_NOT_ASSOCIATED_WITH_BANKROLL();
 307 |     |         }
 308 |     | 
 309 |     |         // Check to make sure that wallet is EOA
 310 |     |         if (_isContract(_player)) revert DGErrors.NOT_AN_EOA_WALLET();
 311 |     | 
 312 |     |         // pay what is left if amount is bigger than bankroll balance
 313 |     |         uint256 maxRisk = getMaxRisk();
 314 |     |         if (_amount > maxRisk) {
 315 |     |             _amount = maxRisk;
 316 |     |             // Emit event that the bankroll is sweppt
 317 |     |             emit DGEvents.BankrollSwept(_player, _amount);
 318 |     |         }
 319 |     | 
 320 |     |         // Fetch escrow threshold
 321 |     |         uint256 threshold = getEscrowThreshold();
 322 |     | 
 323 |     |         // fetch balance before
 324 |     |         uint256 balanceBefore = token.balanceOf(address(this));
 325 |     | 
 326 |     |         // Create amount variable
 327 |     |         uint256 amount;
 328 |     | 
 329 |     |         // If amount is more then threshold, deposit into escrow...
 330 |     |         if (_amount > threshold) {
 331 |     |             escrow.depositFunds(_player, _operator, address(token), _amount);
 332 |     | 
 333 |     |             // fetch balance aftrer
 334 |     |             uint256 balanceAfter = token.balanceOf(address(this));
 335 |     | 
 336 |     |             // amount variable calculated from recieved balances
 337 |     |             amount = balanceBefore - balanceAfter;
 338 |     | 
 339 |     |             // ... Else go on with payout
 340 |     |         } else {
 341 |     |             // transfer ERC20 from the vault to the winner
 342 |     |             token.safeTransfer(_player, _amount);
 343 |     | 
 344 |     |             // fetch balance aftrer
 345 |     |             uint256 balanceAfter = token.balanceOf(address(this));
 346 |     | 
 347 |     |             // amount variable calculated from recieved balances
 348 |     |             amount = balanceBefore - balanceAfter;
 349 |     | 
 350 |     |             // Emit debit event
 351 |     |             emit DGEvents.Debit(msg.sender, _player, amount);
 352 |     |         }
 353 |     | 
 354 |     |         // substract from total GGR
 355 |     |         GGR -= int256(amount);
 356 |     | 
 357 |     |         // subtracting the amount from the specified operator GGR
 358 |     |         ggrOf[_operator] -= int256(amount);
 359 |     |     }
 360 |     | 
 361 |     |     /**
 362 |     |      * @notice Pay bankroll in ERC20 tokens from players loss
 363 |     |      *  Called by Admin
 364 |     |      *
 365 |     |      * @param _amount Player loss amount
 366 |     |      * @param _operator The operator from which the call comes from
 367 |     |      *
 368 |     |      */
 369 | *   |     function credit(uint256 _amount, address _operator) external onlyRole(ADMIN) {
 370 |     |         // Check that operator is approved
 371 |     |         if (!dgBankrollManager.isApproved(_operator)) revert DGErrors.NOT_AN_OPERATOR();
 372 |     | 
 373 |     |         // Check so that operator is associated with this bankroll
 374 |     |         if (!dgBankrollManager.operatorOfBankroll(address(this), _operator)) {
 375 |     |             revert DGErrors.OPERATOR_NOT_ASSOCIATED_WITH_BANKROLL();
 376 |     |         }
 377 |     | 
 378 |     |         // fetch balance before
 379 |     |         uint256 balanceBefore = token.balanceOf(address(this));
 380 |     | 
 381 |     |         // transfer ERC20 from the manager to the vault
 382 |     |         token.safeTransferFrom(msg.sender, address(this), _amount);
 383 |     | 
 384 |     |         // fetch balance aftrer
 385 |     |         uint256 balanceAfter = token.balanceOf(address(this));
 386 |     | 
 387 |     |         // amount variable calculated from recieved balances
 388 |     |         uint256 amount = balanceAfter - balanceBefore;
 389 |     | 
 390 |     |         // Add to total GGR
 391 |     |         GGR += int256(amount);
 392 |     | 
 393 |     |         // add the amount to the specified operator GGR
 394 |     |         ggrOf[_operator] += int256(amount);
 395 |     | 
 396 |     |         // Emit credit event
 397 |     |         emit DGEvents.Credit(msg.sender, amount);
 398 |     |     }
 399 |     | 
 400 |     |     /**
 401 |     |      * @notice Change withdrawal delay for LPs
 402 |     |      *  Only callable by ADMIN
 403 |     |      *
 404 |     |      * @param _withdrawalDelay New withdrawal Delay in seconds
 405 |     |      *
 406 |     |      */
 407 |     |     function setWithdrawalDelay(uint256 _withdrawalDelay) external onlyRole(ADMIN) {
 408 |     |         withdrawalDelay = _withdrawalDelay;
 409 |     |     }
 410 |     | 
 411 |     |     /**
 412 |     |      * @notice Change withdrawal window for LPs
 413 |     |      *  Only callable by ADMIN
 414 |     |      *
 415 |     |      * @param _withdrawalWindow New withdrawal window in seconds
 416 |     |      *
 417 |     |      */
 418 |     |     function setWithdrawalWindow(uint256 _withdrawalWindow) external onlyRole(ADMIN) {
 419 |     |         withdrawalWindowLength = _withdrawalWindow;
 420 |     |     }
 421 |     | 
 422 |     |     /**
 423 |     |      * @notice
 424 |     |      *  Allows admin to update bankroll manager contract
 425 |     |      *
 426 |     |      * @param _newBankrollManager address of the new bankroll manager
 427 |     |      *
 428 |     |      */
 429 |     |     function updateBankrollManager(address _newBankrollManager) external onlyRole(ADMIN) {
 430 |     |         // Make sure that the new bankroll manager is a contract
 431 |     |         if (!_isContract(_newBankrollManager)) revert DGErrors.ADDRESS_NOT_A_CONTRACT();
 432 |     | 
 433 |     |         // Revoke old bankroll manager role
 434 |     |         _revokeRole(BANKROLL_MANAGER, address(dgBankrollManager));
 435 |     | 
 436 |     |         // set the new bankroll manager
 437 |     |         dgBankrollManager = IDGBankrollManager(_newBankrollManager);
 438 |     | 
 439 |     |         // Grant new bankroll manager role
 440 |     |         _grantRole(BANKROLL_MANAGER, _newBankrollManager);
 441 |     |     }
 442 |     | 
 443 |     |     /**
 444 |     |      * @notice Change withdrawal (stage one) event period for LPs
 445 |     |      *  Only callable by ADMIN
 446 |     |      *
 447 |     |      * @param _withdrawalEventPeriod New staging event period in seconds
 448 |     |      *
 449 |     |      */
 450 |     |     function setWithdrawalEventPeriod(uint256 _withdrawalEventPeriod) external onlyRole(ADMIN) {
 451 |     |         withdrawalEventPeriod = _withdrawalEventPeriod;
 452 |     |     }
 453 |     | 
 454 |     |     /**
 455 |     |      * @notice Remove or add authorized liquidity provider to the bankroll
 456 |     |      *  Called by Admin
 457 |     |      *
 458 |     |      * @param _lp Liquidity Provider address
 459 |     |      * @param _isAuthorized If false, LP will not be able to deposit
 460 |     |      *
 461 |     |      */
 462 |     |     function setInvestorWhitelist(address _lp, bool _isAuthorized) external {
 463 |     |         // Check if caller is either an approved operator or admin wallet
 464 |     |         if (!dgBankrollManager.isApproved(msg.sender) && !hasRole(ADMIN, msg.sender)) {
 465 |     |             revert DGErrors.NO_LP_ACCESS_PERMISSION();
 466 |     |         }
 467 |     | 
 468 |     |         // Add toggle LPs _isAuthorized status
 469 |     |         lpWhitelist[_lp] = _isAuthorized;
 470 |     |     }
 471 |     | 
 472 |     |     /**
 473 |     |      * @notice Make bankroll permissionless for LPs or not
 474 |     |      *  Called by Admin
 475 |     |      *
 476 |     |      * @param _lpIs Toggle enum betwen OPEN and WHITELISTED
 477 |     |      *
 478 |     |      */
 479 |     |     function setPublic(DGDataTypes.LpIs _lpIs) external onlyRole(ADMIN) {
 480 |     |         // Toggle lpIs status
 481 |     |         lpIs = _lpIs;
 482 |     |     }
 483 |     | 
 484 |     |     /**
 485 |     |      * @notice Set the minimum LP amount for bankroll
 486 |     |      *  Called by Admin
 487 |     |      *
 488 |     |      * @param _amount Set tthe minimum lp amount
 489 |     |      *
 490 |     |      */
 491 |     |     function setMinimumLp(uint256 _amount) external onlyRole(ADMIN) {
 492 |     |         // set minimum lp
 493 |     |         minimumLp = _amount;
 494 |     |     }
 495 |     | 
 496 |     |     /**
 497 |     |      *
 498 |     |      * @notice allows admins to change the max risk amount
 499 |     |      *
 500 |     |      * @param _newAmount new amount in percentage that should be potentially risked per session
 501 |     |      *
 502 |     |      */
 503 |     |     function changeMaxRisk(uint256 _newAmount) external onlyRole(ADMIN) {
 504 |     |         // Check so that maxrisk doestn't exceed 100%
 505 |     |         if (_newAmount > DENOMINATOR) revert DGErrors.MAXRISK_TOO_HIGH();
 506 |     | 
 507 |     |         // Set new maxrisk
 508 |     |         maxRiskPercentage = _newAmount;
 509 |     |     }
 510 |     | 
 511 |     |     /**
 512 |     |      *
 513 |     |      * @notice allows admins to change the max risk amount
 514 |     |      *
 515 |     |      * @param _newAmount new amount in percentage that should be potentially risked per session
 516 |     |      *
 517 |     |      */
 518 |     |     function changeEscrowThreshold(uint256 _newAmount) external onlyRole(ADMIN) {
 519 |     |         // Check so that maxrisk doestn't exceed 100%
 520 |     |         if (_newAmount > DENOMINATOR) revert DGErrors.ESCROW_THRESHOLD_TOO_HIGH();
 521 |     | 
 522 |     |         // Set new maxrisk
 523 |     |         escrowTreshold = _newAmount;
 524 |     |     }
 525 |     | 
 526 |     |     /**
 527 |     |      * @notice Remove the GGR of a specified operator from the total GGR,
 528 |     |      *  then null out the operator GGR. Only callable by the bankroll manager
 529 |     |      *
 530 |     |      * @param _operator the address  of the operator we want to null out
 531 |     |      *
 532 |     |      */
 533 |     |     function nullGgrOf(address _operator) external onlyRole(BANKROLL_MANAGER) {
 534 |     |         // Subtract the GGR of the operator from the total GGR
 535 |     |         GGR -= ggrOf[_operator];
 536 |     | 
 537 |     |         // Null out operator GGR
 538 |     |         ggrOf[_operator] = 0;
 539 |     |     }
 540 |     | 
 541 |     |     /**
 542 |     |      *
 543 |     |      * @notice Max out the approval for the connected DeGaming contracts to spend on behalf of the bankroll contract
 544 |     |      *
 545 |     |      */
 546 |     |     function maxContractsApprove() external onlyRole(ADMIN) {
 547 |     |         token.forceApprove(
 548 |     |             address(dgBankrollManager), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
 549 |     |         );
 550 |     | 
 551 |     |         token.forceApprove(address(escrow), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
 552 |     |     }
 553 |     | 
 554 |     |     //   _    ___                 ______                 __  _
 555 |     |     //  | |  / (_)__ _      __   / ____/_  ______  _____/ /_(_)___  ____  _____
 556 |     |     //  | | / / / _ \ | /| / /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 557 |     |     //  | |/ / /  __/ |/ |/ /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 558 |     |     //  |___/_/\___/|__/|__/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 559 |     | 
 560 |     |     /**
 561 |     |      * @notice Returns the amount of ERC20 tokens held by the bankroll that are available for playes to win and
 562 |     |      *  will not include funds that are reserved for GGR
 563 |     |      *
 564 |     |      * @return _balance available balance for LPs
 565 |     |      *
 566 |     |      */
 567 | *   |     function liquidity() public view returns (uint256 _balance) {
 568 |     |         if (GGR <= 0) {
 569 |     |             _balance = token.balanceOf(address(this));
 570 |     |         } else if (GGR > 0) {
 571 |     |             _balance = token.balanceOf(address(this)) - uint256(GGR);
 572 |     |         }
 573 |     |     }
 574 |     | 
 575 |     |     /**
 576 |     |      * @notice Returns the current value of the LPs investment (deposit + profit).
 577 |     |      *
 578 |     |      * @param _lp Liquidity Provider address
 579 |     |      *
 580 |     |      * @return _amount the value of the lps holdings
 581 |     |      *
 582 |     |      */
 583 |     |     function getLpValue(address _lp) external view returns (uint256 _amount) {
 584 |     |         if (sharesOf[_lp] > 0) {
 585 |     |             _amount = (liquidity() * sharesOf[_lp]) / totalSupply;
 586 |     |         } else {
 587 |     |             _amount = 0;
 588 |     |         }
 589 |     |     }
 590 |     | 
 591 |     |     /**
 592 |     |      * @notice Returns the current stake of the LPs investment in percentage
 593 |     |      *
 594 |     |      * @param _lp Liquidity Provider address
 595 |     |      *
 596 |     |      * @return _stake the stake amount of given LP address
 597 |     |      *
 598 |     |      */
 599 |     |     function getLpStake(address _lp) external view returns (uint256 _stake) {
 600 |     |         if (sharesOf[_lp] > 0) {
 601 |     |             _stake = (sharesOf[_lp] * DENOMINATOR) / totalSupply;
 602 |     |         } else {
 603 |     |             _stake = 0;
 604 |     |         }
 605 |     |     }
 606 |     | 
 607 |     |     /**
 608 |     |      * @notice returns the maximum amount that can be taken from the bankroll during debit() call
 609 |     |      *
 610 |     |      * @return _maxRisk the maximum amount that can be risked
 611 |     |      *
 612 |     |      */
 613 |     |     function getMaxRisk() public view returns (uint256 _maxRisk) {
 614 |     |         _maxRisk = (liquidity() * maxRiskPercentage) / DENOMINATOR;
 615 |     |     }
 616 |     | 
 617 |     |     /**
 618 |     |      * @notice returns escrow threshold during the debit() call
 619 |     |      *
 620 |     |      * @return _threshold threshold before earnings gets sent to escrow
 621 |     |      *
 622 |     |      */
 623 |     |     function getEscrowThreshold() public view returns (uint256 _threshold) {
 624 |     |         _threshold = (liquidity() * escrowTreshold) / DENOMINATOR;
 625 |     |     }
 626 |     | 
 627 |     |     //     ____      __                        __   ______                 __  _
 628 |     |     //    /  _/___  / /____  _________  ____ _/ /  / ____/_  ______  _____/ /_(_)___  ____  _____
 629 |     |     //    / // __ \/ __/ _ \/ ___/ __ \/ __ `/ /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 630 |     |     //  _/ // / / / /_/  __/ /  / / / / /_/ / /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 631 |     |     // /___/_/ /_/\__/\___/_/  /_/ /_/\__,_/_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 632 |     | 
 633 |     |     /**
 634 |     |      * @notice Mint shares to the caller
 635 |     |      *
 636 |     |      * @param _to Minted shares recipient
 637 |     |      * @param _shares Amount of shares to mint
 638 |     |      *
 639 |     |      */
 640 |     |     function _mint(address _to, uint256 _shares) internal {
 641 |     |         // Increment the total supply
 642 |     |         totalSupply += _shares;
 643 |     | 
 644 |     |         // Increment the share balance of the recipient
 645 |     |         sharesOf[_to] += _shares;
 646 |     |     }
 647 |     | 
 648 |     |     /**
 649 |     |      * @notice Burn shares from the caller
 650 |     |      *
 651 |     |      * @param _from Burner address
 652 |     |      * @param _shares Amount of shares to burn
 653 |     |      *
 654 |     |      */
 655 |     |     function _burn(address _from, uint256 _shares) internal {
 656 |     |         // Subtract from the total supply
 657 |     |         totalSupply -= _shares;
 658 |     | 
 659 |     |         // Subtract the share balance of the target
 660 |     |         sharesOf[_from] -= _shares;
 661 |     |     }
 662 |     | 
 663 |     |     /**
 664 |     |      * @notice Withdraw shares from the bankroll
 665 |     |      *
 666 |     |      * @param _shares Amount of shares to burn
 667 |     |      *
 668 |     |      */
 669 |     |     function _withdraw(uint256 _shares, address _reciever) internal {
 670 |     |         // Calculate the amount of ERC20 worth of shares
 671 |     |         uint256 amount = (_shares * liquidity()) / totalSupply;
 672 |     | 
 673 |     |         // Burn the shares from the caller
 674 |     |         _burn(_reciever, _shares);
 675 |     | 
 676 |     |         // fetch balance before
 677 |     |         uint256 balanceBefore = token.balanceOf(address(this));
 678 |     | 
 679 |     |         // Transfer ERC20 to the caller
 680 |     |         token.safeTransfer(_reciever, amount);
 681 |     | 
 682 |     |         // fetch balance aftrer
 683 |     |         uint256 balanceAfter = token.balanceOf(address(this));
 684 |     | 
 685 |     |         // amount variable calculated from recieved balances
 686 |     |         uint256 realizedAmount = balanceBefore - balanceAfter;
 687 |     | 
 688 |     |         // Emit an event that funds are withdrawn
 689 |     |         emit DGEvents.FundsWithdrawn(_reciever, realizedAmount);
 690 |     |     }
 691 |     | 
 692 |     |     /**
 693 |     |      * @notice
 694 |     |      *  Allows contract to check if the Token address actually is a contract
 695 |     |      *
 696 |     |      * @param _address address we want to  check
 697 |     |      *
 698 |     |      * @return _isAddressContract returns true if token is a contract, otherwise returns false
 699 |     |      *
 700 |     |      */
 701 |     |     function _isContract(address _address) internal view returns (bool _isAddressContract) {
 702 |     |         uint256 size;
 703 |     | 
 704 |     |         assembly {
 705 |     |             size := extcodesize(_address)
 706 |     |         }
 707 |     | 
 708 |     |         _isAddressContract = size > 0;
 709 |     |     }
 710 |     | }
 711 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/DGBankrollFactory.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.19;
   3 |     | 
   4 |     | /* Openzeppelin Contract */
   5 |     | import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";
   6 |     | import {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
   7 |     | 
   8 |     | /* DeGaming Contract */
   9 |     | import {Bankroll} from "src/Bankroll.sol";
  10 |     | 
  11 |     | /* DeGaming Libraries */
  12 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @title  DGBankrollFactory
  16 |     |  * @author DeGaming Technical Team
  17 |     |  * @notice Contract responsible for deploying DeGaming Bankrolls
  18 |     |  *
  19 |     |  */
  20 |     | contract DGBankrollFactory is AccessControlUpgradeable {
  21 |     |     //     _____ __        __
  22 |     |     //    / ___// /_____ _/ /____  _____
  23 |     |     //    \__ \/ __/ __ `/ __/ _ \/ ___/
  24 |     |     //   ___/ / /_/ /_/ / /_/  __(__  )
  25 |     |     //  /____/\__/\__,_/\__/\___/____/
  26 |     | 
  27 |     |     /// @dev number of collection created by this factory
  28 |     |     uint256 public bankrollCount;
  29 |     | 
  30 |     |     /// @dev Array of all Bankrolls created by this factory
  31 |     |     address[] public bankrolls;
  32 |     | 
  33 |     |     /// @dev Standard DeGaming Bankroll contract implementation address
  34 |     |     address public bankrollImpl;
  35 |     | 
  36 |     |     /// @dev DeGaming Bankroll Manager Contract address
  37 |     |     address public dgBankrollManager;
  38 |     | 
  39 |     |     /// @dev DeGaming Escrow contract address
  40 |     |     address public escrow;
  41 |     | 
  42 |     |     /// @dev DeGaming admin account
  43 |     |     address public dgAdmin;
  44 |     | 
  45 |     |     /// @dev DeGaming address
  46 |     |     address public deGaming;
  47 |     | 
  48 |     |     /// @dev Storage gap used for future upgrades (30 * 32 bytes)
  49 |     |     uint256[30] __gap;
  50 |     | 
  51 |     |     //    ______                 __                  __
  52 |     |     //   / ____/___  ____  _____/ /________  _______/ /_____  _____
  53 |     |     //  / /   / __ \/ __ \/ ___/ __/ ___/ / / / ___/ __/ __ \/ ___/
  54 |     |     // / /___/ /_/ / / / (__  ) /_/ /  / /_/ / /__/ /_/ /_/ / /
  55 |     |     // \____/\____/_/ /_/____/\__/_/   \__,_/\___/\__/\____/_/
  56 |     | 
  57 |     |     /**
  58 |     |      * @notice
  59 |     |      *  Contract Constructor
  60 |     |      */
  61 |     |     /// @custom:oz-upgrades-unsafe-allow constructor
  62 |     |     constructor() {
  63 |     |         _disableInitializers();
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @notice
  68 |     |      *  Contract Initializer
  69 |     |      *
  70 |     |      * @param _bankrollImpl address of DeGaming implementation of Bankroll contract
  71 |     |      * @param _dgBankrollManager DeGaming bankroll manager  contract address
  72 |     |      * @param _dgAdmin DeGaming admin account
  73 |     |      * @param _deGaming DeGaming wallet
  74 |     |      *
  75 |     |      */
  76 |     |     function initialize(
  77 |     |         address _bankrollImpl,
  78 |     |         address _dgBankrollManager,
  79 |     |         address _escrow,
  80 |     |         address _dgAdmin,
  81 |     |         address _deGaming
  82 |     |     ) external initializer {
  83 |     |         // Initialize global variables
  84 |     |         bankrollImpl = _bankrollImpl;
  85 |     |         dgBankrollManager = _dgBankrollManager;
  86 |     |         escrow = _escrow;
  87 |     |         dgAdmin = _dgAdmin;
  88 |     |         deGaming = _deGaming;
  89 |     | 
  90 |     |         // initialize access controll
  91 |     |         __AccessControl_init();
  92 |     |         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @notice
  97 |     |      *  Deploy a new Bankroll instance
  98 |     |      *  Only the caller with role `DEFAULT_ADMIN_ROLE` can perform this operation
  99 |     |      *
 100 |     |      * @param _token address of token asociated with bankroll
 101 |     |      * @param _maxRiskPercentage max risk percentage in numbers (denominator 10_000 = 100)
 102 |     |      * @param _salt bytes used for deterministic deployment
 103 |     |      *
 104 |     |      */
 105 |     |     function deployBankroll(address _token, uint256 _maxRiskPercentage, uint256 _escrowThreshold, bytes32 _salt)
 106 |     |         external
 107 |     |         onlyRole(DEFAULT_ADMIN_ROLE)
 108 |     |     {
 109 |     |         // Make sure that token address is a contract
 110 |     |         if (!_isContract(_token)) revert DGErrors.ADDRESS_NOT_A_CONTRACT();
 111 |     | 
 112 |     |         // Make sure that maxrisk does not exceed 100%
 113 |     |         if (_maxRiskPercentage > 10_000) revert DGErrors.MAXRISK_TOO_HIGH();
 114 |     | 
 115 |     |         // Deploy new Bankroll contract
 116 |     |         Bankroll newBankroll = Bankroll(Clones.cloneDeterministic(bankrollImpl, _salt));
 117 |     | 
 118 |     |         // Initialize Bankroll contract
 119 |     |         newBankroll.initialize(
 120 |     |             dgAdmin, _token, dgBankrollManager, escrow, deGaming, _maxRiskPercentage, _escrowThreshold
 121 |     |         );
 122 |     | 
 123 |     |         // Add address to list of bankrolls
 124 |     |         bankrolls.push(address(newBankroll));
 125 |     | 
 126 |     |         // Increment bankroll counter
 127 |     |         ++bankrollCount;
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @notice
 132 |     |      *  Set Bankroll implementation address
 133 |     |      *  Only the caller with role `DEFAULT_ADMIN_ROLE` can perform this operation
 134 |     |      *
 135 |     |      * @param _newImpl address of the new implementation contract
 136 |     |      *
 137 |     |      */
 138 |     |     function setBankrollImplementation(address _newImpl) external onlyRole(DEFAULT_ADMIN_ROLE) {
 139 |     |         // Make sure that new bankroll implementation is a contract
 140 |     |         if (!_isContract(_newImpl)) revert DGErrors.ADDRESS_NOT_A_CONTRACT();
 141 |     | 
 142 |     |         // set new bankroll implementation
 143 |     |         bankrollImpl = _newImpl;
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @notice
 148 |     |      *  Set DeGaming Bankroll Manager contract address
 149 |     |      *  Only the caller with role `DEFAULT_ADMIN_ROLE` can perform this operation
 150 |     |      *
 151 |     |      * @param _dgBankrollManager Bankroll Manager Contract address
 152 |     |      *
 153 |     |      */
 154 |     |     function setDgBankrollManager(address _dgBankrollManager) external onlyRole(DEFAULT_ADMIN_ROLE) {
 155 |     |         // Make sure that new bankroll manager is a contract
 156 |     |         if (!_isContract(_dgBankrollManager)) revert DGErrors.ADDRESS_NOT_A_CONTRACT();
 157 |     | 
 158 |     |         // Set new bankroll manager
 159 |     |         dgBankrollManager = _dgBankrollManager;
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @notice
 164 |     |      *  Set DeGaming Escrow contract address
 165 |     |      *  Only the caller with role `DEFAULT_ADMIN_ROLE` can perform this operation
 166 |     |      *
 167 |     |      * @param _escrow Escrow Contract address
 168 |     |      *
 169 |     |      */
 170 |     |     function setDgEscrow(address _escrow) external onlyRole(DEFAULT_ADMIN_ROLE) {
 171 |     |         // Make sure that new escrow address is a contract
 172 |     |         if (!_isContract(_escrow)) revert DGErrors.ADDRESS_NOT_A_CONTRACT();
 173 |     | 
 174 |     |         // Set new escrow address
 175 |     |         escrow = _escrow;
 176 |     |     }
 177 |     | 
 178 |     |     /**
 179 |     |      * @notice
 180 |     |      *  Set DeGaming admin account
 181 |     |      *  Only the caller with role `DEFAULT_ADMIN_ROLE` can perform this operation
 182 |     |      *
 183 |     |      * @param _dgAdmin DeGaming admin account
 184 |     |      *
 185 |     |      */
 186 |     |     function setDgAdmin(address _dgAdmin) external onlyRole(DEFAULT_ADMIN_ROLE) {
 187 |     |         dgAdmin = _dgAdmin;
 188 |     |     }
 189 |     | 
 190 |     |     /**
 191 |     |      * @notice
 192 |     |      *  Set DeGaming wallet address
 193 |     |      *  Only the caller with role `DEFAULT_ADMIN_ROLE` can perform this operation
 194 |     |      *
 195 |     |      * @param _deGaming DeGaming wallet
 196 |     |      *
 197 |     |      */
 198 |     |     function setDeGaming(address _deGaming) external onlyRole(DEFAULT_ADMIN_ROLE) {
 199 |     |         deGaming = _deGaming;
 200 |     |     }
 201 |     | 
 202 |     |     //   _    ___                 ______                 __  _
 203 |     |     //  | |  / (_)__ _      __   / ____/_  ______  _____/ /_(_)___  ____  _____
 204 |     |     //  | | / / / _ \ | /| / /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 205 |     |     //  | |/ / /  __/ |/ |/ /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 206 |     |     //  |___/_/\___/|__/|__/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 207 |     | 
 208 |     |     /**
 209 |     |      * @notice
 210 |     |      *  Predict the new Bankroll contract address
 211 |     |      *
 212 |     |      * @param _salt salt used for the deterministic deployment
 213 |     |      *
 214 |     |      * @return _predicted predicted address for the given `_salt`
 215 |     |      *
 216 |     |      */
 217 |     |     function predictBankrollAddress(bytes32 _salt) external view returns (address _predicted) {
 218 |     |         _predicted = Clones.predictDeterministicAddress(bankrollImpl, _salt, address(this));
 219 |     |     }
 220 |     | 
 221 |     |     //     ____      __                        __   ______                 __  _
 222 |     |     //    /  _/___  / /____  _________  ____ _/ /  / ____/_  ______  _____/ /_(_)___  ____  _____
 223 |     |     //    / // __ \/ __/ _ \/ ___/ __ \/ __ `/ /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 224 |     |     //  _/ // / / / /_/  __/ /  / / / / /_/ / /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 225 |     |     // /___/_/ /_/\__/\___/_/  /_/ /_/\__,_/_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 226 |     | 
 227 |     |     /**
 228 |     |      * @notice
 229 |     |      *  Allows contract to check if the Token address actually is a contract
 230 |     |      *
 231 |     |      * @param _address address we want to  check
 232 |     |      *
 233 |     |      * @return _isAddressContract returns true if token is a contract, otherwise returns false
 234 |     |      *
 235 |     |      */
 236 |     |     function _isContract(address _address) internal view returns (bool _isAddressContract) {
 237 |     |         uint256 size;
 238 |     | 
 239 |     |         assembly {
 240 |     |             size := extcodesize(_address)
 241 |     |         }
 242 |     | 
 243 |     |         _isAddressContract = size > 0;
 244 |     |     }
 245 |     | }
 246 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/DGBankrollManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.19;
   3 |     | 
   4 |     | /* Openzeppelin Interfaces */
   5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   6 |     | 
   7 |     | /* Openzeppelin Contracts */
   8 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   9 |     | import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
  10 |     | 
  11 |     | /* DeGaming Contracts */
  12 |     | import {Bankroll} from "src/Bankroll.sol";
  13 |     | 
  14 |     | /* DeGaming Interfaces */
  15 |     | import {IBankroll} from "src/interfaces/IBankroll.sol";
  16 |     | import {IDGBankrollManager} from "src/interfaces/IDGBankrollManager.sol";
  17 |     | 
  18 |     | /* DeGaming Libraries */
  19 |     | import {DGEvents} from "src/libraries/DGEvents.sol";
  20 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
  21 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
  22 |     | 
  23 |     | /**
  24 |     |  * @title DGBankrollManager
  25 |     |  * @author DeGaming Technical Team
  26 |     |  * @notice Fee management of GGR
  27 |     |  *
  28 |     |  */
  29 | *   | contract DGBankrollManager is IDGBankrollManager, AccessControl {
  30 |     |     /// @dev Using SafeERC20 for safer token interaction
  31 |     |     using SafeERC20 for IERC20;
  32 |     | 
  33 |     |     /// @dev used to calculate percentages
  34 |     |     uint256 public constant DENOMINATOR = 10_000;
  35 |     | 
  36 |     |     /// @dev DeGaming Wallet
  37 |     |     address public deGaming;
  38 |     | 
  39 |     |     /// @dev ADMIN role
  40 |     |     bytes32 public constant ADMIN = keccak256("ADMIN");
  41 |     | 
  42 |     |     /// @dev Event period of specific bankroll
  43 |     |     mapping(address bankroll => uint256 eventPeriod) public eventPeriodOf;
  44 |     | 
  45 |     |     /// @dev store bankroll status
  46 |     |     mapping(address bankroll => bool isApproved) public bankrollStatus;
  47 |     | 
  48 |     |     /// @dev store bankroll lp fees in percentage
  49 |     |     mapping(address bankroll => uint256 lpFee) public lpFeeOf;
  50 |     | 
  51 |     |     /// @dev mapping that stores all operators associated with a bankroll
  52 |     |     mapping(address bankroll => address[] operator) public operatorsOf;
  53 |     | 
  54 |     |     /// @dev mapping that if operator is approved
  55 | *   |     mapping(address operator => bool approved) public isApproved;
  56 |     | 
  57 |     |     /// @dev Store time claimed + event period
  58 |     |     mapping(address claimer => uint256 timestamp) public eventPeriodEnds;
  59 |     | 
  60 |     |     /// @dev Store a boolean if an operator s associated with a bankroll
  61 | *   |     mapping(address bankroll => mapping(address operator => bool isAssociated)) public operatorOfBankroll;
  62 |     | 
  63 |     |     //     ______                 __                  __
  64 |     |     //    / ____/___  ____  _____/ /________  _______/ /_____  _____
  65 |     |     //   / /   / __ \/ __ \/ ___/ __/ ___/ / / / ___/ __/ __ \/ ___/
  66 |     |     //  / /___/ /_/ / / / (__  ) /_/ /  / /_/ / /__/ /_/ /_/ / /
  67 |     |     //  \____/\____/_/ /_/____/\__/_/   \__,_/\___/\__/\____/_/
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice DGBankrollManager constructor
  71 |     |      *   Just sets the deployer of this contract as the owner
  72 |     |      *
  73 |     |      */
  74 |     |     constructor(address _deGaming) {
  75 |     |         // Set DeGaming global variable
  76 |     |         deGaming = _deGaming;
  77 |     | 
  78 |     |         // Grant default admin role to deployer
  79 |     |         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
  80 |     | 
  81 |     |         // Grant Admin role to deployer
  82 |     |         _grantRole(ADMIN, msg.sender);
  83 |     |     }
  84 |     | 
  85 |     |     //     ____        __         ____                              ______                 __  _
  86 |     |     //    / __ \____  / /_  __   / __ \_      ______  ___  _____   / ____/_  ______  _____/ /_(_)___  ____  _____
  87 |     |     //   / / / / __ \/ / / / /  / / / / | /| / / __ \/ _ \/ ___/  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
  88 |     |     //  / /_/ / / / / / /_/ /  / /_/ /| |/ |/ / / / /  __/ /     / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
  89 |     |     //  \____/_/ /_/_/\__, /   \____/ |__/|__/_/ /_/\___/_/     /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
  90 |     |     //               /____/
  91 |     | 
  92 |     |     /**
  93 |     |      * @notice
  94 |     |      *  Approve a bankroll to use the DeGaming Bankroll Manager
  95 |     |      *  Only the admin role can execute this operation
  96 |     |      *
  97 |     |      * @param _bankroll bankroll contract address to be approved
  98 |     |      *
  99 |     |      */
 100 |     |     function approveBankroll(address _bankroll, uint256 _fee) external onlyRole(ADMIN) {
 101 |     |         // Check so that fee is withing range
 102 |     |         if (_fee > DENOMINATOR) revert DGErrors.TO_HIGH_FEE();
 103 |     | 
 104 |     |         // Make sure that bankroll is a contract
 105 |     |         if (!_isContract(_bankroll)) revert DGErrors.ADDRESS_NOT_A_CONTRACT();
 106 |     | 
 107 |     |         // Toggle bankroll status
 108 |     |         bankrollStatus[_bankroll] = true;
 109 |     | 
 110 |     |         // set LP fee
 111 |     |         lpFeeOf[_bankroll] = _fee;
 112 |     | 
 113 |     |         // set default eventPeriod
 114 |     |         eventPeriodOf[_bankroll] = 30 days;
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @notice
 119 |     |      *  Prevent a bankroll from using the DeGaming Bankroll Manager
 120 |     |      *  Only the admin role can execute this operation
 121 |     |      *
 122 |     |      * @param _bankroll bankroll contract address to be blocked
 123 |     |      *
 124 |     |      */
 125 |     |     function blockBankroll(address _bankroll) external onlyRole(ADMIN) {
 126 |     |         // Toggle bankroll status
 127 |     |         bankrollStatus[_bankroll] = false;
 128 |     | 
 129 |     |         // set lpFee to 0
 130 |     |         lpFeeOf[_bankroll] = 0;
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @notice
 135 |     |      *  Update existing bankrolls fee
 136 |     |      *
 137 |     |      * @param _bankroll bankroll contract address to be blocked
 138 |     |      * @param _newFee bankroll contract address to be blocked
 139 |     |      *
 140 |     |      */
 141 |     |     function updateLpFee(address _bankroll, uint256 _newFee) external onlyRole(ADMIN) {
 142 |     |         // Check that the bankroll is an approved DeGaming Bankroll
 143 |     |         if (!bankrollStatus[_bankroll]) revert DGErrors.BANKROLL_NOT_APPROVED();
 144 |     | 
 145 |     |         // Check so that fee is withing range
 146 |     |         if (_newFee > DENOMINATOR) revert DGErrors.TO_HIGH_FEE();
 147 |     | 
 148 |     |         // set new LP fee
 149 |     |         lpFeeOf[_bankroll] = _newFee;
 150 |     |     }
 151 |     | 
 152 |     |     /**
 153 |     |      * @notice
 154 |     |      *  Allows admins to update eventperiods for bankrolls
 155 |     |      *  Oly calleable by admin role
 156 |     |      *
 157 |     |      * @param _bankroll address of the desired bankroll we want to update event period for
 158 |     |      * @param _eventPeriod the new updated event period
 159 |     |      *
 160 |     |      */
 161 |     |     function updateEventPeriod(address _bankroll, uint256 _eventPeriod) external onlyRole(ADMIN) {
 162 |     |         // Check that the bankroll is an approved DeGaming Bankroll
 163 |     |         if (!bankrollStatus[_bankroll]) revert DGErrors.BANKROLL_NOT_APPROVED();
 164 |     | 
 165 |     |         // Set new eventperiod
 166 |     |         eventPeriodOf[_bankroll] = _eventPeriod;
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @notice
 171 |     |      *  Set new degaming address
 172 |     |      *  Only calleable by admin role
 173 |     |      *
 174 |     |      * @param _deGaming new degaming address
 175 |     |      *
 176 |     |      */
 177 |     |     function setDeGaming(address _deGaming) external onlyRole(ADMIN) {
 178 |     |         deGaming = _deGaming;
 179 |     |     }
 180 |     | 
 181 |     |     /**
 182 |     |      * @notice
 183 |     |      *  Adding operator to list of operators associated with a bankroll
 184 |     |      *  Only calleable by admin role
 185 |     |      *
 186 |     |      * @param _bankroll the bankroll contract address
 187 |     |      * @param _operator address of the operator we want to add to the list of associated operators
 188 |     |      *
 189 |     |      */
 190 |     |     function setOperatorToBankroll(address _bankroll, address _operator) external onlyRole(ADMIN) {
 191 |     |         // Check that the bankroll is an approved DeGaming Bankroll
 192 |     |         if (!bankrollStatus[_bankroll]) revert DGErrors.BANKROLL_NOT_APPROVED();
 193 |     | 
 194 |     |         // Check so that operator isnt added to bankroll already
 195 |     |         if (operatorOfBankroll[_bankroll][_operator]) revert DGErrors.OPERATOR_ALREADY_ADDED_TO_BANKROLL();
 196 |     | 
 197 |     |         // Make sure that operator address is a wallet
 198 |     |         if (_isContract(_operator)) revert DGErrors.ADDRESS_NOT_A_WALLET();
 199 |     | 
 200 |     |         // Add operator into array of associated operators to bankroll
 201 |     |         operatorsOf[_bankroll].push(_operator);
 202 |     | 
 203 |     |         // Set operator of bankroll status to true
 204 |     |         operatorOfBankroll[_bankroll][_operator] = true;
 205 |     | 
 206 |     |         // Approve operator
 207 |     |         isApproved[_operator] = true;
 208 |     |     }
 209 |     | 
 210 |     |     /**
 211 |     |      * @notice
 212 |     |      *  Remove operator from list of operators associated with a bankroll
 213 |     |      *  Only calleable by admin role
 214 |     |      *
 215 |     |      * @param _bankroll the bankroll contract address
 216 |     |      * @param _operator address of the operator we want to remove from the list of associated operators
 217 |     |      *
 218 |     |      */
 219 |     |     function removeOperatorFromBankroll(address _operator, address _bankroll) external onlyRole(ADMIN) {
 220 |     |         // Check that the bankroll is an approved DeGaming Bankroll
 221 |     |         if (!bankrollStatus[_bankroll]) revert DGErrors.BANKROLL_NOT_APPROVED();
 222 |     | 
 223 |     |         // Make sure that operator is associated with bankroll
 224 |     |         if (!operatorOfBankroll[_bankroll][_operator]) revert DGErrors.OPERATOR_NOT_ASSOCIATED_WITH_BANKROLL();
 225 |     | 
 226 |     |         // fetch operators of bankroll
 227 |     |         address[] memory operators = operatorsOf[_bankroll];
 228 |     | 
 229 |     |         // Initiate operator intex
 230 |     |         uint256 operatorIndex = 0;
 231 |     | 
 232 |     |         // Search what index the operator has in the list of bankroll operators
 233 |     |         for (uint256 i = 0; i < operators.length; i++) {
 234 |     |             if (operators[i] == _operator) {
 235 |     |                 operatorIndex = i;
 236 |     |                 break;
 237 |     |             }
 238 |     |         }
 239 |     | 
 240 |     |         // If operatorindex is the last one the switch around is not necessary
 241 |     |         if (operatorIndex != operators.length - 1) {
 242 |     |             // Replace the index of the operator with the last operator in the list
 243 |     |             operatorsOf[_bankroll][operatorIndex] = operatorsOf[_bankroll][operatorsOf[_bankroll].length - 1];
 244 |     |         }
 245 |     | 
 246 |     |         // Set operator of bankroll status to true
 247 |     |         operatorOfBankroll[_bankroll][_operator] = false;
 248 |     | 
 249 |     |         // Remove the last index in the list since this will now be a duplicate
 250 |     |         operatorsOf[_bankroll].pop();
 251 |     |     }
 252 |     | 
 253 |     |     /**
 254 |     |      * @notice
 255 |     |      *  Adding an operator to bankroll ecosystem
 256 |     |      *
 257 |     |      * @param _operator address of the operator
 258 |     |      *
 259 |     |      */
 260 |     |     function addOperator(address _operator) external onlyRole(ADMIN) {
 261 |     |         // Make sure that operator address is a wallet
 262 |     |         if (_isContract(_operator)) revert DGErrors.ADDRESS_NOT_A_WALLET();
 263 |     | 
 264 |     |         // Sett operators appoved status
 265 |     |         isApproved[_operator] = true;
 266 |     |     }
 267 |     | 
 268 |     |     /**
 269 |     |      * @notice
 270 |     |      *  Block an operator from all bankrolls
 271 |     |      *
 272 |     |      * @param _operator address of the operator we want to block
 273 |     |      *
 274 |     |      */
 275 |     |     function blockOperator(address _operator) external onlyRole(ADMIN) {
 276 |     |         // Remove operators approved status
 277 |     |         isApproved[_operator] = false;
 278 |     |     }
 279 |     | 
 280 |     |     //     ______     __                        __   ______                 __  _
 281 |     |     //    / ____/  __/ /____  _________  ____ _/ /  / ____/_  ______  _____/ /_(_)___  ____  _____
 282 |     |     //   / __/ | |/_/ __/ _ \/ ___/ __ \/ __ `/ /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 283 |     |     //  / /____>  </ /_/  __/ /  / / / / /_/ / /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 284 |     |     // /_____/_/|_|\__/\___/_/  /_/ /_/\__,_/_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 285 |     | 
 286 |     |     /**
 287 |     |      * @notice Claim profit from the bankroll
 288 |     |      *
 289 |     |      * @param _bankroll address of bankroll
 290 |     |      *
 291 |     |      */
 292 |     |     function claimProfit(address _bankroll) external onlyRole(ADMIN) {
 293 |     |         // Check that the bankroll is an approved DeGaming Bankroll
 294 |     |         if (!bankrollStatus[_bankroll]) revert DGErrors.BANKROLL_NOT_APPROVED();
 295 |     | 
 296 |     |         // Fetch list of operators we will claim from
 297 |     |         address[] memory operators = operatorsOf[_bankroll];
 298 |     | 
 299 |     |         // Setup bankroll instance
 300 |     |         IBankroll bankroll = IBankroll(_bankroll);
 301 |     | 
 302 |     |         // Set up a token instance
 303 |     |         IERC20 token = IERC20(address(bankroll.token()));
 304 |     | 
 305 |     |         // Set up GGR for desired bankroll
 306 |     |         int256 GGR = bankroll.GGR();
 307 |     | 
 308 |     |         // Check if Casino GGR is posetive
 309 |     |         if (GGR < 1) revert DGErrors.NOTHING_TO_CLAIM();
 310 |     | 
 311 |     |         // Update event period ends unix timestamp to the eventperiod of specified bankroll
 312 |     |         eventPeriodEnds[_bankroll] = block.timestamp + eventPeriodOf[_bankroll];
 313 |     | 
 314 |     |         // variable for amount per operator
 315 |     |         uint256 amount = 0;
 316 |     | 
 317 |     |         // variable for total amount
 318 |     |         uint256 totalAmount = 0;
 319 |     | 
 320 |     |         // Loop over the operator list and perform the claim process over each operator
 321 |     |         for (uint256 i = 0; i < operators.length; i++) {
 322 |     |             if (bankroll.ggrOf(operators[i]) > 0) {
 323 |     |                 // Amount to send
 324 |     |                 amount += uint256(bankroll.ggrOf(operators[i]))
 325 |     |                     - ((lpFeeOf[_bankroll] * uint256(bankroll.ggrOf(operators[i]))) / DENOMINATOR);
 326 |     | 
 327 |     |                 // Increment total amount
 328 |     |                 totalAmount += uint256(bankroll.ggrOf(operators[i]));
 329 |     | 
 330 |     |                 // Zero out the GGR
 331 |     |                 bankroll.nullGgrOf(operators[i]);
 332 |     |             }
 333 |     |         }
 334 |     | 
 335 |     |         // fetch balance before
 336 |     |         uint256 balanceBefore = token.balanceOf(address(this));
 337 |     | 
 338 |     |         // transfer the GGR to DeGaming
 339 |     |         token.safeTransferFrom(_bankroll, deGaming, amount);
 340 |     | 
 341 |     |         // fetch balance aftrer
 342 |     |         uint256 balanceAfter = token.balanceOf(address(this));
 343 |     | 
 344 |     |         // amount variable calculated from recieved balances
 345 |     |         uint256 realizedAmount = balanceAfter - balanceBefore;
 346 |     | 
 347 |     |         emit DGEvents.ProfitsClaimed(_bankroll, totalAmount, realizedAmount);
 348 |     |     }
 349 |     | 
 350 |     |     //     ____      __                        __   ______                 __  _
 351 |     |     //    /  _/___  / /____  _________  ____ _/ /  / ____/_  ______  _____/ /_(_)___  ____  _____
 352 |     |     //    / // __ \/ __/ _ \/ ___/ __ \/ __ `/ /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 353 |     |     //  _/ // / / / /_/  __/ /  / / / / /_/ / /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 354 |     |     // /___/_/ /_/\__/\___/_/  /_/ /_/\__,_/_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 355 |     | 
 356 |     |     /**
 357 |     |      * @notice
 358 |     |      *  Allows contract to check if the Token address actually is a contract
 359 |     |      *
 360 |     |      * @param _address address we want to  check
 361 |     |      *
 362 |     |      * @return _isAddressContract returns true if token is a contract, otherwise returns false
 363 |     |      *
 364 |     |      */
 365 |     |     function _isContract(address _address) internal view returns (bool _isAddressContract) {
 366 |     |         uint256 size;
 367 |     | 
 368 |     |         assembly {
 369 |     |             size := extcodesize(_address)
 370 |     |         }
 371 |     | 
 372 |     |         _isAddressContract = size > 0;
 373 |     |     }
 374 |     | }
 375 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/DGEscrow.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.19;
   3 |     | 
   4 |     | /* Openzeppelin Interfaces */
   5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   6 |     | 
   7 |     | /* Openzeppelin Contracts */
   8 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   9 |     | import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
  10 |     | import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
  11 |     | 
  12 |     | /* DeGaming Interfaces */
  13 |     | import {IDGBankrollManager} from "src/interfaces/IDGBankrollManager.sol";
  14 |     | import {IBankroll} from "src/interfaces/IBankroll.sol";
  15 |     | 
  16 |     | /* DeGaming Libraries */
  17 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
  18 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
  19 |     | import {DGEvents} from "src/libraries/DGEvents.sol";
  20 |     | 
  21 |     | /**
  22 |     |  * @title DGEscrow
  23 |     |  * @author DeGaming Technical Team
  24 |     |  * @notice Escrow Contract for DeGaming's Bankroll poducts
  25 |     |  *
  26 |     |  */
  27 |     | contract DGEscrow is AccessControl, ReentrancyGuard {
  28 |     |     /// @dev Using SafeERC20 for safer token interaction
  29 |     |     using SafeERC20 for IERC20;
  30 |     | 
  31 |     |     /// @dev max time funds can be escrowed
  32 |     |     uint256 eventPeriod;
  33 |     | 
  34 |     |     /// @dev ADMIN role
  35 |     |     bytes32 public constant ADMIN = keccak256("ADMIN");
  36 |     | 
  37 |     |     /// @dev Mapping for holding the escrow info, acts as a source of truth
  38 |     |     mapping(bytes id => uint256 winnings) public escrowed;
  39 |     | 
  40 |     |     /// @dev Bankroll manager instance
  41 |     |     IDGBankrollManager public dgBankrollManager;
  42 |     | 
  43 |     |     //     ______                 __                  __
  44 |     |     //    / ____/___  ____  _____/ /________  _______/ /_____  _____
  45 |     |     //   / /   / __ \/ __ \/ ___/ __/ ___/ / / / ___/ __/ __ \/ ___/
  46 |     |     //  / /___/ /_/ / / / (__  ) /_/ /  / /_/ / /__/ /_/ /_/ / /
  47 |     |     //  \____/\____/_/ /_/____/\__/_/   \__,_/\___/\__/\____/_/
  48 |     | 
  49 |     |     /**
  50 |     |      * @param _eventPeriod event period in seconds
  51 |     |      * @param _bankrollManager address of bankrollmanager
  52 |     |      *
  53 |     |      */
  54 |     |     constructor(uint256 _eventPeriod, address _bankrollManager) {
  55 |     |         // Set event period
  56 |     |         eventPeriod = _eventPeriod;
  57 |     | 
  58 |     |         // Make sure that bankroll manager address actully is a contract
  59 |     |         if (!_isContract(_bankrollManager)) revert DGErrors.ADDRESS_NOT_A_CONTRACT();
  60 |     | 
  61 |     |         // Setup bankroll manager instance
  62 |     |         dgBankrollManager = IDGBankrollManager(_bankrollManager);
  63 |     | 
  64 |     |         // Granting DEFAULT_ADMIN_ROLE to the deoployer
  65 |     |         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
  66 |     | 
  67 |     |         // Granting ADMIN to the deoployer
  68 |     |         _grantRole(ADMIN, msg.sender);
  69 |     |     }
  70 |     | 
  71 |     |     //      ______     __                        __   ______                 __  _
  72 |     |     //     / ____/  __/ /____  _________  ____ _/ /  / ____/_  ______  _____/ /_(_)___  ____  _____
  73 |     |     //    / __/ | |/_/ __/ _ \/ ___/ __ \/ __ `/ /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
  74 |     |     //   / /____>  </ /_/  __/ /  / / / / /_/ / /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
  75 |     |     //  /_____/_/|_|\__/\___/_/  /_/ /_/\__,_/_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
  76 |     | 
  77 |     |     /**
  78 |     |      * @notice
  79 |     |      *  Function called by the bankroll to send funds to the escrow
  80 |     |      *
  81 |     |      * @param _player address of the player
  82 |     |      * @param _operator address of the operator
  83 |     |      * @param _token address of the token
  84 |     |      * @param _winnings amount of tokens sent to escrow
  85 |     |      *
  86 |     |      */
  87 |     |     function depositFunds(address _player, address _operator, address _token, uint256 _winnings) external {
  88 |     |         // Make sure that bankroll is an approved bankroll of DeGaming
  89 |     |         if (!dgBankrollManager.bankrollStatus(msg.sender)) revert DGErrors.BANKROLL_NOT_APPROVED();
  90 |     | 
  91 |     |         // Create escrow entry
  92 |     |         DGDataTypes.EscrowEntry memory entry =
  93 |     |             DGDataTypes.EscrowEntry(msg.sender, _operator, _player, _token, block.timestamp);
  94 |     | 
  95 |     |         // Encode entry into bytes to use for id of escrow
  96 |     |         bytes memory id = abi.encode(entry);
  97 |     | 
  98 |     |         // Set up token intance
  99 |     |         IERC20 token = IERC20(_token);
 100 |     | 
 101 |     |         // Fetch token balance before funds are getting escrowed
 102 |     |         uint256 balanceBefore = token.balanceOf(address(this));
 103 |     | 
 104 |     |         // Transfer funds into escrow
 105 |     |         token.safeTransferFrom(msg.sender, address(this), _winnings);
 106 |     | 
 107 |     |         // Fetch token balance after funds have been escrowed
 108 |     |         uint256 balanceAfter = token.balanceOf(address(this));
 109 |     | 
 110 |     |         // Create the realized winnings from the diff between the two
 111 |     |         uint256 winnings = balanceAfter - balanceBefore;
 112 |     | 
 113 |     |         // Set mapping for how much is held for specific id
 114 |     |         escrowed[id] = winnings;
 115 |     | 
 116 |     |         // Emit Winnings Escrowed event
 117 |     |         emit DGEvents.WinningsEscrowed(msg.sender, _operator, _player, _token, id);
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @notice
 122 |     |      *  Allows DeGaming to release escrowed funds to the player wallet
 123 |     |      *
 124 |     |      * @param _id id in bytes format
 125 |     |      *
 126 |     |      */
 127 |     |     function releaseFunds(bytes memory _id) external onlyRole(ADMIN) {
 128 |     |         // Check so that there are funds to claim for id
 129 |     |         if (escrowed[_id] == 0) revert DGErrors.NOTHING_TO_CLAIM();
 130 |     | 
 131 |     |         // Decode id into an entry
 132 |     |         DGDataTypes.EscrowEntry memory entry = _decode(_id);
 133 |     | 
 134 |     |         // Setup token instance
 135 |     |         IERC20 token = IERC20(entry.token);
 136 |     | 
 137 |     |         // Fetch balance before releasing the funds
 138 |     |         uint256 balanceBefore = token.balanceOf(address(this));
 139 |     | 
 140 |     |         // Send the escrowed funds to the player
 141 |     |         token.safeTransfer(entry.player, escrowed[_id]);
 142 |     | 
 143 |     |         // Fetch balance after the funds are released
 144 |     |         uint256 balanceAfter = token.balanceOf(address(this));
 145 |     | 
 146 |     |         // Setting the amount from the diff between the two
 147 |     |         uint256 amount = balanceBefore - balanceAfter;
 148 |     | 
 149 |     |         // Subtract the amount fetched from the escrowed mapping, probably nulling it out
 150 |     |         escrowed[_id] -= amount;
 151 |     | 
 152 |     |         // Emit event stating that the escrow is payed out
 153 |     |         emit DGEvents.EscrowPayed(msg.sender, _id, amount);
 154 |     |     }
 155 |     | 
 156 |     |     /**
 157 |     |      * @notice
 158 |     |      *  Allows DeGaming to revert escrowed funds back into the bankroll in case of fraud
 159 |     |      *
 160 |     |      * @param _id id in bytes format
 161 |     |      *
 162 |     |      */
 163 |     |     function revertFunds(bytes memory _id) external onlyRole(ADMIN) {
 164 |     |         // Check so that there are funds to claim for id
 165 |     |         if (escrowed[_id] == 0) revert DGErrors.NOTHING_TO_CLAIM();
 166 |     | 
 167 |     |         // Decode id into an entry
 168 |     |         DGDataTypes.EscrowEntry memory entry = _decode(_id);
 169 |     | 
 170 |     |         // Setup token instance
 171 |     |         IERC20 token = IERC20(entry.token);
 172 |     | 
 173 |     |         // Fetch balance before reverting the funds back to the bankroll
 174 |     |         uint256 balanceBefore = token.balanceOf(address(this));
 175 |     | 
 176 |     |         // Approve spending for bankroll to spend on behalf of escrow contract
 177 |     |         if (token.approve(entry.bankroll, escrowed[_id])) {
 178 |     |             // Send the escrowed funds back to the bankroll
 179 |     |             IBankroll(entry.bankroll).credit(escrowed[_id], entry.operator);
 180 |     | 
 181 |     |             // Fetch balance after the funds have been reverted
 182 |     |             uint256 balanceAfter = token.balanceOf(address(this));
 183 |     | 
 184 |     |             // Setting the amount from the diff between the two
 185 |     |             uint256 amount = balanceBefore - balanceAfter;
 186 |     | 
 187 |     |             // Subtract the amount fetched from the escrowed mapping, probably nulling it out
 188 |     |             escrowed[_id] -= amount;
 189 |     | 
 190 |     |             // Emit event that escrow is reverted back into the bankroll
 191 |     |             emit DGEvents.EscrowReverted(entry.bankroll, _id, amount);
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @notice
 197 |     |      *  Allows players to claim their escrowed amount after a certain period has passed
 198 |     |      *  id escrow is left unaddressed by DeGaming
 199 |     |      *
 200 |     |      * @param _id id in bytes format
 201 |     |      *
 202 |     |      */
 203 |     |     function claimUnaddressed(bytes memory _id) external nonReentrant {
 204 |     |         // Check so that there are funds to claim for id
 205 |     |         if (escrowed[_id] == 0) revert DGErrors.NOTHING_TO_CLAIM();
 206 |     | 
 207 |     |         // Decode id into an entry
 208 |     |         DGDataTypes.EscrowEntry memory entry = _decode(_id);
 209 |     | 
 210 |     |         // Make sure that the event period is actually passed
 211 |     |         if (block.timestamp < entry.timestamp + eventPeriod) revert DGErrors.EVENT_PERIOD_NOT_PASSED();
 212 |     | 
 213 |     |         // Check so that msg.sender is the player of the entry
 214 |     |         if (msg.sender != entry.player) revert DGErrors.UNAUTHORIZED_CLAIM();
 215 |     | 
 216 |     |         // Send the escrowed funds back to the bankroll
 217 |     |         IERC20 token = IERC20(entry.token);
 218 |     | 
 219 |     |         // Fetch balance before releasing the funds
 220 |     |         uint256 balanceBefore = token.balanceOf(address(this));
 221 |     | 
 222 |     |         // Send the escrowed funds to the player
 223 |     |         token.safeTransfer(entry.player, escrowed[_id]);
 224 |     | 
 225 |     |         // Fetch balance after the funds are released
 226 |     |         uint256 balanceAfter = token.balanceOf(address(this));
 227 |     | 
 228 |     |         // Setting the amount from the diff between the two
 229 |     |         uint256 amount = balanceBefore - balanceAfter;
 230 |     | 
 231 |     |         // Subtract the amount fetched from the escrowed mapping, probably nulling it out
 232 |     |         escrowed[_id] -= amount;
 233 |     | 
 234 |     |         // Emit event stating that the escrow is payed out
 235 |     |         emit DGEvents.EscrowPayed(msg.sender, _id, amount);
 236 |     |     }
 237 |     | 
 238 |     |     /**
 239 |     |      * @notice
 240 |     |      *  Allows admin to update bankroll manager contract
 241 |     |      *
 242 |     |      * @param _newBankrollManager address of the new bankroll manager
 243 |     |      *
 244 |     |      */
 245 |     |     function updateBankrollManager(address _newBankrollManager) external onlyRole(ADMIN) {
 246 |     |         // Make sure that the new bankroll manager is a contract
 247 |     |         if (!_isContract(_newBankrollManager)) revert DGErrors.ADDRESS_NOT_A_CONTRACT();
 248 |     | 
 249 |     |         // set the new bankroll manager
 250 |     |         dgBankrollManager = IDGBankrollManager(_newBankrollManager);
 251 |     |     }
 252 |     | 
 253 |     |     /**
 254 |     |      * @notice
 255 |     |      *  Allows admin to set new event period time
 256 |     |      *
 257 |     |      * @param _newEventPeriod New event period time in seconds
 258 |     |      *
 259 |     |      */
 260 |     |     function setEventPeriod(uint256 _newEventPeriod) external onlyRole(ADMIN) {
 261 |     |         eventPeriod = _newEventPeriod;
 262 |     |     }
 263 |     | 
 264 |     |     //     ____      __                        __   ______                 __  _
 265 |     |     //    /  _/___  / /____  _________  ____ _/ /  / ____/_  ______  _____/ /_(_)___  ____  _____
 266 |     |     //    / // __ \/ __/ _ \/ ___/ __ \/ __ `/ /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 267 |     |     //  _/ // / / / /_/  __/ /  / / / / /_/ / /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 268 |     |     // /___/_/ /_/\__/\___/_/  /_/ /_/\__,_/_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 269 |     | 
 270 |     |     /**
 271 |     |      * @notice
 272 |     |      *  Decoding IDs into valid entry custom data type
 273 |     |      *
 274 |     |      * @param _id id in bytes format
 275 |     |      *
 276 |     |      * @return _entry custom dataType return which holds all escrow information
 277 |     |      *
 278 |     |      */
 279 |     |     function _decode(bytes memory _id) internal pure returns (DGDataTypes.EscrowEntry memory _entry) {
 280 |     |         _entry = abi.decode(_id, (DGDataTypes.EscrowEntry));
 281 |     |     }
 282 |     | 
 283 |     |     /**
 284 |     |      * @notice
 285 |     |      *  Allows contract to check if the Token address actually is a contract
 286 |     |      *
 287 |     |      * @param _address address we want to  check
 288 |     |      *
 289 |     |      * @return _isAddressContract returns true if token is a contract, otherwise returns false
 290 |     |      *
 291 |     |      */
 292 |     |     function _isContract(address _address) internal view returns (bool _isAddressContract) {
 293 |     |         uint256 size;
 294 |     | 
 295 |     |         assembly {
 296 |     |             size := extcodesize(_address)
 297 |     |         }
 298 |     | 
 299 |     |         _isAddressContract = size > 0;
 300 |     |     }
 301 |     | }
 302 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/echidna/BeforeAfter.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Setup} from "./Setup.sol";
  5 |     | 
  6 |     | abstract contract BeforeAfter is Setup {
  7 |     |     struct Vars {
  8 |     |         // User variables
  9 |     |         uint256 userBalanceToken;
 10 |     |         uint256 userBalanceShares;
 11 |     |         // Bankroll variables
 12 |     |         uint256 totalSupply;
 13 |     |         int256 ggr;
 14 |     |     }
 15 |     | 
 16 |     |     Vars _before;
 17 |     |     Vars _after;
 18 |     | 
 19 | *   |     function __before(address user) internal {
 20 |     |         // User variables
 21 | *   |         _before.userBalanceToken = mockToken.balanceOf(user);
 22 | *   |         _before.userBalanceShares = bankroll.sharesOf(user);
 23 |     |         // Bankroll variables
 24 | *   |         _before.totalSupply = bankroll.totalSupply();
 25 | *   |         _before.ggr = bankroll.GGR();
 26 |     |     }
 27 |     | 
 28 | *   |     function __after(address user) internal {
 29 |     |         // User variables
 30 | *   |         _after.userBalanceToken = mockToken.balanceOf(user);
 31 | *   |         _after.userBalanceShares = bankroll.sharesOf(user);
 32 |     |         // Bankroll variables
 33 | *   |         _after.totalSupply = bankroll.totalSupply();
 34 | *   |         _after.ggr = bankroll.GGR();
 35 |     |     }
 36 |     | }
 37 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/echidna/Properties.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Setup} from "./Setup.sol";
  5 |     | import {PropertiesAsserts} from "../../lib/properties/contracts/util/PropertiesHelper.sol";
  6 |     | 
  7 |     | abstract contract Properties is Setup, PropertiesAsserts {
  8 | *   |     function invariant_liquidityGteShares(uint256 sharesToTokens) internal view returns (bool) {
  9 | *   |         uint256 liquidity = bankroll.liquidity();
 10 |     |         // uint256 shares = sumOfShares;
 11 |     | 
 12 | *   |         return liquidity >= sharesToTokens;
 13 |     |     }
 14 |     | 
 15 | *   |     function invariant_balanceGteGGR() internal view returns (bool) {
 16 | *   |         uint256 balance = mockToken.balanceOf(address(bankroll));
 17 | *   |         int256 ggr = bankroll.GGR();
 18 |     | 
 19 | *   |         return balance >= uint256(ggr);
 20 |     |     }
 21 |     | 
 22 | *   |     function invariant_ggrEqualSumGgrOf() internal view returns (bool) {
 23 | *   |         int256 ggr = bankroll.GGR();
 24 |     | 
 25 | *   |         return ggr == sumOfGgr;
 26 |     |     }
 27 |     | 
 28 |     |     function invariant004() internal view returns (bool) {}
 29 |     | 
 30 |     |     function invariant005() internal returns (bool) {}
 31 |     | 
 32 |     |     function invariant006() internal view returns (bool) {}
 33 |     | 
 34 | *   |     function _checkDepositProperties(
 35 |     |         uint256 deposit,
 36 |     |         uint256 shares,
 37 |     |         uint256 sharesOfBefore,
 38 |     |         uint256 sharesOfAfter,
 39 |     |         uint256 totalSupplyBefore,
 40 |     |         uint256 totalSupplyAfter
 41 |     |     ) internal {
 42 | *   |         assertWithMsg(sharesOfAfter == sharesOfBefore + shares, "DP-1");
 43 | *   |         assertWithMsg(totalSupplyAfter == totalSupplyBefore + shares, "DP-2");
 44 | *   |         if (deposit > 0) assertWithMsg(shares > 0, "DP-3");
 45 | *   |         if (deposit == 0) assertWithMsg(shares == 0, "DP-4");
 46 |     |     }
 47 |     | 
 48 | *   |     function _checkWithdrawProperties(
 49 |     |         uint256 shares,
 50 |     |         uint256 tokens,
 51 |     |         uint256 balanceBefore,
 52 |     |         uint256 balanceAfter,
 53 |     |         uint256 totalSupplyBefore,
 54 |     |         uint256 totalSupplyAfter
 55 |     |     ) internal {
 56 | *   |         assertWithMsg(balanceAfter == balanceBefore + tokens, "WP-1");
 57 | *   |         assertWithMsg(totalSupplyAfter == totalSupplyBefore - shares, "WP-2");
 58 | *   |         if (shares > 0) assertWithMsg(tokens > 0, "WP-3");
 59 | *   |         if (shares == 0) assertWithMsg(tokens == 0, "WP-4");
 60 |     |     }
 61 |     | }
 62 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/echidna/Setup.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity 0.8.19;
   3 |     | 
   4 |     | import "../../lib/properties/contracts/util/Hevm.sol";
   5 |     | 
   6 |     | /* OpenZeppelin contract */
   7 |     | import {TransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
   8 |     | import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
   9 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  10 |     | import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
  11 |     | 
  12 |     | /* DeGaming Contracts */
  13 |     | import {Bankroll} from "src/Bankroll.sol";
  14 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  15 |     | import {DGBankrollFactory} from "src/DGBankrollFactory.sol";
  16 |     | import {DGEscrow} from "src/DGEscrow.sol";
  17 |     | 
  18 |     | /* DeGaming Libraries */
  19 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
  20 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
  21 |     | import {DGEvents} from "src/libraries/DGEvents.sol";
  22 |     | 
  23 |     | /* Mock Contracts */
  24 |     | import {MockToken} from "test/mock/MockToken.sol";
  25 |     | 
  26 |     | abstract contract Setup {
  27 |     |     uint256 sumOfShares;
  28 |     |     int256 sumOfGgr;
  29 |     | 
  30 |     |     MockToken mockToken;
  31 |     |     DGBankrollManager dgBankrollManager;
  32 |     |     DGEscrow dgEscrow;
  33 |     |     Bankroll bankroll;
  34 |     |     DGBankrollFactory dgBankrollFactory;
  35 |     |     TransparentUpgradeableProxy bankrollProxy;
  36 |     | 
  37 |     |     ProxyAdmin proxyAdmin;
  38 |     | 
  39 |     |     address admin;
  40 |     |     address deGaming;
  41 |     |     address operator;
  42 |     |     address player;
  43 |     | 
  44 |     |     address[] operators;
  45 |     |     address[] lps;
  46 |     | 
  47 |     |     uint256 maxRisk = 10_000;
  48 |     |     uint256 threshold = 10_000;
  49 |     | 
  50 |     |     function setup() internal {
  51 |     |         admin = address(0x11);
  52 |     |         deGaming = address(0x22);
  53 |     |         operator = address(0x33);
  54 |     |         player = address(0x44);
  55 |     | 
  56 |     |         mockToken = new MockToken("Mock USDC", "mUSDC");
  57 |     | 
  58 |     |         dgBankrollFactory = new DGBankrollFactory();
  59 |     | 
  60 |     |         dgBankrollManager = new DGBankrollManager(deGaming);
  61 |     | 
  62 |     |         dgEscrow = new DGEscrow(1 weeks, address(dgBankrollManager));
  63 |     | 
  64 |     |         proxyAdmin = new ProxyAdmin();
  65 |     | 
  66 |     |         bankrollProxy = new TransparentUpgradeableProxy(
  67 |     |             address(new Bankroll()),
  68 |     |             address(proxyAdmin),
  69 |     |             abi.encodeWithSelector(
  70 |     |                 Bankroll.initialize.selector,
  71 |     |                 admin,
  72 |     |                 address(mockToken),
  73 |     |                 address(dgBankrollManager),
  74 |     |                 address(dgEscrow),
  75 |     |                 msg.sender,
  76 |     |                 maxRisk,
  77 |     |                 threshold
  78 |     |             )
  79 |     |         );
  80 |     | 
  81 |     |         bankroll = Bankroll(address(bankrollProxy));
  82 |     | 
  83 |     |         dgBankrollManager.grantRole(keccak256("ADMIN"), address(dgBankrollFactory));
  84 |     | 
  85 |     |         dgBankrollManager.grantRole(keccak256("ADMIN"), admin);
  86 |     | 
  87 |     |         dgBankrollManager.approveBankroll(address(bankroll), 650);
  88 |     | 
  89 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), operator);
  90 |     |     }
  91 |     | 
  92 | *   |     function _initMint(address user, uint256 amount) internal {
  93 | *   |         mockToken.mint(user, amount);
  94 |     |     }
  95 |     | 
  96 | *   |     function _getSharesToAmount(uint256 _shares) internal view returns (uint256 amount) {
  97 | *   |         if (bankroll.liquidity() == 0) {
  98 |     |             amount = _shares;
  99 |     |         } else {
 100 | *   |             amount = (_shares * bankroll.liquidity()) / bankroll.totalSupply();
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 | *   |     function _getAmountToShares(uint256 _amount) internal view returns (uint256 shares) {
 105 | *   |         if (bankroll.liquidity() == 0) {
 106 | *   |             shares = _amount;
 107 |     |         } else {
 108 | *   |             shares = (_amount * bankroll.totalSupply()) / bankroll.liquidity();
 109 |     |         }
 110 |     |     }
 111 |     | }
 112 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/echidna/TargetFunctions.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity 0.8.19;
   3 |     | 
   4 |     | import {BeforeAfter} from "./BeforeAfter.sol";
   5 |     | import {Properties} from "./Properties.sol";
   6 |     | import "../../lib/properties/contracts/util/Hevm.sol";
   7 |     | import {Setup} from "./Setup.sol";
   8 |     | 
   9 |     | abstract contract TargetFunctions is Setup, Properties, BeforeAfter {
  10 | *   |     function testDepositFunds(uint256 amount) public {
  11 | *   |         amount = clampBetween(amount, 0, 100000e6);
  12 | *   |         _initMint(msg.sender, amount);
  13 | *   |         __before(msg.sender);
  14 |     | 
  15 | *   |         uint256 shares = _getAmountToShares(amount);
  16 | *   |         hevm.prank(msg.sender);
  17 | *   |         mockToken.approve(address(bankroll), amount);
  18 |     | 
  19 | *   |         hevm.prank(msg.sender);
  20 | *   |         try bankroll.depositFunds(amount) {
  21 | *   |             __after(msg.sender);
  22 | *   |             sumOfShares += shares;
  23 | *   |             uint256 sumOfTokens = _getSharesToAmount(sumOfShares);
  24 | *   |             assertWithMsg(invariant_liquidityGteShares(sumOfTokens), "BKR1 | Liquidity Gte Shares");
  25 | *   |             assertWithMsg(invariant_balanceGteGGR(), "BKR2 | Balance Gte GGR");
  26 | *   |             _checkDepositProperties(
  27 | *   |                 amount,
  28 | *   |                 shares,
  29 | *   |                 _before.userBalanceShares,
  30 | *   |                 _after.userBalanceShares,
  31 | *   |                 _before.totalSupply,
  32 | *   |                 _after.totalSupply
  33 |     |             );
  34 |     |         } catch {
  35 | *   |             assert(false);
  36 |     |         }
  37 |     |     }
  38 |     | 
  39 | *   |     function testWithdrawalStages(uint256 _amount) public {
  40 | *   |         if (bankroll.sharesOf(msg.sender) == 0) {
  41 |     |             return;
  42 |     |         }
  43 | *   |         uint256 balanceOfShares = bankroll.sharesOf(msg.sender);
  44 | *   |         uint256 amount = clampBetween(_amount, 1, balanceOfShares);
  45 |     |         // emit LogUint256("Amount: ", amount);
  46 | *   |         __before(msg.sender);
  47 |     | 
  48 | *   |         hevm.prank(msg.sender);
  49 | *   |         try bankroll.withdrawalStageOne(amount) {
  50 | *   |             __after(msg.sender);
  51 |     |         } catch {
  52 |     |             assert(false);
  53 |     |         }
  54 | *   |         uint256 _shares = _getAmountToShares(amount);
  55 | *   |         hevm.warp(block.timestamp + 3 minutes);
  56 | *   |         hevm.prank(msg.sender);
  57 | *   |         try bankroll.withdrawalStageTwo() {
  58 | *   |             __after(msg.sender);
  59 | *   |             sumOfShares -= _shares;
  60 | *   |             uint256 sumOfTokens = _getSharesToAmount(sumOfShares);
  61 | *   |             hevm.warp(block.timestamp + 1 hours);
  62 | *   |             assertWithMsg(invariant_liquidityGteShares(sumOfTokens), "BKR1 | Liquidity Gte Shares");
  63 | *   |             assertWithMsg(invariant_balanceGteGGR(), "BKR2 | Balance Gte GGR");
  64 | *   |             _checkWithdrawProperties(
  65 | *   |                 _shares,
  66 | *   |                 amount,
  67 | *   |                 _before.userBalanceToken,
  68 | *   |                 _after.userBalanceToken,
  69 | *   |                 _before.totalSupply,
  70 | *   |                 _after.totalSupply
  71 |     |             );
  72 |     |         } catch {
  73 |     |             assert(false);
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 | *   |     function testCredit(uint256 _amount) public {
  78 | *   |         _amount = clampBetween(_amount, 1, 100000e6);
  79 | *   |         __before(address(bankroll));
  80 |     | 
  81 | *   |         if (mockToken.balanceOf(admin) < _amount) {
  82 | *   |             _initMint(admin, _amount);
  83 |     |         }
  84 | *   |         hevm.prank(admin);
  85 | *   |         mockToken.approve(address(bankroll), _amount);
  86 |     | 
  87 | *   |         hevm.prank(admin);
  88 | *   |         try bankroll.credit(_amount, operator) {
  89 | *   |             __after(address(bankroll));
  90 | *   |             sumOfGgr += int256(_amount);
  91 | *   |             assertWithMsg(invariant_ggrEqualSumGgrOf(), "BKR3 | GGR Equal Sum GGR Of");
  92 |     |         } catch {
  93 | *   |             assert(false);
  94 |     |         }
  95 |     |     }
  96 |     | 
  97 |     |     // function testDebit(uint256 _amount) public {
  98 |     |     //     _amount = clampBetween(_amount, 1, 100000e6);
  99 |     |     //     __before(player);
 100 |     | 
 101 |     |     //     hevm.prank(admin);
 102 |     |     //     try bankroll.debit(player, _amount, operator) {
 103 |     |     //         __after(player);
 104 |     |     //         sumOfGgr -= int256(_amount);
 105 |     |     //         assertWithMsg(invariant_ggrEqualSumGgrOf(), "BKR3 | GGR Equal Sum GGR Of");
 106 |     |     //     } catch {
 107 |     |     //         assert(false);
 108 |     |     //     }
 109 |     |     // }
 110 |     | }
 111 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/echidna/Tester.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {Setup} from "./Setup.sol";
  5 |     | import {TargetFunctions} from "./TargetFunctions.sol";
  6 |     | 
  7 | *r  | contract Tester is Setup, TargetFunctions {
  8 |     |     constructor() {
  9 |     |         setup();
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/interfaces/IBankroll.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.19;
   3 |     | 
   4 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
   5 |     | import {IERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title IBankroll V2
   9 |     |  * @author DeGaming Technical Team
  10 |     |  * @notice Interface for Bankroll contract
  11 |     |  *
  12 |     |  */
  13 |     | interface IBankroll { 
  14 |     |     //      ______     __                        __   ______                 __  _
  15 |     |     //     / ____/  __/ /____  _________  ____ _/ /  / ____/_  ______  _____/ /_(_)___  ____  _____
  16 |     |     //    / __/ | |/_/ __/ _ \/ ___/ __ \/ __ `/ /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
  17 |     |     //   / /____>  </ /_/  __/ /  / / / / /_/ / /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
  18 |     |     //  /_____/_/|_|\__/\___/_/  /_/ /_/\__,_/_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
  19 |     | 
  20 |     |     /**
  21 |     |      * @notice Deposit ERC20 tokens to the bankroll
  22 |     |      *  Called by Liquidity Providers
  23 |     |      *
  24 |     |      * @param _amount Amount of ERC20 tokens to deposit
  25 |     |      *
  26 |     |      */
  27 |     |     function depositFunds(uint256 _amount) external;
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice Stage one of withdrawal process
  31 |     |      *
  32 |     |      * @param _amount Amount of shares to withdraw
  33 |     |      *
  34 |     |      */
  35 |     |     function withdrawalStageOne(uint256 _amount) external;
  36 |     | 
  37 |     |     /**
  38 |     |      * @notice Stage two of withdrawal process
  39 |     |      *
  40 |     |      */
  41 |     |     function withdrawalStageTwo() external;
  42 |     | 
  43 |     |     /**
  44 |     |      * @notice Change withdrawal delay for LPs
  45 |     |      *  Only callable by ADMIN
  46 |     |      *
  47 |     |      * @param _withdrawalDelay New withdrawal Delay in seconds
  48 |     |      *
  49 |     |      */
  50 |     |     function setWithdrawalDelay(uint256 _withdrawalDelay) external;
  51 |     | 
  52 |     |     /**
  53 |     |      * @notice Change withdrawal window for LPs
  54 |     |      *  Only callable by ADMIN
  55 |     |      *
  56 |     |      * @param _withdrawalWindow New withdrawal window in seconds
  57 |     |      *
  58 |     |      */
  59 |     |     function setWithdrawalWindow(uint256 _withdrawalWindow) external;
  60 |     | 
  61 |     |     /**
  62 |     |      * @notice
  63 |     |      *  Allows admin to update bankroll manager contract
  64 |     |      *
  65 |     |      * @param _newBankrollManager address of the new bankroll manager
  66 |     |      *
  67 |     |      */
  68 |     |     function updateBankrollManager(address _newBankrollManager) external;
  69 |     | 
  70 |     |     /**
  71 |     |      * @notice Change staging event period for LPs
  72 |     |      *  Only callable by ADMIN
  73 |     |      *
  74 |     |      * @param _withdrawalEventPeriod New staging event period in seconds
  75 |     |      *
  76 |     |      */
  77 |     |     function setWithdrawalEventPeriod(uint256 _withdrawalEventPeriod) external;
  78 |     | 
  79 |     |     /**
  80 |     |      * @notice Pay player amount in ERC20 tokens from the bankroll
  81 |     |      *  Called by Admin
  82 |     |      *
  83 |     |      * @param _player Player wallet
  84 |     |      * @param _amount Prize money amount
  85 |     |      * @param _operator The operator from which the call comes from
  86 |     |      *
  87 |     |      */
  88 |     |     function debit(address _player, uint256 _amount, address _operator) external;
  89 |     | 
  90 |     |     /**
  91 |     |      * @notice Pay bankroll in ERC20 tokens from players loss
  92 |     |      *  Called by Admin
  93 |     |      *
  94 |     |      * @param _amount Player loss amount
  95 |     |      * @param _operator The operator from which the call comes from
  96 |     |      *
  97 |     |      */
  98 |     |     function credit(uint256 _amount, address _operator) external;
  99 |     | 
 100 |     |     /**
 101 |     |      * @notice Remove or add authorized liquidity provider to the bankroll
 102 |     |      *  Called by Admin
 103 |     |      *
 104 |     |      * @param _lp Liquidity Provider address
 105 |     |      * @param _isAuthorized If false, LP will not be able to deposit
 106 |     |      *
 107 |     |      */
 108 |     |     function setInvestorWhitelist(address _lp, bool _isAuthorized) external;
 109 |     | 
 110 |     |     /**
 111 |     |      * @notice Make bankroll permissionless for LPs or not
 112 |     |      *  Called by Admin
 113 |     |      *
 114 |     |      * @param _lpIs Toggle enum betwen OPEN and WHITELISTED
 115 |     |      *
 116 |     |      */
 117 |     |     function setPublic(DGDataTypes.LpIs _lpIs) external;
 118 |     | 
 119 |     |     /**
 120 |     |      * @notice Remove the GGR of a specified operator from the total GGR, 
 121 |     |      *  then null out the operator GGR. Only callable by the bankroll manager
 122 |     |      *
 123 |     |      * @param _operator the address  of the operator we want to null out
 124 |     |      *
 125 |     |      */
 126 |     |     function nullGgrOf(address _operator) external;
 127 |     | 
 128 |     |     //   _    ___                 ______                 __  _
 129 |     |     //  | |  / (_)__ _      __   / ____/_  ______  _____/ /_(_)___  ____  _____
 130 |     |     //  | | / / / _ \ | /| / /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 131 |     |     //  | |/ / /  __/ |/ |/ /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 132 |     |     //  |___/_/\___/|__/|__/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 133 |     | 
 134 |     |     function token() external view returns (IERC20Upgradeable token);
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Returns the amount of ERC20 tokens held by the bankroll that are available for playes to win and
 138 |     |      *  will not include funds that are reserved for GGR
 139 |     |      *
 140 |     |      * @return _balance available balance for LPs
 141 |     |      *
 142 |     |      */
 143 |     |     function liquidity() external view returns (uint256 _balance);
 144 |     | 
 145 |     |     /**
 146 |     |      * @notice Returns the current value of the LPs investment (deposit + profit).
 147 |     |      *
 148 |     |      * @param _lp Liquidity Provider address
 149 |     |      *
 150 |     |      * @return _amount the value of the lps holdings
 151 |     |      *
 152 |     |      */
 153 |     |     function getLpValue(address _lp) external view returns (uint256 _amount);
 154 |     | 
 155 |     |     /**
 156 |     |      * @notice Returns the current stake of the LPs investment in percentage
 157 |     |      *
 158 |     |      * @param _lp Liquidity Provider address
 159 |     |      *
 160 |     |      * @return _stake the stake amount of given LP address
 161 |     |      *
 162 |     |      */
 163 |     |     function getLpStake(address _lp) external view returns (uint256 _stake);
 164 |     | 
 165 |     |     /**
 166 |     |      * @notice returns the maximum amount that can be taken from the bankroll during debit() call
 167 |     |      *
 168 |     |      * @return _maxRisk the maximum amount that can be risked
 169 |     |      *
 170 |     |      */
 171 |     |     function getMaxRisk() external view returns (uint256 _maxRisk);
 172 |     | 
 173 |     |     /**
 174 |     |      * @notice Getter function for GGR variable
 175 |     |      *
 176 |     |      */
 177 |     |     function GGR() external view returns(int256);
 178 |     | 
 179 |     |     /**
 180 |     |      * @notice getter function for ggrOf mapping
 181 |     |      *
 182 |     |      * @param operator address of operator
 183 |     |      *
 184 |     |      * @return operatorGGR the GGR of specified operator
 185 |     |      *
 186 |     |      */
 187 |     |     function ggrOf(address operator) external view returns(int256 operatorGGR);
 188 |     | }
 189 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/interfaces/IDGBankrollManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title IDGBankrollManager V1
  8 |     |  * @author DeGaming Technical Team
  9 |     |  * @notice Interface for DGBankrollManager contract
 10 |     |  *
 11 |     |  */
 12 |     | interface IDGBankrollManager {
 13 |     |     /**
 14 |     |      * @notice
 15 |     |      *  Approve a bankroll to use the DeGaming Bankroll Manager
 16 |     |      *  Only the contract owner can execute this operation
 17 |     |      *
 18 |     |      * @param _bankroll bankroll contract address to be approved
 19 |     |      *
 20 |     |      */
 21 |     |     function approveBankroll(address _bankroll, uint256 _fee) external;
 22 |     | 
 23 |     |     /**
 24 |     |      * @notice
 25 |     |      *  Prevent a bankroll from using the DeGaming Bankroll Manager
 26 |     |      *  Only the contract owner can execute this operation
 27 |     |      *
 28 |     |      * @param _bankroll bankroll contract address to be blocked
 29 |     |      *
 30 |     |      */
 31 |     |     function blockBankroll(address _bankroll) external;
 32 |     | 
 33 |     |     /**
 34 |     |      * @notice
 35 |     |      *  Update existing bankrolls fee
 36 |     |      *
 37 |     |      * @param _bankroll bankroll contract address to be blocked
 38 |     |      * @param _newFee bankroll contract address to be blocked
 39 |     |      *
 40 |     |      */
 41 |     |     function updateLpFee(address _bankroll, uint256 _newFee) external;
 42 |     | 
 43 |     |     /**
 44 |     |      * @notice 
 45 |     |      *  Adding list of operator to list of operators associated with a bankroll
 46 |     |      *  Only calleable by owner
 47 |     |      *
 48 |     |      * @param _bankroll the bankroll contract address
 49 |     |      * @param _operator address of the operator we want to add to the list of associated operators
 50 |     |      *
 51 |     |      */
 52 |     |     function setOperatorToBankroll(address _bankroll, address _operator) external;
 53 |     | 
 54 |     |     function removeOperatorFromBankroll(address _operator, address _bankroll) external;
 55 |     | 
 56 |     |     function blockOperator(address _operator) external;
 57 |     | 
 58 |     |     //     ______     __                        __   ______                 __  _
 59 |     |     //    / ____/  __/ /____  _________  ____ _/ /  / ____/_  ______  _____/ /_(_)___  ____  _____
 60 |     |     //   / __/ | |/_/ __/ _ \/ ___/ __ \/ __ `/ /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 61 |     |     //  / /____>  </ /_/  __/ /  / / / / /_/ / /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 62 |     |     // /_____/_/|_|\__/\___/_/  /_/ /_/\__,_/_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 63 |     | 
 64 |     |     /**
 65 |     |      * @notice Claim profit from the bankroll
 66 |     |      * 
 67 |     |      * @param _bankroll address of bankroll 
 68 |     |      *
 69 |     |      */
 70 |     |     function claimProfit(address _bankroll) external;
 71 |     | 
 72 |     |     function isApproved(address operator) external view returns(bool approved); 
 73 |     | 
 74 |     |     function operatorOfBankroll(address _bankroll, address _operator) external view returns (bool _isRelated);
 75 |     | 
 76 |     |     function eventPeriodOf(address bankroll) external view returns(uint256 eventPeriod);
 77 |     | 
 78 |     |     function bankrollStatus(address bankroll) external view returns(bool isApproved);
 79 |     | } 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/interfaces/IDGEscrow.sol
  1 |     | // SPDX_License_Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | /**
  5 |     |  * @title DGEscrow
  6 |     |  * @author DeGaming Technical Team
  7 |     |  * @notice Escrow Contract for DeGaming's Bankroll poducts
  8 |     |  *
  9 |     |  */
 10 |     | interface IDGEscrow {
 11 |     | 
 12 |     |     //      ______     __                        __   ______                 __  _
 13 |     |     //     / ____/  __/ /____  _________  ____ _/ /  / ____/_  ______  _____/ /_(_)___  ____  _____
 14 |     |     //    / __/ | |/_/ __/ _ \/ ___/ __ \/ __ `/ /  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
 15 |     |     //   / /____>  </ /_/  __/ /  / / / / /_/ / /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  )
 16 |     |     //  /_____/_/|_|\__/\___/_/  /_/ /_/\__,_/_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
 17 |     | 
 18 |     |     /**
 19 |     |      * @notice
 20 |     |      *  Function called by the bankroll to send funds to the escrow
 21 |     |      *
 22 |     |      * @param _player address of the player 
 23 |     |      * @param _operator address of the operator
 24 |     |      * @param _token address of the token
 25 |     |      * @param _winnings amount of tokens sent to escrow
 26 |     |      *
 27 |     |      */
 28 |     |     function depositFunds(address _player, address _operator, address _token, uint256 _winnings) external; 
 29 |     | 
 30 |     |     /**
 31 |     |      * @notice
 32 |     |      *  Allows DeGaming to release escrowed funds to the player wallet
 33 |     |      *
 34 |     |      * @param _id id in bytes format
 35 |     |      *
 36 |     |      */
 37 |     |     function releaseFunds(bytes memory _id) external;
 38 |     | 
 39 |     |     /**
 40 |     |      * @notice
 41 |     |      *  Allows DeGaming to revert escrowed funds back into the bankroll in case of fraud
 42 |     |      *
 43 |     |      * @param _id id in bytes format
 44 |     |      *
 45 |     |      */
 46 |     |     function revertFunds(bytes memory _id) external;
 47 |     | 
 48 |     |     /**
 49 |     |      * @notice
 50 |     |      *  Allows players to claim their escrowed amount after a certain period has passed
 51 |     |      *  id escrow is left unaddressed by DeGaming
 52 |     |      *
 53 |     |      * @param _id id in bytes format
 54 |     |      *
 55 |     |      */
 56 |     |     function claimUnaddressed(bytes memory _id) external;
 57 |     | 
 58 |     |     /**
 59 |     |      * @notice 
 60 |     |      *  Allows admin to set new event period time
 61 |     |      *
 62 |     |      * @param _newEventPeriod New event period time in seconds
 63 |     |      *
 64 |     |      */
 65 |     |     function setEventPeriod(uint256 _newEventPeriod) external;
 66 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/libraries/DGDataTypes.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | /**
  5 |     |  * @title DGDataTypes
  6 |     |  * @author DeGaming Technical Team
  7 |     |  * @notice Library containing DeGaming contracts' custom data types
  8 |     |  */
  9 |     | library DGDataTypes {
 10 |     |     /// @dev Enum for holding LP status
 11 |     |     enum LpIs {
 12 |     |         OPEN,
 13 |     |         WHITELISTED
 14 |     |     }
 15 |     | 
 16 |     |     /// @dev Enum for holding withdrawal stage
 17 |     |     enum WithdrawalIs {
 18 |     |         FULLFILLED,
 19 |     |         STAGED
 20 |     |     }
 21 |     | 
 22 |     |     /// @dev Withdrawal window timestamps
 23 |     |     struct WithdrawalInfo {
 24 |     |         uint256 timestamp;
 25 |     |         uint256 amountToClaim;
 26 |     |         WithdrawalIs stage;
 27 |     |     }
 28 |     | 
 29 |     |     /// @dev Escrow entry 
 30 |     |     struct EscrowEntry {
 31 |     |         address bankroll;
 32 |     |         address operator;
 33 |     |         address player;
 34 |     |         address token;
 35 |     |         uint256 timestamp;
 36 |     |     }
 37 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/libraries/DGErrors.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | /**
  5 |     |  * @title DGErrors
  6 |     |  * @author DeGaming Technical Team
  7 |     |  * @notice Library containing DeGaming contracts' custom errors
  8 |     |  */
  9 |     | library DGErrors {
 10 |     |     /// @dev Error thrown if LP is not on the whitelist
 11 |     |     error LP_IS_NOT_WHITELISTED();
 12 |     |     
 13 |     |     /// @dev Error thrown when someone tries to claim fees before the eventperiod is over
 14 |     |     error EVENT_PERIOD_NOT_PASSED();
 15 |     | 
 16 |     |     /// @dev Error thrown if bankroll is not an approved DeGaming bankroll
 17 |     |     error BANKROLL_NOT_APPROVED();
 18 |     | 
 19 |     |     /// @dev Error thrown if GGR < 1 or even negative
 20 |     |     error NOTHING_TO_CLAIM();
 21 |     | 
 22 |     |     /// @dev Error thrown when address sent to credit/debit is not a valid operator
 23 |     |     error NOT_AN_OPERATOR();
 24 |     | 
 25 |     |     /// @dev Error thrown when lp has no access
 26 |     |     error NO_LP_ACCESS_PERMISSION();
 27 |     | 
 28 |     |     /// @dev Error thrown when bankroll with a > 100% fee is being requested to be added  
 29 |     |     error TO_HIGH_FEE();
 30 |     | 
 31 |     |     /// @dev Error thrown if we are trying to update a role with the previous role holder not being valid
 32 |     |     error ADDRESS_DOES_NOT_HOLD_ROLE();
 33 |     | 
 34 |     |     /// @dev Error thrown if operator is not associated with this specific bankroll
 35 |     |     error OPERATOR_NOT_ASSOCIATED_WITH_BANKROLL();
 36 |     | 
 37 |     |     /// @dev Error thrown when trying to redundantly add operators to bankrolls
 38 |     |     error OPERATOR_ALREADY_ADDED_TO_BANKROLL();
 39 |     | 
 40 |     |     /// @dev Error thrown when LP is trying to withdraw more than they have
 41 |     |     error LP_REQUESTED_AMOUNT_OVERFLOW();
 42 |     | 
 43 |     |     /// @dev Error thrown when a bankroll has a minimum lp amount which the depositor does not satisfy
 44 |     |     error DEPOSITION_TO_LOW();
 45 |     | 
 46 |     |     /// @dev Error thrown when desired bankroll is not a contract
 47 |     |     error ADDRESS_NOT_A_CONTRACT();
 48 |     | 
 49 |     |     /// @dev Error thrown when desired operator is not a wallet
 50 |     |     error ADDRESS_NOT_A_WALLET();
 51 |     | 
 52 |     |     /// @dev Error thrown when max risk is too high
 53 |     |     error MAXRISK_TOO_HIGH();
 54 |     | 
 55 |     |     /// @dev Error thrown when escrow threshold is too high
 56 |     |     error ESCROW_THRESHOLD_TOO_HIGH();
 57 |     | 
 58 |     |     /// @dev Error thrown when withdrawal queue is full
 59 |     |     error WITHDRAWAL_QUEUE_FULL();
 60 |     | 
 61 |     |     /// @dev Error thrown when withdrawal queue is empty
 62 |     |     error WITHDRAWAL_QUEUE_EMPTY();
 63 |     | 
 64 |     |     /// @dev Error thrown when withdrawal timestamp hasnt passed
 65 |     |     error WITHDRAWAL_TIMESTAMP_HASNT_PASSED();
 66 |     | 
 67 |     |     /// @dev Error thrown when withdrawal is in staging mode
 68 |     |     error WITHDRAWAL_PROCESS_IN_STAGING();
 69 |     | 
 70 |     |     /// @dev Error thrown when trying to fullfill an already fullfilled withdrawal
 71 |     |     error WITHDRAWAL_ALREADY_FULLFILLED();
 72 |     | 
 73 |     |     /// @dev Error thrown when LPs are trying to withdraw outside of their withdrawal window
 74 |     |     error OUTSIDE_WITHDRAWAL_WINDOW();
 75 |     | 
 76 |     |     /// @dev Error thrown when someone unauthorized is trying to claim
 77 |     |     error UNAUTHORIZED_CLAIM();
 78 |     | 
 79 |     |     /// @dev Error thrown if wallet is not EOA
 80 |     |     error NOT_AN_EOA_WALLET();
 81 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/src/libraries/DGEvents.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | /**
  5 |     |  * @title DGEvents
  6 |     |  * @author DeGaming Technical Team
  7 |     |  * @notice Library containing DeGaming contracts' custom events
  8 |     |  */
  9 |     | library DGEvents {
 10 |     |     /// @dev Event emitted when LPs have deposited funds
 11 |     |     event FundsDeposited(address lp, uint256 amount);
 12 |     | 
 13 |     |     /// @dev Event emitted when LPs have withdrawn funds
 14 |     |     event FundsWithdrawn(address lp, uint256 amount);
 15 |     | 
 16 |     |     /// @dev Event emitted when LP withdrawal is staged;
 17 |     |     event WithdrawalStaged(address lp, uint256 timestampMin, uint256 timestampMax);
 18 |     |     
 19 |     |     /// @dev Event emitted when debit function is called
 20 |     |     event Debit(address manager, address player, uint256 amount);
 21 |     |     
 22 |     |     /// @dev Event emitted when Credit function is called
 23 |     |     event Credit(address manager, uint256 amount);
 24 |     |     
 25 |     |     /// @dev Event emitted when the bankroll is emptied or reached max risk
 26 |     |     event BankrollSwept(address player, uint256 amount);
 27 |     | 
 28 |     |     /// @dev Event emitted when profits are claimed
 29 |     |     event ProfitsClaimed(address bankroll, uint256 ggrTotal, uint256 sentToDeGaming);
 30 |     | 
 31 |     |     /// @dev Event emitted when funds are escrowed
 32 |     |     event WinningsEscrowed(address bankroll, address operator, address player, address token, bytes id);
 33 |     | 
 34 |     |     /// @dev Event emitted when escrow is payed out
 35 |     |     event EscrowPayed(address recipient, bytes id, uint256 amount);
 36 |     |     
 37 |     |     /// @dev Event emitted when escrow is payed out
 38 |     |     event EscrowReverted(address bankroll, bytes id, uint256 amount);
 39 |     | }
 40 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/test/contracts/Bankroll.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.18;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | 
   6 |     | /* OpenZeppelin contract */
   7 |     | import {TransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
   8 |     | import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
   9 |     | 
  10 |     | /* DeGaming Contracts */
  11 |     | import {Bankroll} from "src/Bankroll.sol";
  12 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  13 |     | import {DGBankrollFactory} from "src/DGBankrollFactory.sol";
  14 |     | import {DGEscrow} from "src/DGEscrow.sol";
  15 |     | 
  16 |     | /* DeGaming Libraries */
  17 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
  18 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
  19 |     | 
  20 |     | /* Mock Contracts */
  21 |     | import {MockToken} from "test/mock/MockToken.sol";
  22 |     | 
  23 |     | 
  24 |     | contract BankrollTest is Test {
  25 |     |     address admin;
  26 |     |     address operator;
  27 |     |     address lpOne;
  28 |     |     address lpTwo;
  29 |     |     address player;
  30 |     |     address owner;
  31 |     |     uint256 maxRisk;
  32 |     |     uint256 threshold;
  33 |     |     TransparentUpgradeableProxy public bankrollProxy;
  34 |     | 
  35 |     |     ProxyAdmin public proxyAdmin;
  36 |     | 
  37 |     |     DGBankrollFactory public dgBankrollFactory;
  38 |     |     DGBankrollManager public dgBankrollManager;
  39 |     |     DGEscrow public dgEscrow;
  40 |     |     Bankroll public bankroll;
  41 |     |     MockToken public token;
  42 |     | 
  43 |     |     function setUp() public {
  44 |     |         admin = address(0x1);
  45 |     |         operator = address(0x2);
  46 |     |         lpOne = address(0x3);
  47 |     |         lpTwo = address(0x4);
  48 |     |         player = address(0x5);
  49 |     |         owner = address(0x6);
  50 |     |         maxRisk = 10_000;
  51 |     |         threshold = 10_000;
  52 |     | 
  53 |     |         dgBankrollFactory = new DGBankrollFactory();
  54 |     | 
  55 |     |         dgBankrollManager = new DGBankrollManager(admin);
  56 |     |         token = new MockToken("token", "MTK");
  57 |     | 
  58 |     |         dgEscrow = new DGEscrow(1 weeks, address(dgBankrollManager));
  59 |     | 
  60 |     |         proxyAdmin = new ProxyAdmin();
  61 |     | 
  62 |     |         bankrollProxy = new TransparentUpgradeableProxy(
  63 |     |             address(new Bankroll()),
  64 |     |             address(proxyAdmin),
  65 |     |             abi.encodeWithSelector(
  66 |     |                 Bankroll.initialize.selector,
  67 |     |                 admin,
  68 |     |                 address(token),
  69 |     |                 address(dgBankrollManager),
  70 |     |                 address(dgEscrow),
  71 |     |                 owner,
  72 |     |                 maxRisk,
  73 |     |                 threshold
  74 |     |             )
  75 |     |         );
  76 |     | 
  77 |     |         bankroll = Bankroll(address(bankrollProxy));
  78 |     | 
  79 |     |         token.mint(lpOne, 1_000_000e6);
  80 |     |         token.mint(lpTwo, 1_000_000e6);
  81 |     |         token.mint(admin, 1_000_000e6);
  82 |     | 
  83 |     |         dgBankrollManager.addOperator(operator);
  84 |     |         dgBankrollManager.approveBankroll(address(bankroll), 0);
  85 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), operator);
  86 |     |     }
  87 |     | 
  88 |     |     function test_initialize(
  89 |     |         Bankroll _bankroll,
  90 |     |         address _admin,
  91 |     |         address _owner,
  92 |     |         uint256 _maxRisk,
  93 |     |         uint256 _threshold,
  94 |     |         address _faultyToken,
  95 |     |         address _faultyBankrollManager,
  96 |     |         address _faultyEscrow,
  97 |     |         uint256 _faultyMaxRisk,
  98 |     |         uint256 _faultyThreshold
  99 |     |     ) public {
 100 |     |         vm.assume(address(_bankroll) != address(bankroll));
 101 |     |         vm.assume(_admin != admin);
 102 |     |         vm.assume(_admin != address(0));
 103 |     |         vm.assume(_owner != owner);
 104 |     |         vm.assume(_owner != address(0));
 105 |     |         vm.assume(_maxRisk > 0);
 106 |     |         vm.assume(_maxRisk < 10_000);
 107 |     |         vm.assume(_threshold > 0);
 108 |     |         vm.assume(_threshold < 10_000);
 109 |     |         vm.assume(!_isContract(_admin));
 110 |     |         vm.assume(!_isContract(_owner));
 111 |     |         vm.assume(!_isContract(_faultyToken));
 112 |     |         vm.assume(!_isContract(_faultyBankrollManager));
 113 |     |         vm.assume(!_isContract(_faultyEscrow));
 114 |     |         vm.assume(_faultyMaxRisk > 10_000);
 115 |     |         vm.assume(_faultyThreshold > 10_000);
 116 |     | 
 117 |     |         //vm.expectRevert(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
 118 |     |         vm.expectRevert();
 119 |     |         _bankroll.initialize(_admin, _faultyToken, address(dgBankrollManager), address(dgEscrow), owner, maxRisk, threshold);
 120 |     | 
 121 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
 122 |     |         _bankroll.initialize(_admin, address(token), _faultyBankrollManager, address(dgEscrow), owner, maxRisk, threshold);
 123 |     |         
 124 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
 125 |     |         _bankroll.initialize(_admin, address(token), address(dgBankrollManager), _faultyEscrow, owner, maxRisk, threshold);
 126 |     | 
 127 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_WALLET.selector);
 128 |     |         _bankroll.initialize(_admin, address(token), address(dgBankrollManager), address(dgEscrow), address(dgBankrollManager), maxRisk, threshold);
 129 |     | 
 130 |     |         vm.expectRevert(DGErrors.MAXRISK_TOO_HIGH.selector);
 131 |     |         _bankroll.initialize(_admin, address(token), address(dgBankrollManager), address(dgEscrow), owner, _faultyMaxRisk, threshold);
 132 |     |         
 133 |     |         vm.expectRevert(DGErrors.ESCROW_THRESHOLD_TOO_HIGH.selector);
 134 |     |         _bankroll.initialize(_admin, address(token), address(dgBankrollManager), address(dgEscrow), owner, _faultyMaxRisk, threshold);
 135 |     | 
 136 |     |         _bankroll.initialize(_admin, address(token), address(dgBankrollManager), address(dgEscrow), owner, maxRisk, threshold);
 137 |     |     } 
 138 |     | 
 139 |     |     function test_depositFunds() public {
 140 |     |         assertEq(bankroll.liquidity(), 0);
 141 |     | 
 142 |     |         // lp one deposits 1_000_000
 143 |     |         vm.startPrank(lpOne);
 144 |     |         token.approve(address(bankroll), 1_000_000e6);
 145 |     |         bankroll.depositFunds(1_000_000e6);
 146 |     |         assertEq(bankroll.sharesOf(address(lpOne)), 1_000_000e6);
 147 |     |         vm.stopPrank();
 148 |     | 
 149 |     |         assertEq(bankroll.totalSupply(), 1_000_000e6);
 150 |     |         assertEq(bankroll.liquidity(), 1_000_000e6);
 151 |     | 
 152 |     |         // lp two deposits 1_000_000
 153 |     |         vm.startPrank(lpTwo);
 154 |     |         token.approve(address(bankroll), 1_000_000e6);
 155 |     |         bankroll.depositFunds(1_000_000e6);
 156 |     |         assertEq(bankroll.sharesOf(address(lpTwo)), 1_000_000e6);
 157 |     |         vm.stopPrank();
 158 |     | 
 159 |     |         assertEq(bankroll.totalSupply(), 2_000_000e6);
 160 |     |         assertEq(bankroll.liquidity(), 2_000_000e6);
 161 |     |     }
 162 |     | 
 163 |     |     function test_depositFundsWithInvestorWhitelist() public {
 164 |     |         vm.prank(admin);
 165 |     |         bankroll.setPublic(DGDataTypes.LpIs.WHITELISTED);
 166 |     | 
 167 |     |         // lp one deposits 1_000_000
 168 |     |         vm.startPrank(lpOne);
 169 |     |         token.approve(address(bankroll), 1_000_000e6);
 170 |     |         vm.expectRevert(DGErrors.LP_IS_NOT_WHITELISTED.selector); //reverts: FORBIDDEN()
 171 |     |         bankroll.depositFunds(1_000_000e6);
 172 |     |         vm.stopPrank();
 173 |     | 
 174 |     |         vm.prank(admin);
 175 |     |         bankroll.setInvestorWhitelist(lpOne, true);
 176 |     | 
 177 |     |         vm.startPrank(lpOne);
 178 |     |         bankroll.depositFunds(1_000_000e6);
 179 |     | 
 180 |     |         assertEq(bankroll.sharesOf(address(lpOne)), 1_000_000e6);
 181 |     | 
 182 |     |         vm.stopPrank();
 183 |     |     }
 184 |     | 
 185 |     |     function test_withdrawStageOne() public {
 186 |     |         vm.startPrank(lpOne);
 187 |     |         token.approve(address(bankroll), 1_000_000e6);
 188 |     |         bankroll.depositFunds(1_000_000e6);
 189 |     | 
 190 |     |         bankroll.withdrawalStageOne(bankroll.sharesOf(lpOne));
 191 |     | 
 192 |     |         vm.warp(3);
 193 |     | 
 194 |     |         // vm.expectRevert(DGErrors.WITHDRAWAL_PROCESS_IN_STAGING.selector);
 195 |     |         // bankroll.withdrawalStageOne(bankroll.sharesOf(lpOne));
 196 |     | 
 197 |     |         vm.stopPrank();
 198 |     |     }
 199 |     | 
 200 |     |     function test_updateBankrollManager(address _wallet) public {
 201 |     |         vm.assume(!_isContract(_wallet));
 202 |     |         DGBankrollManager newBankrollManager = new DGBankrollManager(admin);
 203 |     | 
 204 |     |         vm.startPrank(admin);
 205 |     | 
 206 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
 207 |     |         bankroll.updateBankrollManager(_wallet);
 208 |     | 
 209 |     |         bankroll.updateBankrollManager(address(newBankrollManager));
 210 |     | 
 211 |     |         bankroll.maxContractsApprove();
 212 |     | 
 213 |     |         vm.stopPrank();
 214 |     |         assertEq(token.allowance(address(bankroll), address(newBankrollManager)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
 215 |     |     }
 216 |     | 
 217 |     |     function test_withdrawStageTwo() public {
 218 |     |         vm.startPrank(lpOne);
 219 |     |         token.approve(address(bankroll), 1_000_000e6);
 220 |     |         bankroll.depositFunds(1_000_000e6);
 221 |     | 
 222 |     |         bankroll.withdrawalStageOne(bankroll.sharesOf(lpOne));
 223 |     | 
 224 |     |         vm.warp(3);
 225 |     | 
 226 |     |         bankroll.withdrawalStageTwo();
 227 |     | 
 228 |     |         vm.stopPrank();
 229 |     |     }
 230 |     | 
 231 |     |     function test_setWithdrawalEventPeriod(uint256 _newEventPeriod) public{
 232 |     |         vm.assume(_newEventPeriod < 45 minutes);
 233 |     |         vm.assume(_newEventPeriod > 30 minutes);
 234 |     |         vm.prank(admin);
 235 |     |         bankroll.setWithdrawalEventPeriod(_newEventPeriod);
 236 |     | 
 237 |     |         vm.startPrank(lpOne);
 238 |     |         token.approve(address(bankroll), 1_000_000e6);
 239 |     |         bankroll.depositFunds(1_000_000e6);
 240 |     | 
 241 |     |         bankroll.withdrawalStageOne((bankroll.sharesOf(lpOne)) / 2);
 242 |     | 
 243 |     |         vm.warp(_newEventPeriod + 1);
 244 |     | 
 245 |     |         bankroll.withdrawalStageOne((bankroll.sharesOf(lpOne)) / 2);
 246 |     | 
 247 |     |         vm.stopPrank();
 248 |     |     }
 249 |     | 
 250 |     |     function test_setWithdrawalDelay(uint256 _newWithdrawalDelay) public {
 251 |     |         vm.assume(_newWithdrawalDelay > 3);
 252 |     |         vm.assume(_newWithdrawalDelay < 350);
 253 |     |         
 254 |     |         vm.startPrank(lpOne);
 255 |     |         token.approve(address(bankroll), 1_000_000e6);
 256 |     |         bankroll.depositFunds(1_000_000e6);
 257 |     | 
 258 |     |         bankroll.withdrawalStageOne(bankroll.sharesOf(lpOne));
 259 |     |         vm.stopPrank();
 260 |     | 
 261 |     |         vm.prank(admin);
 262 |     |         bankroll.setWithdrawalDelay(_newWithdrawalDelay);
 263 |     | 
 264 |     |         vm.startPrank(lpOne);
 265 |     |         vm.warp(3);
 266 |     | 
 267 |     |         vm.expectRevert(DGErrors.OUTSIDE_WITHDRAWAL_WINDOW.selector);
 268 |     |         bankroll.withdrawalStageTwo();
 269 |     | 
 270 |     |         vm.stopPrank();
 271 |     |     }
 272 |     | 
 273 |     |     function test_setWithdrawalWindow() public {
 274 |     |         vm.startPrank(lpOne);
 275 |     |         token.approve(address(bankroll), 1_000_000e6);
 276 |     |         bankroll.depositFunds(1_000_000e6);
 277 |     | 
 278 |     |         bankroll.withdrawalStageOne(bankroll.sharesOf(lpOne));
 279 |     |         vm.stopPrank();
 280 |     | 
 281 |     |         vm.prank(admin);
 282 |     |         bankroll.setWithdrawalWindow(30);
 283 |     | 
 284 |     |         vm.startPrank(lpOne);
 285 |     |         vm.warp(61);
 286 |     | 
 287 |     |         vm.expectRevert(DGErrors.OUTSIDE_WITHDRAWAL_WINDOW.selector);
 288 |     |         bankroll.withdrawalStageTwo();
 289 |     | 
 290 |     |         vm.stopPrank();
 291 |     |     }
 292 |     | 
 293 |     |     function test_debit() public {
 294 |     |         vm.startPrank(lpOne);
 295 |     |         token.approve(address(bankroll), 1_000_000e6);
 296 |     |         bankroll.depositFunds(1_000_000e6);
 297 |     |         vm.stopPrank();
 298 |     | 
 299 |     |         // bankroll has 1_000_000
 300 |     |         assertEq(token.balanceOf(address(bankroll)), 1_000_000e6);
 301 |     |         assertEq(bankroll.liquidity(), 1_000_000e6);
 302 |     | 
 303 |     |         // lpOne has 1_000_000 shares
 304 |     |         assertEq(token.balanceOf(address(lpOne)), 0);
 305 |     |         assertEq(bankroll.sharesOf(address(lpOne)), 1_000_000e6);
 306 |     | 
 307 |     |         // Test operator revert
 308 |     |         dgBankrollManager.addOperator(address(69));
 309 |     |         vm.prank(admin);
 310 |     |         vm.expectRevert(DGErrors.OPERATOR_NOT_ASSOCIATED_WITH_BANKROLL.selector);
 311 |     |         bankroll.debit(player, 500_000e6, address(69));
 312 |     | 
 313 |     |         // pay player 500_000
 314 |     |         vm.prank(admin);
 315 |     |         bankroll.debit(player, 500_000e6, operator);
 316 |     | 
 317 |     |         // bankroll now has 500_000
 318 |     |         assertEq(bankroll.liquidity(), 500_000e6);
 319 |     | 
 320 |     |         // player now has 500_000
 321 |     |         assertEq(token.balanceOf(address(player)), 500_000e6);
 322 |     | 
 323 |     |         // lpOne now has shares worth only 500_000
 324 |     |         assertEq(bankroll.getLpValue(address(lpOne)), 500_000e6);
 325 |     |     }
 326 |     | 
 327 |     |     function test_debitInsufficientFunds() public {
 328 |     |         vm.startPrank(lpOne);
 329 |     |         token.approve(address(bankroll), 1_000_000e6);
 330 |     |         bankroll.depositFunds(1_000_000e6);
 331 |     |         vm.stopPrank();
 332 |     | 
 333 |     |         assertEq(bankroll.liquidity(), 1_000_000e6);
 334 |     | 
 335 |     |         vm.prank(admin);
 336 |     |         bankroll.debit(player, 5000_000e6, operator);
 337 |     | 
 338 |     |         assertEq(bankroll.liquidity(), 0);
 339 |     |         assertEq(token.balanceOf(address(player)), 1_000_000e6);
 340 |     |         assertEq(token.balanceOf(address(lpOne)), 0);
 341 |     | 
 342 |     |         assertEq(bankroll.sharesOf(address(lpOne)), 1_000_000e6);
 343 |     |         assertEq(bankroll.getLpValue(address(lpOne)), 0);
 344 |     |     }
 345 |     | 
 346 |     |     function test_credit() public {
 347 |     |         vm.startPrank(lpOne);
 348 |     |         token.approve(address(bankroll), 1_000_000e6);
 349 |     |         bankroll.depositFunds(1_000_000e6);
 350 |     |         vm.stopPrank();
 351 |     | 
 352 |     |         // Test operator revert
 353 |     |         dgBankrollManager.addOperator(address(69));
 354 |     |         vm.startPrank(admin);
 355 |     |         token.approve(address(bankroll), 500_000e6);
 356 |     |         vm.expectRevert(DGErrors.OPERATOR_NOT_ASSOCIATED_WITH_BANKROLL.selector);
 357 |     |         bankroll.credit(500_000e6, address(69));
 358 |     |         vm.stopPrank();
 359 |     | 
 360 |     |         vm.startPrank(admin);
 361 |     |         token.approve(address(bankroll), 500_000e6);
 362 |     |         bankroll.credit(500_000e6, operator);
 363 |     |         vm.stopPrank();
 364 |     | 
 365 |     |         // profit is not available for LPs before managers has claimed it
 366 |     |         assertEq(bankroll.liquidity(), 1_000_000e6);
 367 |     |         assertEq(bankroll.GGR(), 500_000e6);
 368 |     |         //assertEq(bankroll.lpsProfit(), 0);
 369 |     |     }
 370 |     | 
 371 |     |     function test_changeMaxRisk(uint256 _faultyMaxRisk, uint256 _correctMaxRisk) public {
 372 |     |         vm.assume(_faultyMaxRisk > 10_000);
 373 |     |         vm.assume(_correctMaxRisk < 10_000);
 374 |     | 
 375 |     |         vm.startPrank(admin);
 376 |     | 
 377 |     |         vm.expectRevert(DGErrors.MAXRISK_TOO_HIGH.selector);
 378 |     |         bankroll.changeMaxRisk(_faultyMaxRisk);
 379 |     | 
 380 |     |         bankroll.changeMaxRisk(_correctMaxRisk);
 381 |     |         vm.stopPrank();
 382 |     |     }
 383 |     | 
 384 |     |     function test_setInvestorWhitelist() public {
 385 |     |         assertEq(bankroll.lpWhitelist(lpOne), false);
 386 |     | 
 387 |     |         vm.expectRevert(DGErrors.NO_LP_ACCESS_PERMISSION.selector);
 388 |     |         bankroll.setInvestorWhitelist(lpOne, true);
 389 |     | 
 390 |     |         vm.prank(admin);
 391 |     |         bankroll.setInvestorWhitelist(lpOne, true);
 392 |     | 
 393 |     |         assertEq(bankroll.lpWhitelist(lpOne), true);
 394 |     |     }
 395 |     | 
 396 |     |     function test_setPublic() public {
 397 |     |         assertEq(uint256(bankroll.lpIs()), 0);
 398 |     | 
 399 |     |         vm.prank(admin);
 400 |     |         bankroll.setPublic(DGDataTypes.LpIs.WHITELISTED);
 401 |     | 
 402 |     |         assertEq(uint256(bankroll.lpIs()), 1);
 403 |     |     }
 404 |     | 
 405 |     |     function test_getLpStake(address _lp) public {
 406 |     |         assertEq(bankroll.getLpStake(_lp), 0);
 407 |     |         vm.startPrank(lpOne);
 408 |     |         token.approve(address(bankroll), 10_000e6);
 409 |     |         bankroll.depositFunds(10_000e6);
 410 |     |         vm.stopPrank();
 411 |     | 
 412 |     |         vm.startPrank(lpTwo);
 413 |     |         token.approve(address(bankroll), 10_000e6);
 414 |     |         bankroll.depositFunds(10_000e6);
 415 |     |         vm.stopPrank();
 416 |     | 
 417 |     |         assertEq(bankroll.getLpStake(address(lpOne)), 5_000);
 418 |     |         assertEq(bankroll.getLpStake(address(lpTwo)), 5_000);
 419 |     | 
 420 |     |         console.logUint(bankroll.getLpStake(address(lpOne)));
 421 |     | 
 422 |     |         vm.startPrank(lpOne);
 423 |     |         token.approve(address(bankroll), 10_000e6);
 424 |     |         bankroll.depositFunds(10_000e6);
 425 |     |         vm.stopPrank();
 426 |     | 
 427 |     |         assertEq(bankroll.getLpStake(address(lpOne)), 6_666);
 428 |     |         assertEq(bankroll.getLpStake(address(lpTwo)), 3_333);
 429 |     |     }
 430 |     | 
 431 |     |     function test_minimumLp(uint256 _newLpMinimum, uint256 _toLittle, uint256 _enough) public {
 432 |     |         vm.assume(_toLittle < 250_000e6);
 433 |     |         vm.assume(_newLpMinimum < 500_000e6);
 434 |     |         vm.assume(_enough < 750_000e6);
 435 |     |         vm.assume(_toLittle < _newLpMinimum);
 436 |     |         vm.assume(_enough > _newLpMinimum);
 437 |     | 
 438 |     |         token.mint(lpOne, _enough * 2);
 439 |     | 
 440 |     |         vm.prank(admin);
 441 |     |         bankroll.setMinimumLp(_newLpMinimum);
 442 |     | 
 443 |     |         vm.startPrank(lpOne);
 444 |     | 
 445 |     |         token.approve(address(bankroll), _enough * 2);
 446 |     | 
 447 |     |         vm.expectRevert(DGErrors.DEPOSITION_TO_LOW.selector);
 448 |     |         bankroll.depositFunds(_toLittle);
 449 |     | 
 450 |     |         bankroll.depositFunds(_enough);
 451 |     |         vm.stopPrank();
 452 |     |     }
 453 |     | 
 454 |     |     function test_liquidity(address _lp, address _player) public {
 455 |     |         vm.assume(_player != address(0));
 456 |     |         vm.assume(_lp != address(0));
 457 |     |         vm.assume(!_isContract(_player));
 458 |     | 
 459 |     |         assertEq(bankroll.liquidity(), 0);
 460 |     | 
 461 |     |         vm.startPrank(_lp);
 462 |     | 
 463 |     |         token.mint(_lp, 10e6);
 464 |     |         token.approve(address(bankroll), 10e6);
 465 |     |         bankroll.depositFunds(10e6);
 466 |     |         vm.stopPrank();
 467 |     | 
 468 |     |         token.mint(admin, 50e6);
 469 |     |         vm.startPrank(admin);
 470 |     |         token.approve(address(bankroll), 50e6);
 471 |     |         bankroll.credit(50e6, operator);
 472 |     |         vm.stopPrank();
 473 |     | 
 474 |     |         assertEq(bankroll.liquidity(), 10e6);
 475 |     |         assertEq(bankroll.liquidity(), token.balanceOf(address(bankroll)) - uint256(bankroll.GGR()));
 476 |     | 
 477 |     |         vm.startPrank(admin);
 478 |     |         bankroll.debit(_player, 5e6, operator);
 479 |     |         vm.stopPrank();
 480 |     | 
 481 |     |         // assertEq(bankroll.liquidity(), 5e6);
 482 |     |         // assertEq(bankroll.liquidity(), token.balanceOf(address(bankroll)));
 483 |     |     }
 484 |     | 
 485 |     |     function test_getLPValue(address _lp) public {
 486 |     |         assertEq(bankroll.getLpValue(_lp), 0);
 487 |     |     }
 488 |     |     
 489 |     |     function test_printErrors() public view {
 490 |     |         // 0x89ae3f9a
 491 |     |         console.logBytes4(DGErrors.ADDRESS_DOES_NOT_HOLD_ROLE.selector);
 492 |     |         
 493 |     |         // 0x5c2a0858
 494 |     |         console.logBytes4(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
 495 |     |         
 496 |     |         // 0x192498bf
 497 |     |         console.logBytes4(DGErrors.ADDRESS_NOT_A_WALLET.selector);
 498 |     |         
 499 |     |         // 0x85ef85ac
 500 |     |         console.logBytes4(DGErrors.BANKROLL_NOT_APPROVED.selector);
 501 |     |         
 502 |     |         // 0x2220bdd0
 503 |     |         console.logBytes4(DGErrors.DEPOSITION_TO_LOW.selector);
 504 |     |         
 505 |     |         // 0x2d03b3fd
 506 |     |         console.logBytes4(DGErrors.EVENT_PERIOD_NOT_PASSED.selector);
 507 |     |         
 508 |     |         // 0x1f22f3b3
 509 |     |         console.logBytes4(DGErrors.LP_IS_NOT_WHITELISTED.selector);
 510 |     |         
 511 |     |         // 0xf792d5d9
 512 |     |         console.logBytes4(DGErrors.LP_REQUESTED_AMOUNT_OVERFLOW.selector);
 513 |     |         
 514 |     |         // 0xb717644a
 515 |     |         console.logBytes4(DGErrors.MAXRISK_TOO_HIGH.selector);
 516 |     |         
 517 |     |         // 0x59184bad
 518 |     |         console.logBytes4(DGErrors.NO_LP_ACCESS_PERMISSION.selector);
 519 |     |         
 520 |     |         // 0xf202cc93
 521 |     |         console.logBytes4(DGErrors.NOT_AN_OPERATOR.selector);
 522 |     |         
 523 |     |         // 0x76914729
 524 |     |         console.logBytes4(DGErrors.NOTHING_TO_CLAIM.selector);
 525 |     |         
 526 |     |         // 0x6c07c0e7
 527 |     |         console.logBytes4(DGErrors.OPERATOR_ALREADY_ADDED_TO_BANKROLL.selector);
 528 |     |         
 529 |     |         // 0x341e934a
 530 |     |         console.logBytes4(DGErrors.OPERATOR_NOT_ASSOCIATED_WITH_BANKROLL.selector);
 531 |     |         
 532 |     |         // 0xb0647df7
 533 |     |         console.logBytes4(DGErrors.TO_HIGH_FEE.selector);
 534 |     |     }
 535 |     | 
 536 |     |     function _isContract(address _address) internal view returns (bool _isAddressContract) {
 537 |     |         uint256 size;
 538 |     | 
 539 |     |         assembly {
 540 |     |             size := extcodesize(_address)
 541 |     |         }
 542 |     | 
 543 |     |         _isAddressContract = size > 0;
 544 |     |     }
 545 |     | 
 546 |     |         function test_withdrawStageTwo_fail() public {
 547 |     |         vm.startPrank(lpOne);
 548 |     |         token.approve(address(bankroll), type(uint256).max);
 549 |     |         bankroll.depositFunds(100000e6);
 550 |     |         bankroll.depositFunds(11930361);
 551 |     |         bankroll.withdrawalStageOne(4089590315);
 552 |     | 
 553 |     |         vm.warp(3);
 554 |     | 
 555 |     |         bankroll.withdrawalStageTwo();
 556 |     |         bankroll.depositFunds(1);
 557 |     |         vm.stopPrank();
 558 |     |     }
 559 |     | }
 560 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/test/contracts/DGBankrollFactory.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.18;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | 
   6 |     | /* OpenZeppelin contract */
   7 |     | import {TransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
   8 |     | import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
   9 |     | import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";
  10 |     | 
  11 |     | /* DeGaming Contracts */
  12 |     | import {Bankroll} from "src/Bankroll.sol";
  13 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  14 |     | import {DGBankrollFactory} from "src/DGBankrollFactory.sol";
  15 |     | import {DGEscrow} from "src/DGEscrow.sol";
  16 |     | 
  17 |     | /* DeGaming Libraries */
  18 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
  19 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
  20 |     | 
  21 |     | /* Mock Contracts */
  22 |     | import {MockToken} from "test/mock/MockToken.sol";
  23 |     | 
  24 |     | contract DGBankrollFactoryTest is Test {
  25 |     |     address admin;
  26 |     |     address operator;
  27 |     |     address deGaming;
  28 |     |     address lp;
  29 |     |     address player;
  30 |     |     uint256 maxRisk;
  31 |     |     uint256 threshold;
  32 |     |     uint256 lpFee;
  33 |     | 
  34 |     |     TransparentUpgradeableProxy public bankrollFactoryProxy;
  35 |     |     ProxyAdmin public proxyAdmin;
  36 |     | 
  37 |     |     DGBankrollFactory public dgBankrollFactory;
  38 |     |     DGBankrollManager public dgBankrollManager;
  39 |     |     DGEscrow public dgEscrow;
  40 |     |     Bankroll public bankroll;
  41 |     |     MockToken public token;
  42 |     |     
  43 |     |     bytes32 public constant DEFAULT_ADMIN_ROLE_HASH = 0x0;
  44 |     | 
  45 |     | 
  46 |     |     function setUp() public {
  47 |     |         admin = address(0x1);
  48 |     |         operator = address(0x2);
  49 |     |         lp = address(0x3);
  50 |     |         player = address(0x4);
  51 |     |         deGaming = address(0x5);
  52 |     | 
  53 |     |         maxRisk = 10_000;
  54 |     |         threshold = 10_000;
  55 |     | 
  56 |     |         lpFee = 650;
  57 |     | 
  58 |     |         token = new MockToken("token", "MTK");
  59 |     | 
  60 |     |         proxyAdmin = new ProxyAdmin();
  61 |     | 
  62 |     |         bankroll = new Bankroll();
  63 |     | 
  64 |     |         dgBankrollManager = new DGBankrollManager(admin);
  65 |     | 
  66 |     |         dgEscrow = new DGEscrow(1 weeks, address(dgBankrollManager));
  67 |     | 
  68 |     |         bankrollFactoryProxy = new TransparentUpgradeableProxy(
  69 |     |             address(new DGBankrollFactory()),
  70 |     |             address(proxyAdmin),
  71 |     |             abi.encodeWithSelector(
  72 |     |                 DGBankrollFactory.initialize.selector,
  73 |     |                 address(bankroll),
  74 |     |                 address(dgBankrollManager),
  75 |     |                 address(dgEscrow),
  76 |     |                 deGaming,
  77 |     |                 admin
  78 |     |             )
  79 |     |         );
  80 |     | 
  81 |     |         dgBankrollFactory = DGBankrollFactory(address(bankrollFactoryProxy));
  82 |     | 
  83 |     |         dgBankrollManager.addOperator(operator);
  84 |     |     }
  85 |     | 
  86 |     |     function test_deployBankroll(address _operator, address _faultyToken, uint256 _faultyMaxRisk, bytes32 _salt) public {
  87 |     |         vm.assume(!_isContract(_operator));
  88 |     |         vm.assume(!_isContract(_faultyToken));
  89 |     |         vm.assume(_faultyMaxRisk > 10_000);
  90 |     | 
  91 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
  92 |     |         dgBankrollFactory.deployBankroll(
  93 |     |             _faultyToken, 
  94 |     |             maxRisk,
  95 |     |             threshold, 
  96 |     |             _salt
  97 |     |         );
  98 |     | 
  99 |     |         vm.expectRevert(DGErrors.MAXRISK_TOO_HIGH.selector);
 100 |     |         dgBankrollFactory.deployBankroll(
 101 |     |             address(token), 
 102 |     |             _faultyMaxRisk,
 103 |     |             threshold,
 104 |     |             _salt
 105 |     |         );
 106 |     |         
 107 |     |         dgBankrollFactory.deployBankroll(
 108 |     |             address(token), 
 109 |     |             maxRisk,
 110 |     |             threshold, 
 111 |     |             _salt
 112 |     |         );
 113 |     | 
 114 |     |         dgBankrollManager.approveBankroll(
 115 |     |             dgBankrollFactory.bankrolls(0),
 116 |     |             lpFee
 117 |     |         );
 118 |     | 
 119 |     |         dgBankrollManager.setOperatorToBankroll(
 120 |     |             dgBankrollFactory.bankrolls(0),
 121 |     |             _operator
 122 |     |         );
 123 |     |     }
 124 |     | 
 125 |     |     function test_setBankrollImplementation(address _sender, address _faultyBankroll) public {
 126 |     |         vm.assume(_sender != address(proxyAdmin));
 127 |     |         vm.assume(dgBankrollFactory.bankrollImpl() != _faultyBankroll);
 128 |     |         vm.assume(!_isContract(_faultyBankroll));
 129 |     | 
 130 |     |         dgBankrollFactory.grantRole(DEFAULT_ADMIN_ROLE_HASH, _sender);
 131 |     |     
 132 |     |         vm.startPrank(_sender);
 133 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
 134 |     |         dgBankrollFactory.setBankrollImplementation(_faultyBankroll);
 135 |     | 
 136 |     |         vm.stopPrank();
 137 |     | 
 138 |     |         Bankroll newBankroll = new Bankroll();
 139 |     | 
 140 |     |         vm.prank(_sender);
 141 |     |         dgBankrollFactory.setBankrollImplementation(address(newBankroll));
 142 |     | 
 143 |     |         assertEq(dgBankrollFactory.bankrollImpl(), address(newBankroll));
 144 |     |     }
 145 |     | 
 146 |     |     function test_setDeGaming(address _deGaming) public {
 147 |     |         dgBankrollFactory.setDeGaming(_deGaming);
 148 |     |         assertEq(dgBankrollFactory.deGaming(), _deGaming);
 149 |     |     }
 150 |     | 
 151 |     |     function test_setBankrollImplementation_incorrectRole(address _sender, address _bankroll) public {
 152 |     |         vm.assume(_sender != address(proxyAdmin));
 153 |     |         vm.assume(dgBankrollFactory.hasRole(DEFAULT_ADMIN_ROLE_HASH, _sender) != true);
 154 |     | 
 155 |     |         vm.prank(_sender);
 156 |     |         vm.expectRevert();
 157 |     |         dgBankrollFactory.setBankrollImplementation(_bankroll);
 158 |     |     }
 159 |     | 
 160 |     |     function test_setDgBankrollManager(address _sender, address _faultyBankrollManager) public {
 161 |     |         vm.assume(_sender != address(proxyAdmin));
 162 |     |         vm.assume(dgBankrollFactory.dgBankrollManager() != _faultyBankrollManager);
 163 |     |         vm.assume(!_isContract(_faultyBankrollManager));
 164 |     | 
 165 |     |         dgBankrollFactory.grantRole(DEFAULT_ADMIN_ROLE_HASH, _sender);
 166 |     |     
 167 |     |         vm.startPrank(_sender);
 168 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
 169 |     |         dgBankrollFactory.setDgBankrollManager(_faultyBankrollManager);
 170 |     |         vm.stopPrank();
 171 |     | 
 172 |     |         DGBankrollManager newBankrollManager = new DGBankrollManager(admin);
 173 |     | 
 174 |     |         vm.prank(_sender);
 175 |     |         dgBankrollFactory.setDgBankrollManager(address(newBankrollManager));
 176 |     | 
 177 |     |         assertEq(dgBankrollFactory.dgBankrollManager(), address(newBankrollManager));
 178 |     |     }
 179 |     |     
 180 |     |     function test_setDgEscrow(address _sender, address _faultyEscrow) public {
 181 |     |         vm.assume(_sender != address(proxyAdmin));
 182 |     |         vm.assume(dgBankrollFactory.escrow() != _faultyEscrow);
 183 |     |         vm.assume(!_isContract(_faultyEscrow));
 184 |     | 
 185 |     |         dgBankrollFactory.grantRole(DEFAULT_ADMIN_ROLE_HASH, _sender);
 186 |     |     
 187 |     |         vm.startPrank(_sender);
 188 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
 189 |     |         dgBankrollFactory.setDgEscrow(_faultyEscrow);
 190 |     |         vm.stopPrank();
 191 |     | 
 192 |     |         DGEscrow newEscrow = new DGEscrow(1 weeks, address(dgBankrollManager));
 193 |     | 
 194 |     |         vm.prank(_sender);
 195 |     |         dgBankrollFactory.setDgEscrow(address(newEscrow));
 196 |     | 
 197 |     |         assertEq(dgBankrollFactory.escrow(), address(newEscrow));
 198 |     |     }
 199 |     | 
 200 |     |     function test_setDgBankrollManager_incorrectRole(address _sender, address _bankrollManager) public {
 201 |     |         vm.assume(_sender != address(proxyAdmin));
 202 |     |         vm.assume(dgBankrollFactory.hasRole(DEFAULT_ADMIN_ROLE_HASH, _sender) != true);
 203 |     | 
 204 |     |         vm.prank(_sender);
 205 |     |         vm.expectRevert();
 206 |     | 
 207 |     |         dgBankrollFactory.setDgBankrollManager(_bankrollManager);
 208 |     |     }
 209 |     | 
 210 |     |     function test_setDgAdmin(address _sender, address _admin) public {
 211 |     |         vm.assume(_sender != address(proxyAdmin));
 212 |     |         vm.assume(dgBankrollFactory.dgAdmin() != _admin);
 213 |     |         
 214 |     |         dgBankrollFactory.grantRole(DEFAULT_ADMIN_ROLE_HASH, _sender);
 215 |     | 
 216 |     |         vm.prank(_sender);
 217 |     |         dgBankrollFactory.setDgAdmin(_admin);
 218 |     | 
 219 |     |         assertEq(dgBankrollFactory.dgAdmin(), _admin);
 220 |     |     }
 221 |     | 
 222 |     |     function test_setDgAdmin_incorrectRole(address _sender, address _admin) public {
 223 |     |         vm.assume(_sender != address(proxyAdmin));
 224 |     |         vm.assume(dgBankrollFactory.hasRole(DEFAULT_ADMIN_ROLE_HASH, _sender) != true);
 225 |     | 
 226 |     |         vm.prank(_sender);
 227 |     |         vm.expectRevert();
 228 |     | 
 229 |     |         dgBankrollFactory.setDgAdmin(_admin);
 230 |     |     }
 231 |     | 
 232 |     |     function test_predictBankrollAddress(bytes32 _salt) public {
 233 |     |         assertEq(
 234 |     |             dgBankrollFactory.predictBankrollAddress(_salt),
 235 |     |             Clones.predictDeterministicAddress(
 236 |     |                 dgBankrollFactory.bankrollImpl(), 
 237 |     |                 _salt, 
 238 |     |                 address(dgBankrollFactory)
 239 |     |             )
 240 |     |         );
 241 |     |     }
 242 |     | 
 243 |     |     /**
 244 |     |      * @notice
 245 |     |      *  Allows contract to check if the Token address actually is a contract
 246 |     |      *
 247 |     |      * @param _address address we want to  check
 248 |     |      *
 249 |     |      * @return _isAddressContract returns true if token is a contract, otherwise returns false
 250 |     |      *
 251 |     |      */
 252 |     |     function _isContract(address _address) internal view returns (bool _isAddressContract) {
 253 |     |         uint256 size;
 254 |     | 
 255 |     |         assembly {
 256 |     |             size := extcodesize(_address)
 257 |     |         }
 258 |     | 
 259 |     |         _isAddressContract = size > 0;
 260 |     |     }
 261 |     | }

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/test/contracts/DGBankrollManager.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.19;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | 
   6 |     | /* OpenZeppelin contract */
   7 |     | import {TransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
   8 |     | import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
   9 |     | 
  10 |     | /* DeGaming Contracts */
  11 |     | import {Bankroll} from "src/Bankroll.sol";
  12 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  13 |     | import {DGBankrollFactory} from "src/DGBankrollFactory.sol";
  14 |     | import {DGEscrow} from "src/DGEscrow.sol";
  15 |     | 
  16 |     | /* DeGaming Libraries */
  17 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
  18 |     | 
  19 |     | /* Mock Contracts */
  20 |     | import {MockToken} from "test/mock/MockToken.sol";
  21 |     | 
  22 |     | contract DGBankrollManagerTest is Test {
  23 |     |     MockToken public mockToken;
  24 |     |     DGBankrollManager public dgBankrollManager;
  25 |     |     DGEscrow public dgEscrow;
  26 |     |     Bankroll public bankroll;
  27 |     |     DGBankrollFactory public dgBankrollFactory;
  28 |     |     TransparentUpgradeableProxy public bankrollProxy;
  29 |     | 
  30 |     |     ProxyAdmin public proxyAdmin;
  31 |     | 
  32 |     |     address admin;
  33 |     |     address deGaming;
  34 |     |     address operator;
  35 |     | 
  36 |     |     address[] operators;
  37 |     |     address[] lps;
  38 |     | 
  39 |     |     uint256 maxRisk = 10_000;
  40 |     |     uint256 threshold = 10_000;
  41 |     | 
  42 |     |     function setUp() public {
  43 |     |         admin = address(0x1);
  44 |     |         deGaming = address(0x2);
  45 |     |         operator = address(0x3);
  46 |     | 
  47 |     |         operators = [ 
  48 |     |             address(0x55), 
  49 |     |             address(0x56), 
  50 |     |             address(0x57),
  51 |     |             address(0x58),
  52 |     |             address(0x59),
  53 |     |             address(0x60)
  54 |     |         ];
  55 |     | 
  56 |     |         lps = [ 
  57 |     |             address(0x65), 
  58 |     |             address(0x66), 
  59 |     |             address(0x67),
  60 |     |             address(0x68),
  61 |     |             address(0x69),
  62 |     |             address(0x70)
  63 |     |         ];
  64 |     | 
  65 |     | 
  66 |     |         mockToken = new MockToken("Mock USDC", "mUSDC");
  67 |     | 
  68 |     |         dgBankrollFactory = new DGBankrollFactory();
  69 |     | 
  70 |     |         dgBankrollManager = new DGBankrollManager(deGaming);
  71 |     | 
  72 |     |         dgEscrow = new DGEscrow(1 weeks, address(dgBankrollManager));
  73 |     | 
  74 |     |         proxyAdmin = new ProxyAdmin();
  75 |     | 
  76 |     |         bankrollProxy = new TransparentUpgradeableProxy(
  77 |     |             address(new Bankroll()),
  78 |     |             address(proxyAdmin),
  79 |     |             abi.encodeWithSelector(
  80 |     |                 Bankroll.initialize.selector,
  81 |     |                 admin,
  82 |     |                 address(mockToken),
  83 |     |                 address(dgBankrollManager),
  84 |     |                 address(dgEscrow),
  85 |     |                 msg.sender,
  86 |     |                 maxRisk,
  87 |     |                 threshold
  88 |     |             )
  89 |     |         );
  90 |     | 
  91 |     |         bankroll = Bankroll(address(bankrollProxy));
  92 |     | 
  93 |     |         dgBankrollManager.grantRole(keccak256("ADMIN"), address(dgBankrollFactory));
  94 |     | 
  95 |     |         dgBankrollManager.grantRole(keccak256("ADMIN"), admin);
  96 |     | 
  97 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
  98 |     |         dgBankrollManager.approveBankroll(admin, 650);
  99 |     |         
 100 |     |         dgBankrollManager.approveBankroll(address(bankroll), 650);
 101 |     | 
 102 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), operator);
 103 |     | 
 104 |     |         mockToken.mint(admin, 1_000_000e6);
 105 |     | 
 106 |     |         vm.prank(admin);
 107 |     |     
 108 |     |         mockToken.approve(address(bankroll), 1_000_000e6);
 109 |     |     }
 110 |     | 
 111 |     |     function test_claimProfit() public {
 112 |     |         vm.startPrank(admin);
 113 |     |         bankroll.credit(1_000_000e6, operator);
 114 |     | 
 115 |     |         bankroll.maxContractsApprove();
 116 |     | 
 117 |     |         dgBankrollManager.claimProfit(address(bankroll));
 118 |     |         vm.stopPrank();
 119 |     |     }
 120 |     | 
 121 |     |     function test_claimProfit_nothingToClaim() public {
 122 |     |         vm.expectRevert(DGErrors.NOTHING_TO_CLAIM.selector);
 123 |     |         dgBankrollManager.claimProfit(address(bankroll));
 124 |     |     }
 125 |     | 
 126 |     |     function test_addOperator(address _operator) public {
 127 |     |         vm.assume(_operator != operator);
 128 |     |         vm.assume(!_isContract(_operator));
 129 |     | 
 130 |     |         vm.prank(admin);
 131 |     |         vm.expectRevert(DGErrors.NOT_AN_OPERATOR.selector);
 132 |     |         bankroll.credit(1_000_000e6, _operator);
 133 |     | 
 134 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_WALLET.selector);
 135 |     |         dgBankrollManager.addOperator(address(bankroll));
 136 |     | 
 137 |     |         dgBankrollManager.addOperator(_operator);
 138 |     | 
 139 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_WALLET.selector);
 140 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), address(bankroll));
 141 |     | 
 142 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), _operator);
 143 |     | 
 144 |     |         vm.expectRevert(DGErrors.OPERATOR_ALREADY_ADDED_TO_BANKROLL.selector);
 145 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), _operator);
 146 |     | 
 147 |     | 
 148 |     |         vm.prank(admin);
 149 |     |         bankroll.credit(1_000_000e6, _operator);
 150 |     | 
 151 |     |         assertEq(mockToken.balanceOf(address(bankroll)), 1_000_000e6);
 152 |     |     }
 153 |     | 
 154 |     |     function test_removeOperator(address _operator, address _operator2, address _operator3) public {
 155 |     |         vm.assume(_operator != operator);
 156 |     |         vm.assume(_operator2 != operator);
 157 |     |         vm.assume(_operator3 != operator);
 158 |     |         vm.assume(!_isContract(_operator));
 159 |     |         vm.assume(!_isContract(_operator2));
 160 |     |         vm.assume(!_isContract(_operator3));
 161 |     | 
 162 |     |         vm.prank(admin);
 163 |     |         
 164 |     |         vm.expectRevert(DGErrors.NOT_AN_OPERATOR.selector);
 165 |     |         bankroll.credit(1_000_000e6, _operator);
 166 |     | 
 167 |     |         dgBankrollManager.addOperator(_operator);
 168 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), _operator);
 169 |     |         vm.prank(admin);
 170 |     |         bankroll.credit(500_000e6, _operator);
 171 |     | 
 172 |     |         assertEq(mockToken.balanceOf(address(bankroll)), 500_000e6);
 173 |     | 
 174 |     |         dgBankrollManager.blockOperator(_operator);
 175 |     |         
 176 |     |         vm.prank(admin);
 177 |     |         vm.expectRevert(DGErrors.NOT_AN_OPERATOR.selector);
 178 |     |         bankroll.credit(500_000e6, _operator);
 179 |     | 
 180 |     |         dgBankrollManager.addOperator(_operator);
 181 |     |         dgBankrollManager.removeOperatorFromBankroll(_operator, address(bankroll));
 182 |     | 
 183 |     |         vm.prank(admin);
 184 |     |         vm.expectRevert(DGErrors.OPERATOR_NOT_ASSOCIATED_WITH_BANKROLL.selector);
 185 |     |         bankroll.credit(500_000e6, _operator);
 186 |     | 
 187 |     |         dgBankrollManager.addOperator(_operator);
 188 |     |         dgBankrollManager.addOperator(_operator2);
 189 |     |         dgBankrollManager.addOperator(_operator3);
 190 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), _operator);
 191 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), _operator2);
 192 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), _operator3);
 193 |     | 
 194 |     |         vm.startPrank(admin);
 195 |     |         bankroll.credit(1e6, _operator2);
 196 |     |         bankroll.credit(1e6, _operator3);
 197 |     |         vm.stopPrank();
 198 |     | 
 199 |     |         dgBankrollManager.removeOperatorFromBankroll(_operator2, address(bankroll));
 200 |     | 
 201 |     |         vm.prank(admin);
 202 |     |         vm.expectRevert(DGErrors.OPERATOR_NOT_ASSOCIATED_WITH_BANKROLL.selector);
 203 |     |         bankroll.credit(1e6, _operator2);
 204 |     |     }
 205 |     | 
 206 |     |     function test_updateFee(uint256 _newFee, uint256 _faultyFee, address _faultyBankroll, address _notAdmin) public {
 207 |     |         vm.assume(_newFee < 10_000);
 208 |     |         vm.assume(_faultyFee > 10_000);
 209 |     |         vm.assume(_faultyBankroll != address(bankroll));
 210 |     |         vm.assume(_notAdmin != address(dgBankrollFactory));
 211 |     |         vm.assume(_notAdmin != msg.sender);
 212 |     | 
 213 |     |         vm.expectRevert();
 214 |     |         vm.prank(_notAdmin);
 215 |     |         dgBankrollManager.updateLpFee(address(bankroll), _newFee);
 216 |     | 
 217 |     |         vm.expectRevert(DGErrors.BANKROLL_NOT_APPROVED.selector);
 218 |     |         dgBankrollManager.updateLpFee(_faultyBankroll, _newFee);
 219 |     | 
 220 |     |         vm.expectRevert(DGErrors.TO_HIGH_FEE.selector);
 221 |     |         dgBankrollManager.updateLpFee(address(bankroll), _faultyFee);
 222 |     | 
 223 |     |         dgBankrollManager.updateLpFee(address(bankroll), _newFee);
 224 |     | 
 225 |     |         assertEq(dgBankrollManager.lpFeeOf(address(bankroll)), _newFee);
 226 |     |     }
 227 |     | 
 228 |     |     function test_setDeGaming(address _newDegaming) public {
 229 |     |         vm.assume(_newDegaming != deGaming);
 230 |     |         assertEq(dgBankrollManager.deGaming(), deGaming);
 231 |     | 
 232 |     |         dgBankrollManager.setDeGaming(_newDegaming);
 233 |     |         assertEq(dgBankrollManager.deGaming(), _newDegaming);
 234 |     |     }
 235 |     | 
 236 |     |     function test_blockBankroll() public {
 237 |     |         vm.prank(admin);
 238 |     |         bankroll.credit(1_000_000e6, operator);
 239 |     | 
 240 |     |         dgBankrollManager.blockBankroll(address(bankroll));
 241 |     | 
 242 |     |         vm.expectRevert(DGErrors.BANKROLL_NOT_APPROVED.selector);
 243 |     |         dgBankrollManager.claimProfit(address(bankroll));
 244 |     |     }
 245 |     | 
 246 |     |     function test_feeOutOfRangeError(uint256 _fee, address _newBankroll) public {
 247 |     |         vm.assume(_fee > 10_000);
 248 |     | 
 249 |     |         vm.expectRevert(DGErrors.TO_HIGH_FEE.selector);
 250 |     |         dgBankrollManager.approveBankroll(_newBankroll, _fee);
 251 |     |     }
 252 |     | 
 253 |     |     function test_feeIsCorrect(uint256 _wager) public {
 254 |     |         vm.assume(_wager > 10_000e6);
 255 |     |         vm.assume(_wager < 1_000_000e6);
 256 |     | 
 257 |     |         mockToken.mint(admin, _wager * 5);
 258 |     | 
 259 |     |         assertEq(mockToken.balanceOf(address(bankroll)), 0);
 260 |     | 
 261 |     |         vm.prank(admin);
 262 |     |         bankroll.credit(_wager, operator); 
 263 |     | 
 264 |     |         assertEq(mockToken.balanceOf(address(bankroll)), _wager);
 265 |     | 
 266 |     |         vm.startPrank(admin);
 267 |     |         bankroll.maxContractsApprove();
 268 |     | 
 269 |     |         dgBankrollManager.claimProfit(address(bankroll));
 270 |     |         vm.stopPrank();
 271 |     | 
 272 |     |         uint256 expectedBalance = (_wager * 650) / 10_000;
 273 |     | 
 274 |     |         assertEq(mockToken.balanceOf(address(bankroll)), expectedBalance);
 275 |     | 
 276 |     |         assertEq(mockToken.balanceOf(deGaming), _wager - expectedBalance);
 277 |     |     }
 278 |     | 
 279 |     |     function test_multipleOperators(uint256 _wager) public {
 280 |     |         vm.assume(_wager < 150_000e6 && _wager > 500e6);
 281 |     | 
 282 |     |         uint256 totalWagered; 
 283 |     |         for (uint256 i = 0; i < operators.length; i++) {
 284 |     |             dgBankrollManager.setOperatorToBankroll(address(bankroll), operators[i]);
 285 |     | 
 286 |     |             vm.prank(admin);
 287 |     |             bankroll.credit(_wager, operators[i]);
 288 |     |              
 289 |     |             assertEq(mockToken.balanceOf(address(bankroll)), totalWagered + _wager);
 290 |     | 
 291 |     |             totalWagered += _wager;
 292 |     |         }
 293 |     | 
 294 |     |         assertEq(totalWagered, _wager * operators.length);
 295 |     | 
 296 |     |         uint256 expectedBalance = (totalWagered * 650) / 10_000;
 297 |     | 
 298 |     |         vm.startPrank(admin);
 299 |     |         bankroll.maxContractsApprove();
 300 |     | 
 301 |     |         dgBankrollManager.claimProfit(address(bankroll));
 302 |     |         vm.stopPrank();
 303 |     | 
 304 |     |         assertApproxEqAbs(mockToken.balanceOf(address(bankroll)), expectedBalance, 5);
 305 |     | 
 306 |     |         assertApproxEqAbs(mockToken.balanceOf(deGaming), totalWagered - expectedBalance, 5);
 307 |     |     }
 308 |     | 
 309 |     |     function test_multipleLPs(uint256 _liquidity, uint256 _wager, uint256 _rand) public {
 310 |     |         vm.assume(_liquidity > 500e6 && _liquidity < 1_000_000_000e6);
 311 |     |         vm.assume(_wager < 1_000_000e6 && _wager > 500e6);
 312 |     | 
 313 |     |         uint256 rand = _rand % 5;
 314 |     | 
 315 |     |         for (uint256 i = 0; i < lps.length; i++) {
 316 |     |             vm.assume(lps[i] != address(0));
 317 |     |             mockToken.mint(lps[i], _liquidity);
 318 |     | 
 319 |     |             vm.startPrank(lps[i]);
 320 |     |             mockToken.approve(address(bankroll), _liquidity);
 321 |     |             bankroll.depositFunds(_liquidity);
 322 |     |             vm.stopPrank();
 323 |     |         }
 324 |     | 
 325 |     |         for (uint256 i = 0; i < lps.length; i++) {
 326 |     |             mockToken.mint(admin, _wager);
 327 |     |             vm.startPrank(admin);
 328 |     |             mockToken.approve(address(bankroll), _wager);
 329 |     |             bankroll.credit(_wager, operator);
 330 |     |             vm.stopPrank();
 331 |     |         }
 332 |     | 
 333 |     |         vm.prank(admin);
 334 |     |         bankroll.maxContractsApprove();
 335 |     | 
 336 |     |         assertEq(mockToken.balanceOf(address(bankroll)), (_wager + _liquidity) * lps.length);
 337 |     | 
 338 |     |         vm.prank(admin);
 339 |     |         dgBankrollManager.claimProfit(address(bankroll));
 340 |     | 
 341 |     |         uint256 expectedValue = _liquidity + (_wager * 650)/ 10_000;
 342 |     | 
 343 |     |         assertEq(expectedValue, bankroll.getLpValue(lps[rand]));
 344 |     |     }
 345 |     | 
 346 |     |     function test_updateEventPeriod(uint256 _newEventPeriod, address _wrongBankroll) public {
 347 |     |         assertEq(dgBankrollManager.eventPeriodOf(address(bankroll)), 30 days);
 348 |     | 
 349 |     |         vm.expectRevert(DGErrors.BANKROLL_NOT_APPROVED.selector);
 350 |     |         dgBankrollManager.updateEventPeriod(_wrongBankroll, _newEventPeriod);
 351 |     | 
 352 |     |         dgBankrollManager.updateEventPeriod(address(bankroll), _newEventPeriod);
 353 |     | 
 354 |     |         assertEq(dgBankrollManager.eventPeriodOf(address(bankroll)), _newEventPeriod);
 355 |     |     }
 356 |     | 
 357 |     |     /**
 358 |     |      * @notice
 359 |     |      *  Allows contract to check if the Token address actually is a contract
 360 |     |      *
 361 |     |      * @param _address address we want to  check
 362 |     |      *
 363 |     |      * @return _isAddressContract returns true if token is a contract, otherwise returns false
 364 |     |      *
 365 |     |      */
 366 |     |     function _isContract(address _address) internal view returns (bool _isAddressContract) {
 367 |     |         uint256 size;
 368 |     | 
 369 |     |         assembly {
 370 |     |             size := extcodesize(_address)
 371 |     |         }
 372 |     | 
 373 |     |         _isAddressContract = size > 0;
 374 |     |     }
 375 |     | }
 376 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/test/contracts/DGEscrow.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.19;
   3 |     | 
   4 |     | import "forge-std/Test.sol";
   5 |     | 
   6 |     | /* OpenZeppelin contract */
   7 |     | import {TransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
   8 |     | import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
   9 |     | 
  10 |     | /* DeGaming Contracts */
  11 |     | import {Bankroll} from "src/Bankroll.sol";
  12 |     | import {DGBankrollManager} from "src/DGBankrollManager.sol";
  13 |     | import {DGBankrollFactory} from "src/DGBankrollFactory.sol";
  14 |     | import {DGEscrow} from "src/DGEscrow.sol";
  15 |     | 
  16 |     | /* DeGaming Libraries */
  17 |     | import {DGErrors} from "src/libraries/DGErrors.sol";
  18 |     | import {DGDataTypes} from "src/libraries/DGDataTypes.sol";
  19 |     | 
  20 |     | /* Mock Contracts */
  21 |     | import {MockToken} from "test/mock/MockToken.sol";
  22 |     | 
  23 |     | contract DGEscrowTest is Test {
  24 |     |     address admin;
  25 |     |     address operator;
  26 |     |     address lpOne;
  27 |     |     address lpTwo;
  28 |     |     address player;
  29 |     |     address owner;
  30 |     |     uint256 maxRisk;
  31 |     |     uint256 threshold;
  32 |     |     TransparentUpgradeableProxy public bankrollProxy;
  33 |     | 
  34 |     |     ProxyAdmin public proxyAdmin;
  35 |     | 
  36 |     |     DGBankrollFactory public dgBankrollFactory;
  37 |     |     DGBankrollManager public dgBankrollManager;
  38 |     |     DGEscrow public dgEscrow;
  39 |     |     Bankroll public bankroll;
  40 |     |     MockToken public token;
  41 |     | 
  42 |     |     function setUp() public {
  43 |     |         admin = address(0x1);
  44 |     |         operator = address(0x2);
  45 |     |         lpOne = address(0x3);
  46 |     |         lpTwo = address(0x4);
  47 |     |         player = address(0x5);
  48 |     |         owner = address(0x6);
  49 |     |         maxRisk = 10_000;
  50 |     |         threshold = 10_000;
  51 |     | 
  52 |     |         dgBankrollFactory = new DGBankrollFactory();
  53 |     | 
  54 |     |         dgBankrollManager = new DGBankrollManager(admin);
  55 |     |         token = new MockToken("token", "MTK");
  56 |     | 
  57 |     |         dgEscrow = new DGEscrow(1 weeks, address(dgBankrollManager));
  58 |     | 
  59 |     |         proxyAdmin = new ProxyAdmin();
  60 |     | 
  61 |     |         bankrollProxy = new TransparentUpgradeableProxy(
  62 |     |             address(new Bankroll()),
  63 |     |             address(proxyAdmin),
  64 |     |             abi.encodeWithSelector(
  65 |     |                 Bankroll.initialize.selector,
  66 |     |                 admin,
  67 |     |                 address(token),
  68 |     |                 address(dgBankrollManager),
  69 |     |                 address(dgEscrow),
  70 |     |                 owner,
  71 |     |                 maxRisk,
  72 |     |                 threshold
  73 |     |             )
  74 |     |         );
  75 |     | 
  76 |     |         bankroll = Bankroll(address(bankrollProxy));
  77 |     | 
  78 |     |         token.mint(lpOne, 1_000_000e6);
  79 |     |         token.mint(lpTwo, 1_000_000e6);
  80 |     |         token.mint(admin, 1_000_000e6);
  81 |     | 
  82 |     |         dgBankrollManager.addOperator(operator);
  83 |     |         dgBankrollManager.approveBankroll(address(bankroll), 0);
  84 |     |         dgBankrollManager.setOperatorToBankroll(address(bankroll), operator);
  85 |     | 
  86 |     |         vm.startPrank(lpOne);
  87 |     |         token.approve(address(bankroll), 1_000_000e6);
  88 |     |         bankroll.depositFunds(1_000_000e6);
  89 |     |         vm.stopPrank();
  90 |     | 
  91 |     |         vm.startPrank(admin);
  92 |     | 
  93 |     |         bankroll.changeEscrowThreshold(5_000);
  94 |     | 
  95 |     |         bankroll.maxContractsApprove();
  96 |     |         vm.stopPrank();
  97 |     |     }
  98 |     | 
  99 |     |     function test_depositFundsEscrow() public {
 100 |     |         vm.startPrank(admin);
 101 |     |         token.approve(address(bankroll), 500e6);
 102 |     | 
 103 |     |         bankroll.debit(player, 500_001e6, operator);
 104 |     | 
 105 |     |         vm.stopPrank();
 106 |     | 
 107 |     |         assertEq(token.balanceOf(address(dgEscrow)), 500_001e6);
 108 |     |     }
 109 |     |     
 110 |     |     function test_revertFunds() public {
 111 |     |         vm.startPrank(admin);
 112 |     |         token.approve(address(bankroll), 500e6);
 113 |     | 
 114 |     |         bankroll.debit(player, 500_001e6, operator);
 115 |     | 
 116 |     |         vm.stopPrank();
 117 |     | 
 118 |     |         assertEq(token.balanceOf(address(dgEscrow)), 500_001e6);
 119 |     | 
 120 |     |         DGDataTypes.EscrowEntry memory entry = DGDataTypes.EscrowEntry(
 121 |     |             address(bankroll),
 122 |     |             operator,
 123 |     |             player,
 124 |     |             address(token),
 125 |     |             block.timestamp
 126 |     |         );
 127 |     | 
 128 |     |         bytes memory id = abi.encode(entry);
 129 |     | 
 130 |     |         dgEscrow.revertFunds(id);
 131 |     | 
 132 |     |         assertEq(token.balanceOf(address(dgEscrow)), 0);
 133 |     |     }
 134 |     |     
 135 |     |     function test_releaseFunds() public {
 136 |     |         vm.startPrank(admin);
 137 |     |         token.approve(address(bankroll), 500e6);
 138 |     | 
 139 |     |         bankroll.debit(player, 500_001e6, operator);
 140 |     | 
 141 |     |         vm.stopPrank();
 142 |     | 
 143 |     |         assertEq(token.balanceOf(address(dgEscrow)), 500_001e6);
 144 |     | 
 145 |     |         DGDataTypes.EscrowEntry memory entry = DGDataTypes.EscrowEntry(
 146 |     |             address(bankroll),
 147 |     |             operator,
 148 |     |             player,
 149 |     |             address(token),
 150 |     |             block.timestamp
 151 |     |         );
 152 |     | 
 153 |     |         bytes memory id = abi.encode(entry);
 154 |     | 
 155 |     |         dgEscrow.releaseFunds(id);
 156 |     |         assertEq(token.balanceOf(address(player)), 500_001e6);
 157 |     |         assertEq(token.balanceOf(address(dgEscrow)), 0);
 158 |     |     }
 159 |     | 
 160 |     |     function test_claimUnaddressed(uint256 _time) public {
 161 |     |         vm.assume(_time < 10 hours);
 162 |     |         dgEscrow.setEventPeriod(_time);
 163 |     | 
 164 |     |         vm.startPrank(admin);
 165 |     |         token.approve(address(bankroll), 500e6);
 166 |     | 
 167 |     |         bankroll.debit(player, 500_001e6, operator);
 168 |     | 
 169 |     |         vm.stopPrank();
 170 |     | 
 171 |     |         DGDataTypes.EscrowEntry memory entry = DGDataTypes.EscrowEntry(
 172 |     |             address(bankroll),
 173 |     |             operator,
 174 |     |             player,
 175 |     |             address(token),
 176 |     |             block.timestamp
 177 |     |         );
 178 |     | 
 179 |     |         bytes memory id = abi.encode(entry);
 180 |     | 
 181 |     |         vm.warp(_time + 1);
 182 |     | 
 183 |     |         vm.prank(player);
 184 |     | 
 185 |     |         dgEscrow.claimUnaddressed(id);
 186 |     | 
 187 |     |         assertEq(token.balanceOf(player), 500_001e6);
 188 |     |     }
 189 |     | 
 190 |     |     function test_updateManager_escrow(address _faultyManager) external {
 191 |     |         vm.assume(!_isContract(_faultyManager));
 192 |     | 
 193 |     |         address oldManager = address(dgEscrow.dgBankrollManager());
 194 |     | 
 195 |     |         DGBankrollManager newManager = new DGBankrollManager(admin);
 196 |     | 
 197 |     |         vm.expectRevert(DGErrors.ADDRESS_NOT_A_CONTRACT.selector);
 198 |     |         dgEscrow.updateBankrollManager(_faultyManager);
 199 |     | 
 200 |     |         dgEscrow.updateBankrollManager(address(newManager));
 201 |     | 
 202 |     |         assertNotEq(oldManager, address(newManager));
 203 |     |     }
 204 |     | 
 205 |     |     function _isContract(address _address) internal view returns (bool _isAddressContract) {
 206 |     |         uint256 size;
 207 |     | 
 208 |     |         assembly {
 209 |     |             size := extcodesize(_address)
 210 |     |         }
 211 |     | 
 212 |     |         _isAddressContract = size > 0;
 213 |     |     }
 214 |     | }
 215 |     | 

/Users/aboutika/Documents/Echidna/BankrollKickOff/bankroll-contracts/test/mock/MockToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | /* Openzeppelin Contract */
  5 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  6 |     | 
  7 | *   | contract MockToken is ERC20 {
  8 |     |     constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}
  9 |     | 
 10 | *   |     function mint(address _user, uint256 _quantity) external {
 11 | *   |         _mint(_user, _quantity);
 12 |     |     }
 13 |     | }
 14 |     | 

